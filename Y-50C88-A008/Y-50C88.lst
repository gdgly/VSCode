---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\main.c ----------------------------------------------------------------------
1:                /******************Copyright (c)*******************************
2:                
3:                              杭州九阳欧南多小家电有限公司
4:                                http://www.joyoung.com.cn
5:                
6:                *********************文件信息*********************************
7:                机型名称:	 Y-50C88
8:                创 建 人:	 
9:                创建日期:    2019/4/4
10:               *********************硬件信息描述******************************
11:               *NTC:       R25=100K  B=3990
12:               *BUZZER:    5V,4KHZ
13:               *SWIM_H:    通强电
14:               *SWIM_L:    无
15:               *LID:       干簧管
16:               
17:               *******************历史版本信息******************************* 
18:               * @history 
19:               * 2019-3-20 C001 checksum 96F8    初版程序
20:               * 2019-5-21  A002 checksum 8D4C    
21:               	1.芯片由SOP32改为LQFP32封装，KEY及DISPLAY相应端口更改，更改了ADC中电压检测部分
22:               	2.E3报警问题：开始工作后，断电会显示E3报警（错误处理加增加延时1S）
23:               	3.工厂测试报警温度：130度改为135度
24:               * 2019-5-21  A003 checksum 7D71
25:               	1.修复按某一按键上电会乱码，在按键扫码过程禁用LED模块
26:               	2.进入工厂模式改为长按预约+取消
27:               	3.IO口默认配置改为输入
28:               * 2019-6-15  A004  checksum  7A02
29:               * 2019-6-18  A005  checksum  7A0A   压力开关断开判定值改为15
30:               * 2019-8-12  A006  checksum  57D6   E3延迟报警，底部温度低于80C先闭合继电器
31:               * 2019-8-14  A007  checksum  57D6   增加防串码显示
32:                
33:               **************************************************************/
34:               
35:               #include "board_define.h"
36:               
37:               
38:               /***********************************************
39:               函数名称：Init_PWM
40:               备注：	//PWM周期 = [(PR2)+1]*4*(1/Fosc)*(TMR2预分频值)
41:               		//脉冲宽度 = (CCPRxL:PWMxD<1:0>*(1/Fosc)*(TMR2预分频值)
42:               		//占空比 = (CCPRxL:PWMxD<1:0>)/(4*(PR2+1))
43:               ************************************************/
44:               void Init_PWM(void)
45:               {
46:               	PR2 = 124;	                            //周期((124+1)*4*(1/8)*4) = 250us							
  03AE    307C    LDIA	0x7C
  03AF    1683    SETB	0x3,5
  03B0    0092    LD	0x12,A
47:               	CCPR0L = 0x3E;							//PWM0占空比(250/(4*(124+1))) = 50%			
  03B1    303E    LDIA	0x3E
  03B2    1283    CLRB	0x3,5
  03B3    009B    LD	0x1B,A
48:               	PWMCON = 0b00100000;                    //PWM0-RC2,PWM1-RC3,使能PWM0
  03B4    3020    LDIA	0x20
  03B5    009D    LD	0x1D,A
49:               	TMR2IF = 0;              				//清零PIR1寄存器中的TMR2IF中断标志位
  03B6    108C    CLRB	0xC,1
50:               	T2CKPS0 = 1;             				//定时器TMR2设置1:4预分频比，T2CKPS0=0
  03B7    1412    SETB	0x12,0
51:               	T2CKPS1 = 0;             				//定时器TMR2设置1:4预分频比，T2CKPS1=1
  03B8    1092    CLRB	0x12,1
52:               	TMR2ON = 1;              				//T2CON寄存器中的TMR2ON位置1使能Timer2	
  03B9    1512    SETB	0x12,2
  03BA    0008    RET
53:               }
54:               
55:               /*-------------------------------------------
56:               程序名称：Init_TMR1
57:               备注：	  定时时间计算方法
58:               		  定时时间T = {1/[(Fosc)*预分频比)]}*(65536-[TMR1H:TMR1L])
59:               		  本程序计算示例：
60:               		  T = {1/[(8)*1]}*(65536 - 63536)
61:               			= 250 us
62:               -------------------------------------------*/
63:               void Init_TMR1(void)
64:               {
65:               	TMR1L = 0x30;			//赋初值
  03BB    3030    LDIA	0x30
  03BC    1283    CLRB	0x3,5
  03BD    008E    LD	0xE,A
66:               	TMR1H = 0xF8;
  03BE    30F8    LDIA	0xF8
  03BF    008F    LD	0xF,A
67:               	TMR1IF = 0;				//清中断标志位
  03C0    100C    CLRB	0xC,0
68:               	TMR1IE = 1;				//允许Timer1中断	
  03C1    1683    SETB	0x3,5
  03C2    140C    SETB	0xC,0
69:               	T1CON = 0x01;			//开启Timer1，使用内部时钟源Fosc，预分频比为1:1
  03C3    3001    LDIA	0x1
  03C4    1283    CLRB	0x3,5
  03C5    0090    LD	0x10,A
  03C6    0008    RET
70:               }
71:               
72:               void Init_GPIO(void)
73:               {
74:                   //init_GPIO
75:               	//配置IO初始状态，按键检测口开上拉
76:               	WPUA  = 0B00000000;  	
  0389    1703    SETB	0x3,6
  038A    018E    CLR	0xE
77:               	WPUB  = 0B00000000;  	
  038B    1303    CLRB	0x3,6
  038C    0195    CLR	0x15
78:               	WPUC  = 0B00000000;  				
  038D    1703    SETB	0x3,6
  038E    018F    CLR	0xF
79:               	WPUD  = 0B00000000;
  038F    0185    CLR	0x5
80:               	
81:               	/*配置引脚电平
82:               	*/							
83:               	PORTA = 0B00000000;		
  0390    1283    CLRB	0x3,5
  0391    1303    CLRB	0x3,6
  0392    0185    CLR	0x5
84:               	PORTB = 0B00000000;		
  0393    0186    CLR	0x6
85:               	PORTC = 0B00000000;		
  0394    0187    CLR	0x7
86:               	PORTD = 0B00000000;
  0395    0188    CLR	0x8
87:               	
88:               	/*配置输入输出状态
89:               	  1: 输入
90:               	  0: 输出
91:               	*/  		
92:               	TRISA = 0B11111111;     	
  0396    30FF    LDIA	0xFF
  0397    1683    SETB	0x3,5
  0398    0085    LD	0x5,A
93:               	TRISB = 0B11111111; 
  0399    0086    LD	0x6,A
94:               	TRISC = 0B11111101;     //RC0 LID输入  RC1 REL输出  RC4 BOT输入   RC5 SWIN输入
  039A    30FD    LDIA	0xFD
  039B    0087    LD	0x7,A
95:               	TRISD = 0B11111111;  
  039C    30FF    LDIA	0xFF
  039D    0088    LD	0x8,A
  039E    0008    RET
96:               
97:               		
98:               }
99:               
100:              void Init_Var(void)
101:              {
102:              	//变量初始化
103:              	SysStatus = POWERON_MODE;      //上电系统状态	
  03C7    3006    LDIA	0x6
  03C8    1303    CLRB	0x3,6
  03C9    00EA    LD	0x6A,A
104:              	AC_Vol_Rms = 220;              //上电默认电压220V
  03CA    30DC    LDIA	0xDC
  03CB    00E7    LD	0x67,A
  03CC    01E8    CLR	0x68
105:              	Vrms_Level = VRMS_LEVEL_220;   //上电默认电压档
  03CD    3003    LDIA	0x3
  03CE    00E9    LD	0x69,A
  03CF    0008    RET
106:              }
107:              
108:              
109:              //系统初始化
110:              void Init_System(void)
  0363    0000    NOP
  0364    0064    CLRWDT
111:              {
112:              	/*配置系统寄存器*/	
113:              	asm("nop");
114:              	asm("clrwdt");
115:              	INTCON = 0;				//禁止中断
  0365    018B    CLR	0xB
116:              	OSCCON = 0X71;			//上电配置振荡为8M
  0366    3071    LDIA	0x71
  0367    1683    SETB	0x3,5
  0368    1303    CLRB	0x3,6
  0369    008F    LD	0xF,A
117:              	OPTION_REG = 0x03;      //看门狗和TMR0预分频器   144ms复位  0x03 144*8=1152
  036A    3003    LDIA	0x3
  036B    0081    LD	0x1,A
118:              	
119:              	/*初始化外设*/
120:              	Init_GPIO();
  036C    2389    CALL	0x389
  036D    120A    CLRB	0xA,4
  036E    118A    CLRB	0xA,3
121:              	Init_TMR1();
  036F    23BB    CALL	0x3BB
  0370    120A    CLRB	0xA,4
  0371    118A    CLRB	0xA,3
122:              	Init_PWM();
  0372    23AE    CALL	0x3AE
  0373    120A    CLRB	0xA,4
  0374    118A    CLRB	0xA,3
123:              	Init_LED_Module();    //初始化LED模块
  0375    239F    CALL	0x39F
  0376    120A    CLRB	0xA,4
  0377    118A    CLRB	0xA,3
124:              	Init_Var();
  0378    23C7    CALL	0x3C7
  0379    120A    CLRB	0xA,4
  037A    118A    CLRB	0xA,3
125:              	
126:              	//上电延时 非精准300ms
127:              	DelayXms(300); 
  037B    302C    LDIA	0x2C
  037C    00DA    LD	0x5A,A
  037D    3001    LDIA	0x1
  037E    00DB    LD	0x5B,A
  037F    23D0    CALL	0x3D0
128:              	
129:              	/****************************************/
130:              	/*增加自检函数*/  
131:              	
132:              	 	
133:              	//开启总中断	
134:              	INTCON = 0XC0;
  0380    30C0    LDIA	0xC0
  0381    008B    LD	0xB,A
135:              	//上电声音
136:              	POWERON_SOUND;   	
  0382    3001    LDIA	0x1
  0383    00D7    LD	0x57,A
  0384    307D    LDIA	0x7D
  0385    00D6    LD	0x56,A
  0386    120A    CLRB	0xA,4
  0387    158A    SETB	0xA,3
  0388    2FD5    JP	0x7D5
137:              }
138:              
139:              
140:              /***********************************************************
141:              定时器1中断服务函数  250us
142:              ***********************************************************/
143:              void interrupt Timer1_Isr()
144:              {
145:              	if(TMR1IF)				
  002C    1283    CLRB	0x3,5
  002D    1303    CLRB	0x3,6
  002E    1C0C    SNZB	0xC,0
  002F    2871    JP	0x71
146:              	{
147:              	    //---------------------------------------
148:              		TMR1L += 0x30;     //重新赋初值，在赋值前Timer1已有计数，故在该基础上加初值
  0030    3030    LDIA	0x30
  0031    078E    ADDR	0xE
149:              		TMR1H += 0xF8;	   //在进入中断等过程中其实Time是一直在计数的									
  0032    30F8    LDIA	0xF8
  0033    078F    ADDR	0xF
150:              	    //---------------------------------------	
151:              
152:              		Operate_Relay_IO();		               //继电器动作函数			
  0034    2148    CALL	0x148
  0035    120A    CLRB	0xA,4
  0036    118A    CLRB	0xA,3
153:              		Ad_Pressure_Raw = Get_AD(ADC_AN19);	   //每250us获取一个原始底部压力开关AD值  		
  0037    3013    LDIA	0x13
  0038    2078    CALL	0x78
  0039    120A    CLRB	0xA,4
  003A    118A    CLRB	0xA,3
  003B    1283    CLRB	0x3,5
  003C    00D2    LD	0x52,A
154:              		Get_Pressure_Switch_Data();	           //读取压力开关信号		
  003D    20D1    CALL	0xD1
  003E    120A    CLRB	0xA,4
  003F    118A    CLRB	0xA,3
155:              		Get_Zero();                            //读取过零信号
  0040    20FD    CALL	0xFD
  0041    120A    CLRB	0xA,4
  0042    118A    CLRB	0xA,3
156:              							
157:              		if(b_VolData_OK == 0)
  0043    1A72    SZB	0x72,4
  0044    2848    JP	0x48
158:              		{
159:              			Get_AC_Voltage();	              //获取AC电压AD平均值	
  0045    20AB    CALL	0xAB
  0046    120A    CLRB	0xA,4
  0047    118A    CLRB	0xA,3
160:              		}
161:              									
162:              		//主循环8ms
163:              		if(++MainTime_8ms >= 32)
  0048    3020    LDIA	0x20
  0049    1683    SETB	0x3,5
  004A    0AC1    INCR	0x41
  004B    0241    SUBA	0x41
  004C    1C03    SNZB	0x3,0
  004D    2859    JP	0x59
164:              		{			
165:              			MainTime_8ms = 0;
  004E    01C1    CLR	0x41
166:              			b_MainLoop_8ms = 1;
  004F    14F0    SETB	0x70,1
167:              			
168:              			if(b_AdBot_OK == 0)
  0050    1BF1    SZB	0x71,7
  0051    2859    JP	0x59
169:              			{
170:              				Ad_Bot_Raw = Get_AD(ADC_AN20);     //每8ms获取一个原始底部温度AD值	
  0052    3014    LDIA	0x14
  0053    2078    CALL	0x78
  0054    120A    CLRB	0xA,4
  0055    118A    CLRB	0xA,3
  0056    1283    CLRB	0x3,5
  0057    00D0    LD	0x50,A
171:              				b_AdBot_OK = 1;
  0058    17F1    SETB	0x71,7
172:              			}						
173:              		}
174:              		
175:              		//10ms循环
176:              		if(++MainTime_10ms >= 40)
  0059    3028    LDIA	0x28
  005A    1683    SETB	0x3,5
  005B    0AC0    INCR	0x40
  005C    0240    SUBA	0x40
  005D    1C03    SNZB	0x3,0
  005E    286F    JP	0x6F
177:              		{
178:              			MainTime_10ms = 0;
  005F    01C0    CLR	0x40
179:              			
180:              			//主循环500ms
181:              			if(++MainTime_500ms >= 50)
  0060    3032    LDIA	0x32
  0061    0AC9    INCR	0x49
  0062    0249    SUBA	0x49
  0063    1C03    SNZB	0x3,0
  0064    2867    JP	0x67
182:              			{
183:              				MainTime_500ms = 0;
  0065    01C9    CLR	0x49
184:              				b_MainLoop_500ms = 1;					
  0066    1470    SETB	0x70,0
185:              			}
186:              			//LED闪烁标志位
187:              			if(++LedCol_500ms >= 50)
  0067    3032    LDIA	0x32
  0068    0ACB    INCR	0x4B
  0069    024B    SUBA	0x4B
  006A    1C03    SNZB	0x3,0
  006B    286F    JP	0x6F
188:              			{
189:              				LedCol_500ms = 0;
  006C    01CB    CLR	0x4B
190:              				b_LedCol = ~b_LedCol;					
  006D    3020    LDIA	0x20
  006E    06F0    XORR	0x70
191:              			}				
192:              		}						
193:              		TMR1IF = 0;	
  006F    1283    CLRB	0x3,5
  0070    100C    CLRB	0xC,0
  0071    0878    LD	A,0x78
  0072    008A    LD	0xA,A
  0073    0E77    SWAPA	0x77
  0074    0083    LD	0x3,A
  0075    0EFE    SWAPR	0x7E
  0076    0E7E    SWAPA	0x7E
  0077    0009    RETI
194:              								
195:              	}
196:              }
197:              
198:              /***********************************************************
199:              主循环
200:              ***********************************************************/
201:              void main()
202:              {
203:              	Init_System();
  0468    120A    CLRB	0xA,4
  0469    118A    CLRB	0xA,3
  046A    2363    CALL	0x363
204:              	
205:              	while(1)
  046D    0064    CLRWDT
206:              	{
207:              		CLRWDT();
208:              		//主循环8ms   循环内任务最大耗时约4ms
209:              		if(b_MainLoop_8ms)
  046E    1CF0    SNZB	0x70,1
  046F    2CD2    JP	0x4D2
210:              		{
211:              			b_MainLoop_8ms = 0;
  0470    10F0    CLRB	0x70,1
212:              			
213:              			//上电模式1s
214:              			if(SysStatus == POWERON_MODE)
  0471    3006    LDIA	0x6
  0472    1283    CLRB	0x3,5
  0473    1303    CLRB	0x3,6
  0474    066A    XORA	0x6A
  0475    1D03    SNZB	0x3,2
  0476    2CA1    JP	0x4A1
215:              			{
216:              				if(++WaitCycle >= 125)
  0477    307D    LDIA	0x7D
  0478    0AA9    INCR	0x29
  0479    0229    SUBA	0x29
  047A    1C03    SNZB	0x3,0
  047B    2C7F    JP	0x47F
217:              				{
218:              					WaitCycle = 0;
  047C    01A9    CLR	0x29
219:              					SysStatus = WAITING_MODE;	
  047D    3001    LDIA	0x1
  047E    00EA    LD	0x6A,A
220:              				}		
221:              
222:              				if(WaitCycle >= 60)
  047F    303C    LDIA	0x3C
  0480    0229    SUBA	0x29
  0481    1C03    SNZB	0x3,0
  0482    2CA1    JP	0x4A1
223:              				{
224:              					//自动进入工装检测的条件
225:              					if((Ad_Bot_Raw >= 158 && Ad_Bot_Raw <= 168) && (Ad_Pressure_Raw >= 238 && Ad_Pressure_Raw <= 248) && b_LidClosed == TRUE)
  0483    309E    LDIA	0x9E
  0484    0250    SUBA	0x50
  0485    1C03    SNZB	0x3,0
  0486    2CA1    JP	0x4A1
  0487    30A9    LDIA	0xA9
  0488    0250    SUBA	0x50
  0489    1803    SZB	0x3,0
  048A    2CA1    JP	0x4A1
  048B    30EE    LDIA	0xEE
  048C    0252    SUBA	0x52
  048D    1C03    SNZB	0x3,0
  048E    2CA1    JP	0x4A1
  048F    30F9    LDIA	0xF9
  0490    0252    SUBA	0x52
  0491    1C03    SNZB	0x3,0
  0492    1FF2    SNZB	0x72,7
  0493    2CA1    JP	0x4A1
226:              					{
227:              						SysStatus = FACTORY_TEST_MODE;
  0494    3005    LDIA	0x5
  0495    00EA    LD	0x6A,A
228:              						FactoryTestData = 0;
  0496    01C1    CLR	0x41
229:              						b_Auto_test = TRUE;
  0497    15F1    SETB	0x71,3
230:              						KEY_LONG_SOUND;
  0498    3001    LDIA	0x1
  0499    00D7    LD	0x57,A
  049A    3025    LDIA	0x25
  049B    00D6    LD	0x56,A
  049C    120A    CLRB	0xA,4
  049D    158A    SETB	0xA,3
  049E    279A    CALL	0x79A
231:              					}				
232:              				}	
233:              			}
234:              									
235:              			 Key_Drive();      //按键驱动
  04A1    120A    CLRB	0xA,4
  04A2    118A    CLRB	0xA,3
  04A3    2281    CALL	0x281
236:              			 Key_Task();       //按键任务
  04A6    120A    CLRB	0xA,4
  04A7    158A    SETB	0xA,3
  04A8    2407    CALL	0x407
237:              			
238:              			if(b_AdBot_OK)
  04AB    1FF1    SNZB	0x71,7
  04AC    2CB2    JP	0x4B2
239:              			{
240:              				Get_Temp_Data();  //获得底部温度
  04AD    120A    CLRB	0xA,4
  04AE    118A    CLRB	0xA,3
  04AF    254D    CALL	0x54D
241:              			}
242:              			
243:              			Get_Lid_Data();   //获取干簧管信号
  04B2    120A    CLRB	0xA,4
  04B3    158A    SETB	0xA,3
  04B4    27A1    CALL	0x7A1
244:              			
245:              			if(b_Auto_test == FALSE)	
  04B7    19F1    SZB	0x71,3
  04B8    2CBE    JP	0x4BE
246:              			{
247:              				Error_Deal();     //报警处理
  04B9    120A    CLRB	0xA,4
  04BA    118A    CLRB	0xA,3
  04BB    23E8    CALL	0x3E8
248:              			}	
249:              			Cook_Task();      //烹饪
  04BE    120A    CLRB	0xA,4
  04BF    158A    SETB	0xA,3
  04C0    2041    CALL	0x41
250:              			Sound_Deal();     //声音
  04C3    120A    CLRB	0xA,4
  04C4    118A    CLRB	0xA,3
  04C5    25DA    CALL	0x5DA
251:              			LED_Task();       //LED显示任务
  04C8    120A    CLRB	0xA,4
  04C9    118A    CLRB	0xA,3
  04CA    2183    CALL	0x183
252:              			LED_Drive();	  //LED驱动		
  04CD    120A    CLRB	0xA,4
  04CE    118A    CLRB	0xA,3
  04CF    24E2    CALL	0x4E2
253:              		}
254:              		//主循环500ms
255:              		if(b_MainLoop_500ms)
  04D2    1C70    SNZB	0x70,0
  04D3    2C6D    JP	0x46D
256:              		{
257:              			b_MainLoop_500ms = 0;	
  04D4    1070    CLRB	0x70,0
258:              			Time_Deal();            //时间处理
  04D5    120A    CLRB	0xA,4
  04D6    158A    SETB	0xA,3
  04D7    2370    CALL	0x370
259:              			
260:              			//压力开关闭合情况下检测
261:              			if(b_VolData_OK == 1)
  04DA    1E72    SNZB	0x72,4
  04DB    2C6D    JP	0x46D
262:              			{
263:              				Get_AC_Rms();       //获取电压有效值	
  04DC    160A    SETB	0xA,4
  04DD    118A    CLRB	0xA,3
  04DE    2002    CALL	0x2
  04E1    2C6D    JP	0x46D
264:              			}
265:              		}
266:              	}
267:              }
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\time.c ----------------------------------------------------------------------
1:                #include "time.h"
2:                
3:                /*****************************************************************
4:                 @fun:      StandbyTimeStart
5:                 @brief:    自动时间处理
6:                 @param:    None                             
7:                 @retval:   None
8:                *****************************************************************/
9:                void StandbyTimeStart(void)
10:               {
11:               	if((SysStatus == FACTORY_TEST_MODE && (FactoryTestData < FACTORY_TEST_START||b_Auto_test == TRUE)))
  0F60    3005    LDIA	0x5
  0F61    1283    CLRB	0x3,5
  0F62    1303    CLRB	0x3,6
  0F63    066A    XORA	0x6A
  0F64    1D03    SNZB	0x3,2
  0F65    2F78    JP	0x778
  0F66    3013    LDIA	0x13
  0F67    0241    SUBA	0x41
  0F68    1C03    SNZB	0x3,0
  0F69    2F6C    JP	0x76C
  0F6A    1DF1    SNZB	0x71,3
  0F6B    2F78    JP	0x778
12:               	{
13:               		//工厂测试下,30S无操作则退出工厂测试
14:               		if(KeyFlag == 0x00)     
  0F6C    082D    LD	A,0x2D
  0F6D    1D03    SNZB	0x3,2
  0F6E    2F76    JP	0x776
15:               		{
16:               			if(++StandbyTimeCnt >= 60)      
  0F6F    303C    LDIA	0x3C
  0F70    0AD9    INCR	0x59
  0F71    0259    SUBA	0x59
  0F72    1C03    SNZB	0x3,0
  0F73    0008    RET
17:               			{
18:               				StandbyTimeCnt = 0;
  0F74    01D9    CLR	0x59
19:               				Cancel();	
  0F75    2D77    JP	0x577
20:               			}
21:               		}
22:               		else
23:               		{
24:               			StandbyTimeCnt = 0;	
  0F76    01D9    CLR	0x59
  0F77    0008    RET
25:               		}						
26:               	}	
27:               	else if(SysStatus == WAITING_MODE)	  
  0F78    0B6A    SZDECA	0x6A
  0F79    0008    RET
28:               	{
29:               		//待机状态两分钟无操作进入省电模式
30:               		if(KeyFlag == 0x00)      
  0F7A    082D    LD	A,0x2D
  0F7B    1D03    SNZB	0x3,2
  0F7C    2F85    JP	0x785
31:               		{
32:               			if((++StandbyTimeCnt) >= 240)  
  0F7D    30F0    LDIA	0xF0
  0F7E    0AD9    INCR	0x59
  0F7F    0259    SUBA	0x59
  0F80    1C03    SNZB	0x3,0
  0F81    0008    RET
33:               			{
34:               				StandbyTimeCnt = 0;
  0F82    01D9    CLR	0x59
35:               				b_Standby = 1;
  0F83    1772    SETB	0x72,6
  0F84    0008    RET
36:               			}
37:               		}
38:               		else
39:               		{
40:               			StandbyTimeCnt = 0;
  0F85    01D9    CLR	0x59
41:               			b_Standby = 0;
  0F86    1372    CLRB	0x72,6
  0F87    0008    RET
42:               		}
43:               	}			
44:               }
45:               
46:               
47:               /*****************************************************************
48:                @fun:      ErrorTimeStart
49:                @brief:    报警时间处理
50:                @param:    None                             
51:                @retval:   None
52:               *****************************************************************/
53:               void ErrorTimeStart(void)
54:               {
55:               	if((ErrorCode != NO_ERROR || b_BotTempOut))
  0EEB    1283    CLRB	0x3,5
  0EEC    0858    LD	A,0x58
  0EED    1D03    SNZB	0x3,2
  0EEE    2EF1    JP	0x6F1
  0EEF    1D71    SNZB	0x71,2
  0EF0    2EFF    JP	0x6FF
56:               	{
57:               		if(++ErrorSoundTime >= 6)	  
  0EF1    3006    LDIA	0x6
  0EF2    1683    SETB	0x3,5
  0EF3    0ABF    INCR	0x3F
  0EF4    023F    SUBA	0x3F
  0EF5    1C03    SNZB	0x3,0
  0EF6    0008    RET
58:               		{
59:               			ErrorSoundTime = 0;
  0EF7    01BF    CLR	0x3F
60:               			ERROR_SOUND;
  0EF8    3003    LDIA	0x3
  0EF9    1283    CLRB	0x3,5
  0EFA    00D7    LD	0x57,A
  0EFB    300C    LDIA	0xC
  0EFC    00D6    LD	0x56,A
  0EFD    3019    LDIA	0x19
  0EFE    2FD5    JP	0x7D5
61:               		}
62:               	}
63:               	else 
64:               	{
65:               		ErrorSoundTime = 0;	
  0EFF    1683    SETB	0x3,5
  0F00    01BF    CLR	0x3F
  0F01    0008    RET
66:               	}	
67:               }
68:               
69:               
70:               /*****************************************************************
71:                @fun:      PresetTimeStart
72:                @brief:    预约时间处理
73:                @param:    None                             
74:                @retval:   None
75:               *****************************************************************/
76:               void PresetTimeStart(void)
77:               {
78:               	if(SysStatus == WORK_MODE) 	 
  108D    3003    LDIA	0x3
  108E    066A    XORA	0x6A
  108F    1903    SZB	0x3,2
79:               	{
80:               		if(WorkStage == WORK_PRESET_STAGE)   //预约时间剩下50+countDownTime，开始工作
  1090    0B3F    SZDECA	0x3F
  1091    0008    RET
81:               		{
82:               			if((++PresetTimeS) >= 120)
  1092    3078    LDIA	0x78
  1093    0AAC    INCR	0x2C
  1094    022C    SUBA	0x2C
  1095    1C03    SNZB	0x3,0
  1096    289F    JP	0x9F
83:               			{
84:               				PresetTimeS = 0;
  1097    01AC    CLR	0x2C
85:               				if(PresetTimeM <= 0)
  1098    0835    LD	A,0x35
  1099    1D03    SNZB	0x3,2
  109A    289E    JP	0x9E
86:               				{
87:               					PresetTimeM = 60;
  109B    303C    LDIA	0x3C
  109C    00B5    LD	0x35,A
88:               					PresetTimeH--;
  109D    03B6    DECR	0x36
89:               				}
90:               				PresetTimeM--;
  109E    03B5    DECR	0x35
91:               			}
92:               			if(PresetTimeH <= ((50+CountDownTime)/60) && PresetTimeM <= ((50+CountDownTime)%60) && PresetTimeS >= 2) //预约结束烹饪开始
  109F    0840    LD	A,0x40
  10A0    00DC    LD	0x5C,A
  10A1    3032    LDIA	0x32
  10A2    27D7    CALL	0x7D7
  10A3    160A    SETB	0xA,4
  10A4    118A    CLRB	0xA,3
  10A5    2353    CALL	0x353
  10A6    160A    SETB	0xA,4
  10A7    118A    CLRB	0xA,3
  10A8    085B    LD	A,0x5B
  10A9    3A80    XORIA	0x80
  10AA    00E2    LD	0x62,A
  10AB    3080    LDIA	0x80
  10AC    0262    SUBA	0x62
  10AD    1D03    SNZB	0x3,2
  10AE    28B1    JP	0xB1
  10AF    0836    LD	A,0x36
  10B0    025A    SUBA	0x5A
  10B1    1C03    SNZB	0x3,0
  10B2    0008    RET
  10B3    1283    CLRB	0x3,5
  10B4    1303    CLRB	0x3,6
  10B5    0840    LD	A,0x40
  10B6    00DC    LD	0x5C,A
  10B7    3032    LDIA	0x32
  10B8    27DF    CALL	0x7DF
  10B9    160A    SETB	0xA,4
  10BA    118A    CLRB	0xA,3
  10BB    2398    CALL	0x398
  10BC    160A    SETB	0xA,4
  10BD    118A    CLRB	0xA,3
  10BE    085B    LD	A,0x5B
  10BF    3A80    XORIA	0x80
  10C0    00E2    LD	0x62,A
  10C1    3080    LDIA	0x80
  10C2    0262    SUBA	0x62
  10C3    1D03    SNZB	0x3,2
  10C4    28C7    JP	0xC7
  10C5    0835    LD	A,0x35
  10C6    025A    SUBA	0x5A
  10C7    1C03    SNZB	0x3,0
  10C8    0008    RET
  10C9    3002    LDIA	0x2
  10CA    1283    CLRB	0x3,5
  10CB    1303    CLRB	0x3,6
  10CC    022C    SUBA	0x2C
  10CD    1C03    SNZB	0x3,0
  10CE    0008    RET
93:               			{
94:               				WorkStage = WORK_HEAT_STAGE;   //进入加热阶段				
  10CF    3002    LDIA	0x2
  10D0    00BF    LD	0x3F,A
95:               				PresetTimeH = 0;
  10D1    01B6    CLR	0x36
96:               				PresetTimeM = 0;					 
  10D2    01B5    CLR	0x35
97:               				START_SOUND;		 
  10D3    3003    LDIA	0x3
  10D4    00D7    LD	0x57,A
  10D5    3019    LDIA	0x19
  10D6    120A    CLRB	0xA,4
  10D7    158A    SETB	0xA,3
  10D8    2F88    JP	0x788
98:               			}
99:               		}
100:              	}	
101:              }
102:              
103:              /*****************************************************************
104:               @fun:      CountDownTimeStart
105:               @brief:    保压时间处理
106:               @param:    None                             
107:               @retval:   None
108:              *****************************************************************/
109:              void CountDownTimeStart(void)
110:              {	
111:              	if(SysStatus == FACTORY_TEST_MODE && FactoryTestData == FACTORY_TEST_COUNT)
  0BBB    3005    LDIA	0x5
  0BBC    1283    CLRB	0x3,5
  0BBD    1303    CLRB	0x3,6
  0BBE    066A    XORA	0x6A
  0BBF    1D03    SNZB	0x3,2
  0BC0    2BDE    JP	0x3DE
  0BC1    3014    LDIA	0x14
  0BC2    0641    XORA	0x41
  0BC3    1D03    SNZB	0x3,2
  0BC4    2BDE    JP	0x3DE
112:              	{
113:              		if((++CountTimeS) < 120) return;
  0BC5    3078    LDIA	0x78
  0BC6    0AAA    INCR	0x2A
  0BC7    022A    SUBA	0x2A
  0BC8    1C03    SNZB	0x3,0
  0BC9    0008    RET
114:              		CountTimeS = 0;
  0BCA    01AA    CLR	0x2A
115:              		
116:              		if(CountDownTime > 0)
  0BCB    0840    LD	A,0x40
  0BCC    1D03    SNZB	0x3,2
117:              		{
118:              			CountDownTime--;		
  0BCD    03C0    DECR	0x40
119:              		}
120:              		
121:              		if(CountDownTime == 0)
  0BCE    0840    LD	A,0x40
  0BCF    1D03    SNZB	0x3,2
  0BD0    0008    RET
122:              		{
123:              			Cancel();      //工厂模式倒计时结束直接进入待机
  0BD1    2577    CALL	0x577
  0BD2    120A    CLRB	0xA,4
  0BD3    158A    SETB	0xA,3
124:              			FINISH_SOUND;
  0BD4    3005    LDIA	0x5
  0BD5    1283    CLRB	0x3,5
  0BD6    00D7    LD	0x57,A
  0BD7    3019    LDIA	0x19
  0BD8    00D6    LD	0x56,A
  0BD9    279A    CALL	0x79A
125:              			ChooseFunSave = 0;
  0BDA    01FB    CLR	0x7B
126:              			SysStatus = KEEP_WARM_MODE;
  0BDB    3004    LDIA	0x4
  0BDC    00EA    LD	0x6A,A
  0BDD    0008    RET
127:              		}
128:              		return;
129:              	}
130:              	
131:              	if(SysStatus != WORK_MODE)
  0BDE    3003    LDIA	0x3
  0BDF    066A    XORA	0x6A
  0BE0    1903    SZB	0x3,2
  0BE1    2BE4    JP	0x3E4
132:              	{
133:              		CountTimeS = 0;
  0BE2    01AA    CLR	0x2A
  0BE3    0008    RET
134:              		return;
135:              	}
136:              
137:              	if(SysStatus == WORK_MODE && WorkStage == WORK_COUNTDOWN_STAGE)
  0BE4    3003    LDIA	0x3
  0BE5    066A    XORA	0x6A
  0BE6    1D03    SNZB	0x3,2
  0BE7    0008    RET
  0BE8    3003    LDIA	0x3
  0BE9    063F    XORA	0x3F
  0BEA    1D03    SNZB	0x3,2
  0BEB    0008    RET
138:              	{
139:              		if(WorkStage == WORK_COUNTDOWN_STAGE)
  0BEC    3003    LDIA	0x3
  0BED    063F    XORA	0x3F
  0BEE    1D03    SNZB	0x3,2
  0BEF    2BF9    JP	0x3F9
140:              		{
141:              			CountTimeS++;
  0BF0    0AAA    INCR	0x2A
142:              			if(CountTimeS < 120) return;
  0BF1    3078    LDIA	0x78
  0BF2    022A    SUBA	0x2A
  0BF3    1C03    SNZB	0x3,0
  0BF4    0008    RET
143:              				CountTimeS = 0;
  0BF5    01AA    CLR	0x2A
144:              
145:              			if(CountDownTime > 0)
  0BF6    0840    LD	A,0x40
  0BF7    1D03    SNZB	0x3,2
146:              			{
147:              				CountDownTime--;
  0BF8    03C0    DECR	0x40
148:              			}		
149:              		}
150:              
151:              		if(CountDownTime == 0)
  0BF9    0840    LD	A,0x40
  0BFA    1D03    SNZB	0x3,2
  0BFB    0008    RET
152:              		{
153:              			Cancel();				
  0BFC    2577    CALL	0x577
  0BFD    120A    CLRB	0xA,4
  0BFE    158A    SETB	0xA,3
154:              			SysStatus = KEEP_WARM_MODE;
  0BFF    3004    LDIA	0x4
  0C00    1283    CLRB	0x3,5
  0C01    00EA    LD	0x6A,A
155:              			b_AutoKeepWarm = 1;
  0C02    1670    SETB	0x70,4
156:              			FINISH_SOUND;			
  0C03    3005    LDIA	0x5
  0C04    00D7    LD	0x57,A
  0C05    3019    LDIA	0x19
  0C06    2F88    JP	0x788
157:              		}					
158:              	}	
159:              }
160:              
161:              
162:              /*****************************************************************
163:               @fun:      KeepWarmTimeStart
164:               @brief:    保温时间处理, 默认米饭和蛋糕5小时保温，其他24小时，直接保温24小时
165:               @param:    None                             
166:               @retval:   None
167:              *****************************************************************/	
168:              void KeepWarmTimeStart(void)		
169:              {
170:              	if(SysStatus != KEEP_WARM_MODE)
  05A4    3004    LDIA	0x4
  05A5    066A    XORA	0x6A
  05A6    1903    SZB	0x3,2
  05A7    2DAE    JP	0x5AE
171:              	{
172:              		KeepWarmS = 0;
  05A8    1683    SETB	0x3,5
  05A9    01C4    CLR	0x44
173:              		KeepWarmM = 0;
  05AA    01C5    CLR	0x45
174:              		KeepWarmH = 0;
  05AB    1283    CLRB	0x3,5
  05AC    01AB    CLR	0x2B
  05AD    0008    RET
175:              		return;
176:              	}
177:              	
178:              	if((++KeepWarmS) < 120)return;
  05AE    3078    LDIA	0x78
  05AF    1683    SETB	0x3,5
  05B0    0AC4    INCR	0x44
  05B1    0244    SUBA	0x44
  05B2    1C03    SNZB	0x3,0
  05B3    0008    RET
179:              	KeepWarmS = 0;
  05B4    01C4    CLR	0x44
180:              	if((++KeepWarmM) < 60) return;
  05B5    303C    LDIA	0x3C
  05B6    0AC5    INCR	0x45
  05B7    0245    SUBA	0x45
  05B8    1C03    SNZB	0x3,0
  05B9    0008    RET
181:              	KeepWarmM = 0;
  05BA    01C5    CLR	0x45
182:              	
183:              	if(ChooseFunSave == FUN_RICE || ChooseFunSave == FUN_MIXRICE || ChooseFunSave == FUN_CAKE) //米饭类或蛋糕时间为5小时保温
  05BB    037B    DECA	0x7B
  05BC    1903    SZB	0x3,2
  05BD    2DC6    JP	0x5C6
  05BE    3002    LDIA	0x2
  05BF    067B    XORA	0x7B
  05C0    1903    SZB	0x3,2
  05C1    2DC6    JP	0x5C6
  05C2    300C    LDIA	0xC
  05C3    067B    XORA	0x7B
  05C4    1D03    SNZB	0x3,2
  05C5    2DC8    JP	0x5C8
184:              	{
185:              		if((++KeepWarmH) < 5) 
  05C6    3005    LDIA	0x5
  05C7    2DC9    JP	0x5C9
186:              			return;
187:              	}
188:              	else  //其他为24小时保温
189:              	{
190:              		if((++KeepWarmH) < 24) 
  05C8    3018    LDIA	0x18
  05C9    1283    CLRB	0x3,5
  05CA    0AAB    INCR	0x2B
  05CB    022B    SUBA	0x2B
  05CC    1C03    SNZB	0x3,0
  05CD    0008    RET
191:              			return;
192:              	}
193:              	ChooseFunSave = 0;
  05CE    01FB    CLR	0x7B
194:              	b_AutoKeepWarm = 0;
  05CF    1270    CLRB	0x70,4
195:              	Cancel();
  05D0    120A    CLRB	0xA,4
  05D1    158A    SETB	0xA,3
  05D2    2577    CALL	0x577
196:              	FINISH_SOUND; 	
  05D3    3005    LDIA	0x5
  05D4    1283    CLRB	0x3,5
  05D5    00D7    LD	0x57,A
  05D6    3019    LDIA	0x19
  05D7    120A    CLRB	0xA,4
  05D8    158A    SETB	0xA,3
  05D9    2F88    JP	0x788
197:              }
198:              
199:              
200:              /*****************************************************************
201:               @fun:      WorkTimeStart
202:               @brief:    工作时间处理
203:               @param:    None                             
204:               @retval:   None
205:              *****************************************************************/
206:              void WorkTimeStart(void)
207:              {	
208:              	if(SysStatus != WORK_MODE || (WorkStage != WORK_HEAT_STAGE && WorkStage != WORK_COUNTDOWN_STAGE))
  0FDB    3003    LDIA	0x3
  0FDC    1283    CLRB	0x3,5
  0FDD    066A    XORA	0x6A
  0FDE    1D03    SNZB	0x3,2
  0FDF    2FE8    JP	0x7E8
  0FE0    3002    LDIA	0x2
  0FE1    063F    XORA	0x3F
  0FE2    1903    SZB	0x3,2
  0FE3    2FEC    JP	0x7EC
  0FE4    3003    LDIA	0x3
  0FE5    063F    XORA	0x3F
  0FE6    1903    SZB	0x3,2
  0FE7    2FEC    JP	0x7EC
209:              	{
210:              		WorkTimeS = 0;
  0FE8    01B4    CLR	0x34
211:              		WorkTimeM = 0;
  0FE9    01BD    CLR	0x3D
212:              		WorkTimeH = 0;
  0FEA    01AE    CLR	0x2E
  0FEB    0008    RET
213:              		return;
214:              	}
215:              	
216:              	if(++WorkTimeS < 120)
  0FEC    3078    LDIA	0x78
  0FED    0AB4    INCR	0x34
  0FEE    0234    SUBA	0x34
  0FEF    1C03    SNZB	0x3,0
  0FF0    0008    RET
217:              		return;
218:              	WorkTimeS = 0;
  0FF1    01B4    CLR	0x34
219:              	
220:              	if(++WorkTimeM >= 60)
  0FF2    303C    LDIA	0x3C
  0FF3    0ABD    INCR	0x3D
  0FF4    023D    SUBA	0x3D
  0FF5    1C03    SNZB	0x3,0
  0FF6    0008    RET
221:              	{
222:              		WorkTimeM = 0;
  0FF7    01BD    CLR	0x3D
223:              		if(++WorkTimeH >= 24)
  0FF8    3018    LDIA	0x18
  0FF9    0AAE    INCR	0x2E
  0FFA    022E    SUBA	0x2E
  0FFB    1C03    SNZB	0x3,0
  0FFC    0008    RET
224:              		{
225:              			WorkTimeH = 24;
  0FFD    3018    LDIA	0x18
  0FFE    00AE    LD	0x2E,A
  0FFF    0008    RET
226:              		}
227:              	}	
228:              }
229:              
230:              
231:              /*****************************************************************
232:               @fun:      ShortTime
233:               @brief:    短计时器
234:               @param:    None                             
235:               @retval:   None
236:              *****************************************************************/
237:              void ShortTime(void)	
238:              {
239:              	if (!b_ShortOn) return;
  0F50    1E71    SNZB	0x71,4
  0F51    0008    RET
240:              	if (++ShortCntL >= 120)
  0F52    3078    LDIA	0x78
  0F53    0AC4    INCR	0x44
  0F54    0244    SUBA	0x44
  0F55    1C03    SNZB	0x3,0
  0F56    0008    RET
241:              	{
242:              		ShortCntL = 0;
  0F57    01C4    CLR	0x44
243:              		if (++ShortCntM >= 240) ShortCntM = 240;
  0F58    30F0    LDIA	0xF0
  0F59    0AC3    INCR	0x43
  0F5A    0243    SUBA	0x43
  0F5B    1C03    SNZB	0x3,0
  0F5C    0008    RET
  0F5D    30F0    LDIA	0xF0
  0F5E    00C3    LD	0x43,A
  0F5F    0008    RET
244:              	}
245:              }
246:              
247:              void AutoStartFun()
248:              {
249:              	if(SysStatus == CHOOSE_FUN_MODE)
  0B8C    3002    LDIA	0x2
  0B8D    066A    XORA	0x6A
  0B8E    1D03    SNZB	0x3,2
  0B8F    0008    RET
250:              	{
251:              		if(KeyFlag == 0x00)
  0B90    082D    LD	A,0x2D
  0B91    1D03    SNZB	0x3,2
  0B92    2BB9    JP	0x3B9
252:              		{		
253:              			if(++StandbyTimeCnt >= 14)
  0B93    300E    LDIA	0xE
  0B94    0AD9    INCR	0x59
  0B95    0259    SUBA	0x59
  0B96    1C03    SNZB	0x3,0
  0B97    0008    RET
254:              			{
255:              				StandbyTimeCnt = 0;
  0B98    01D9    CLR	0x59
256:              				SysStatus = WORK_MODE;
  0B99    3003    LDIA	0x3
  0B9A    00EA    LD	0x6A,A
257:              				if(PresetTimeH == 0 && PresetTimeM == 0)
  0B9B    0836    LD	A,0x36
  0B9C    1D03    SNZB	0x3,2
  0B9D    2BA3    JP	0x3A3
  0B9E    0835    LD	A,0x35
  0B9F    1D03    SNZB	0x3,2
  0BA0    2BA3    JP	0x3A3
258:              				{
259:              					WorkStage = WORK_HEAT_STAGE; //加热状态
  0BA1    3002    LDIA	0x2
  0BA2    2BA4    JP	0x3A4
260:              				}
261:              				else
262:              				{
263:              					WorkStage = WORK_PRESET_STAGE; //预约状态
  0BA3    3001    LDIA	0x1
  0BA4    00BF    LD	0x3F,A
264:              				}
265:              				
266:              				if(ChooseFun == FUN_OPENEHEAT)	//直接进入倒计时
  0BA5    300E    LDIA	0xE
  0BA6    063C    XORA	0x3C
  0BA7    1D03    SNZB	0x3,2
  0BA8    2BAB    JP	0x3AB
267:              				{
268:              					WorkStage = WORK_COUNTDOWN_STAGE;
  0BA9    3003    LDIA	0x3
  0BAA    00BF    LD	0x3F,A
269:              				}
270:              				ChooseFunSave = ChooseFun;
  0BAB    083C    LD	A,0x3C
  0BAC    00FB    LD	0x7B,A
271:              				CountDownTimeSave = CountDownTime; 
  0BAD    0840    LD	A,0x40
  0BAE    00B3    LD	0x33,A
272:              				WorkStep = 0;
  0BAF    01C2    CLR	0x42
273:              				b_JudgeLidOk = 0;
  0BB0    1170    CLRB	0x70,2
274:              				JudgeLidCnt = 0;
  0BB1    1683    SETB	0x3,5
  0BB2    01C8    CLR	0x48
275:              				JudgeLidMin = 0;
  0BB3    1283    CLRB	0x3,5
  0BB4    01AF    CLR	0x2F
276:              
277:              				START_SOUND;			
  0BB5    3003    LDIA	0x3
  0BB6    00D7    LD	0x57,A
  0BB7    3019    LDIA	0x19
  0BB8    2F88    JP	0x788
278:              			}			
279:              		}
280:              		else
281:              		{
282:              			StandbyTimeCnt=0;
  0BB9    01D9    CLR	0x59
  0BBA    0008    RET
283:              		}
284:              	}
285:              }
286:              
287:              /*****************************************************************
288:               @fun:      Time_Deal
289:               @brief:    时间处理函数, 主函数500ms调用
290:               @param:    None                             
291:               @retval:   None
292:              *****************************************************************/
293:              void Time_Deal(void)
294:              {
295:              	StandbyTimeStart();     //待机时间处理
  0B70    2760    CALL	0x760
  0B71    120A    CLRB	0xA,4
  0B72    158A    SETB	0xA,3
296:              	ErrorTimeStart();       //报警时间处理
  0B73    26EB    CALL	0x6EB
  0B74    120A    CLRB	0xA,4
  0B75    158A    SETB	0xA,3
297:              	Relay_Duty_Control();   //继电器间歇控制
  0B76    2702    CALL	0x702
  0B77    120A    CLRB	0xA,4
  0B78    158A    SETB	0xA,3
298:              	AutoStartFun();			//功能自动开始
  0B79    238C    CALL	0x38C
  0B7A    120A    CLRB	0xA,4
  0B7B    158A    SETB	0xA,3
299:              	
300:              	if(ErrorCode != NO_ERROR)
  0B7C    0858    LD	A,0x58
  0B7D    1D03    SNZB	0x3,2
  0B7E    0008    RET
301:              	{
302:              		return;		
303:              	}
304:              	//有报警时不计时
305:              	ShortTime();            //短计时1
  0B7F    2750    CALL	0x750
306:              	PresetTimeStart();      //预约时间
  0B80    160A    SETB	0xA,4
  0B81    118A    CLRB	0xA,3
  0B82    208D    CALL	0x8D
307:              	CountDownTimeStart();   //保压时间
  0B85    23BB    CALL	0x3BB
308:              	KeepWarmTimeStart();    //保温时间
  0B86    120A    CLRB	0xA,4
  0B87    118A    CLRB	0xA,3
  0B88    25A4    CALL	0x5A4
309:              	WorkTimeStart();        //工作时间		
  0B8B    2FDB    JP	0x7DB
310:              }
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\sound.c ----------------------------------------------------------------------
1:                #include "Sound.h"
2:                
3:                /***********************************************************
4:                声音处理函数 主函数8ms调用
5:                ***********************************************************/
6:                void Sound_Deal(void)
7:                {
8:                	if(BuzCnt > 0)
  05DA    0857    LD	A,0x57
  05DB    1903    SZB	0x3,2
  05DC    2DF5    JP	0x5F5
9:                	{
10:               		if(BuzUpTime > 0)
  05DD    0856    LD	A,0x56
  05DE    1903    SZB	0x3,2
  05DF    2DE6    JP	0x5E6
11:               		{			
12:               			BUZ_ON();
  05E0    1683    SETB	0x3,5
  05E1    1107    CLRB	0x7,2
  05E2    1283    CLRB	0x3,5
  05E3    141D    SETB	0x1D,0
13:               			BuzUpTime--;	
  05E4    03D6    DECR	0x56
14:               		}
  05E5    0008    RET
15:               		else
16:               		{
17:               			BUZ_OFF();
  05E6    1683    SETB	0x3,5
  05E7    1507    SETB	0x7,2
  05E8    1283    CLRB	0x3,5
  05E9    101D    CLRB	0x1D,0
18:               			if(BuzDownTime > 0)
  05EA    0855    LD	A,0x55
  05EB    1903    SZB	0x3,2
  05EC    2DEF    JP	0x5EF
19:               			{	
20:               				BuzDownTime--;
  05ED    03D5    DECR	0x55
21:               			}
  05EE    0008    RET
22:               			else
23:               			{
24:               				BuzCnt--;
  05EF    03D7    DECR	0x57
25:               				BuzDownTime = BuzDownTemp;
  05F0    0853    LD	A,0x53
  05F1    00D5    LD	0x55,A
26:               				BuzUpTime = BuzUpTemp;
  05F2    0854    LD	A,0x54
  05F3    00D6    LD	0x56,A
  05F4    0008    RET
27:               			}
28:               		}		
29:               	}
30:               	else
31:               	{
32:               		BuzUpTime = 0;
  05F5    01D6    CLR	0x56
33:               		BuzDownTime = 0;
  05F6    01D5    CLR	0x55
34:               		BuzUpTemp = 0;
  05F7    01D4    CLR	0x54
35:               		BuzDownTemp = 0;
  05F8    01D3    CLR	0x53
36:               		BuzCnt = 0;
  05F9    01D7    CLR	0x57
37:               		BUZ_OFF();	
  05FA    1683    SETB	0x3,5
  05FB    1507    SETB	0x7,2
  05FC    1283    CLRB	0x3,5
  05FD    101D    CLRB	0x1D,0
  05FE    0008    RET
38:               	}
39:               }
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\display.c ----------------------------------------------------------------------
1:                #include "display.h"
2:                
3:                //变量定义
4:                const uint8 SEG_MATH_TAB[] = {
5:                	0x3F	,//0
6:                	0x06	,//1
7:                	0x5B	,//2
8:                	0x4F	,//3
9:                	0x66	,//4
10:               	0x6D	,//5
11:               	0x7D	,//6
12:               	0x07	,//7
13:               	0x7F	,//8
14:               	0x6F	,//9
15:               	0x77	,//A
16:               	0x7C	,//b
17:               	0x39	,//C
18:               	0x5E	,//d
19:               	0x79	,//E
20:               	0x71	,//F
21:               };
22:               
23:               //加热跑圈显示数组
24:               const uint8 HOT_RUN_TAB[13][4]={		
25:               								{SEGM_A,SEGM_A,SEGM_A,0},	   
26:               							   	{SEGM_A,SEGM_A,SEGM_A,0},
27:               							  	{0,SEGM_A,SEGM_A,SEGM_A},
28:               							  	{0,0,SEGM_A,SEGM_A+SEGM_B},
29:               							  	{0,0,0,SEGM_A+SEGM_B+SEGM_C},
30:               							  	{0,0,0,SEGM_B+SEGM_C+SEGM_D},
31:               							  	{0,0,SEGM_D,SEGM_C+SEGM_D},
32:               							  	{0,SEGM_D,SEGM_D,SEGM_D},
33:               							  	{SEGM_D,SEGM_D,SEGM_D,0},
34:               							  	{SEGM_D+SEGM_E,SEGM_D,0,0},
35:               							  	{SEGM_D+SEGM_E+SEGM_F,0,0,0},
36:               							  	{SEGM_A+SEGM_E+SEGM_F,0,0,0},
37:               							  	{SEGM_A+SEGM_F,SEGM_A,0,0},};
38:               
39:               
40:               /*****************************************************************
41:                @fun:      DIG_Show_Time
42:                @brief:    显示时间HH:MM        小时高位0不显示,分钟高位0显示
43:                @param:    uint8 hour      小时 
44:                           uint8 min       分钟
45:                           uint8 bPoint    1 显示冒号 0 不显示                           
46:                @retval:   None
47:               *****************************************************************/
48:               void DIG_Show_Time(uint8 hour, uint8 min, uint8 point)
  174F    00E1    LD	0x61,A
49:               {
50:               	if(hour >= 10)
  1750    300A    LDIA	0xA
  1751    0261    SUBA	0x61
  1752    1C03    SNZB	0x3,0
  1753    2F61    JP	0x761
51:               	{
52:               		DIG_DATA_4 |= SEG_MATH_TAB[hour/10];	
  1754    300A    LDIA	0xA
  1755    00DA    LD	0x5A,A
  1756    0861    LD	A,0x61
  1757    271B    CALL	0x71B
  1758    160A    SETB	0xA,4
  1759    118A    CLRB	0xA,3
  175A    2792    CALL	0x792
  175B    160A    SETB	0xA,4
  175C    158A    SETB	0xA,3
  175D    2000    CALL	0x0
  1760    04A0    ORR	0x20
53:               	}
54:               	
55:               	//预约倒计时保留小时0
56:               	if(WorkStage == WORK_PRESET_STAGE)  
  1761    0B3F    SZDECA	0x3F
  1762    2F64    JP	0x764
  1763    2F67    JP	0x767
57:               	{
58:               		DIG_DATA_3 |= SEG_MATH_TAB[hour%10];			
59:               		if(point) 
60:               		{
61:               			SEGM_TWO_POINT;		
  1777    17A2    SETB	0x22,7
  1778    17A1    SETB	0x21,7
62:               		}
63:               	}
64:               	else		//hour为0时  不显示
65:               	{
66:               		if(hour > 0)
  1764    0861    LD	A,0x61
  1765    1903    SZB	0x3,2
  1766    2F79    JP	0x779
67:               		{
68:               			DIG_DATA_3 |= SEG_MATH_TAB[hour%10];			
  1767    300A    LDIA	0xA
  1768    00DA    LD	0x5A,A
  1769    0861    LD	A,0x61
  176A    26FF    CALL	0x6FF
  176B    160A    SETB	0xA,4
  176C    118A    CLRB	0xA,3
  176D    2792    CALL	0x792
  176E    160A    SETB	0xA,4
  176F    158A    SETB	0xA,3
  1770    2000    CALL	0x0
  1773    04A1    ORR	0x21
69:               			if(point) 
  1774    0860    LD	A,0x60
  1775    1903    SZB	0x3,2
  1776    2F79    JP	0x779
70:               			{
71:               				SEGM_TWO_POINT;		
72:               			} 					
73:               		}
74:               	}
75:               					 
76:               	DIG_DATA_2 |= SEG_MATH_TAB[min/10];	 
  1779    300A    LDIA	0xA
  177A    00DA    LD	0x5A,A
  177B    085F    LD	A,0x5F
  177C    271B    CALL	0x71B
  177D    160A    SETB	0xA,4
  177E    118A    CLRB	0xA,3
  177F    2792    CALL	0x792
  1780    160A    SETB	0xA,4
  1781    158A    SETB	0xA,3
  1782    2000    CALL	0x0
  1785    04A2    ORR	0x22
77:               	DIG_DATA_1 |= SEG_MATH_TAB[min%10]; 
  1786    300A    LDIA	0xA
  1787    00DA    LD	0x5A,A
  1788    085F    LD	A,0x5F
  1789    26FF    CALL	0x6FF
  178A    160A    SETB	0xA,4
  178B    118A    CLRB	0xA,3
  178C    2792    CALL	0x792
  178D    160A    SETB	0xA,4
  178E    158A    SETB	0xA,3
  178F    2000    CALL	0x0
  1790    04A3    ORR	0x23
  1791    0008    RET
78:               }
79:               
80:               /*****************************************************************
81:                @fun:      DIG_Show_Data
82:                @brief:    显示4位数码管,从左往右
83:                @param:    uint8 digdata1  左1
84:                           uint8 digdata2  左2
85:                           uint8 digdata3  左3
86:                           uint8 digdata4  左4              
87:                @retval:   None
88:               *****************************************************************/
89:               void DIG_Show_Data(uint8 digdata1, uint8 digdata2, uint8 digdata3, uint8 digdata4)
  1315    00E2    LD	0x62,A
90:               {
91:               	if(digdata1 != 0)
  1316    0862    LD	A,0x62
  1317    1903    SZB	0x3,2
  1318    2B1B    JP	0x31B
92:               	{
93:               		DIG_DATA_4 |= digdata1;
  1319    0862    LD	A,0x62
  131A    04A0    ORR	0x20
94:               	}
95:               	
96:               	if(digdata2 != 0)
  131B    085F    LD	A,0x5F
  131C    1903    SZB	0x3,2
  131D    2B20    JP	0x320
97:               	{	 
98:               		DIG_DATA_3 |= digdata2;	
  131E    085F    LD	A,0x5F
  131F    04A1    ORR	0x21
99:               	}
100:              	
101:              	if(digdata3 != 0)
  1320    0860    LD	A,0x60
  1321    1903    SZB	0x3,2
  1322    2B25    JP	0x325
102:              	{	 
103:              		DIG_DATA_2 |= digdata3;	
  1323    0860    LD	A,0x60
  1324    04A2    ORR	0x22
104:              	}
105:              	
106:              	if(digdata4 != 0)
  1325    0861    LD	A,0x61
  1326    1D03    SNZB	0x3,2
107:              	{	 
108:              		DIG_DATA_1 |= digdata4; 
  1327    04A3    ORR	0x23
  1328    0008    RET
109:              	}
110:              }								
111:              
112:              /*****************************************************************
113:               @fun:      LED_Off
114:               @brief:    关闭所有LED
115:               @param:    None                             
116:               @retval:   None
117:              *****************************************************************/
118:              void LED_Off(void)
119:              {
120:              	uint8 i;
121:              	
122:              	for(i = 0; i < COM_NUMBER; i++)
  0260    01DA    CLR	0x5A
123:              	{
124:              		DispData[i] = 0x00;	   //关闭所有LED	
  0261    085A    LD	A,0x5A
  0262    3E20    ADDIA	0x20
  0263    0084    LD	0x4,A
  0264    3007    LDIA	0x7
  0265    1383    CLRB	0x3,7
  0266    0180    CLR	0x0
  0267    0ADA    INCR	0x5A
  0268    025A    SUBA	0x5A
  0269    1803    SZB	0x3,0
  026A    0008    RET
  026B    2A61    JP	0x261
125:              	}		
126:              }
127:              
128:              
129:              /*****************************************************************
130:               @fun:      Power_On_Show
131:               @brief:    上电显示
132:               @param:    None                             
133:               @retval:   None
134:              *****************************************************************/
135:              void Power_On_Show(void)       
136:              {
137:              	uint8 i;
138:              		
139:              	for(i = 0; i < COM_NUMBER; i++)
  026C    01DA    CLR	0x5A
140:              	{
141:              		DispData[i] = 0xFF;	   //打开所有LED	
  026D    085A    LD	A,0x5A
  026E    3E20    ADDIA	0x20
  026F    0084    LD	0x4,A
  0270    30FF    LDIA	0xFF
  0271    0080    LD	0x0,A
  0272    3007    LDIA	0x7
  0273    0ADA    INCR	0x5A
  0274    025A    SUBA	0x5A
  0275    1803    SZB	0x3,0
  0276    0008    RET
  0277    2A6D    JP	0x26D
142:              	}
143:              }
144:              
145:              /*****************************************************************
146:               @fun:      Waiting_Mode_Show
147:               @brief:    待机显示
148:               @param:    None                             
149:               @retval:   None
150:              *****************************************************************/
151:              void Waiting_Mode_Show(void)   	
152:              {	
153:              		//数码管--:--
154:              		DIG_DATA_4 |= SEGM_G;
155:              		DIG_DATA_3 |= SEGM_G;
156:              		DIG_DATA_2 |= SEGM_G;
157:              		DIG_DATA_1 |= SEGM_G;	
158:              		SEGM_TWO_POINT;			
  0278    227A    CALL	0x27A
  0279    0008    RET
159:              }
160:              
161:              
162:              /*****************************************************************
163:               @fun:      Fun_Choose_Show
164:               @brief:    选择功能显示
165:               @param:    None                             
166:               @retval:   None
167:              *****************************************************************/
168:              void Fun_Choose_Show(void)
169:              { 
170:              	//13个功能灯闪烁       
171:              	if(b_LedCol) 
  10D9    1AF0    SZB	0x70,5
  10DA    28F8    JP	0xF8
  10DB    2924    JP	0x124
172:              	{
173:              		switch(ChooseFun)
174:              		{
175:              			case FUN_RICE		: 		ON_LED8;		break;
  10DC    1424    SETB	0x24,0
  10DD    2924    JP	0x124
176:              			case FUN_MIXRICE	:		ON_LED16;		break;
  10DE    1425    SETB	0x25,0
  10DF    2924    JP	0x124
177:              			case FUN_PORRIDGE	:		ON_LED1;		break;
  10E0    1724    SETB	0x24,6
  10E1    2924    JP	0x124
178:              			case FUN_CONGEE		:		ON_LED9;		break;
  10E2    1725    SETB	0x25,6
  10E3    2924    JP	0x124
179:              
180:              			case FUN_SOUP		:		ON_LED10;  		break;
  10E4    15A5    SETB	0x25,3
  10E5    2924    JP	0x124
181:              			case FUN_COOKMEAT	:		ON_LED11;		break;
  10E6    1525    SETB	0x25,2
  10E7    2924    JP	0x124
182:              			case FUN_RIB		:		ON_LED12;		break;
  10E8    1625    SETB	0x25,4
  10E9    2924    JP	0x124
183:              			case FUN_CHICKEN	:		ON_LED13;		break;
  10EA    16A5    SETB	0x25,5
  10EB    2924    JP	0x124
184:              
185:              			case FUN_EIGHTCONGEE:		ON_LED2;		break;
  10EC    15A4    SETB	0x24,3
  10ED    2924    JP	0x124
186:              			case FUN_BEEF		:		ON_LED3;		break;
  10EE    1524    SETB	0x24,2
  10EF    2924    JP	0x124
187:              			case FUN_BEAN		:		ON_LED4;		break;
  10F0    1624    SETB	0x24,4
  10F1    2924    JP	0x124
188:              			case FUN_CAKE		:		ON_LED5;		break;
  10F2    16A4    SETB	0x24,5
  10F3    2924    JP	0x124
189:              
190:              			case FUN_FASTHEAT	:		ON_LED7;		break;
  10F4    17A4    SETB	0x24,7
  10F5    2924    JP	0x124
191:              			case FUN_OPENEHEAT	:		ON_LED14;		break;
  10F6    14A5    SETB	0x25,1
  10F7    2924    JP	0x124
  10F8    083C    LD	A,0x3C
  10F9    3A01    XORIA	0x1
  10FA    1903    SZB	0x3,2
  10FB    28DC    JP	0xDC
  10FC    3A03    XORIA	0x3
  10FD    1903    SZB	0x3,2
  10FE    28DE    JP	0xDE
  10FF    3A01    XORIA	0x1
  1100    1903    SZB	0x3,2
  1101    28E0    JP	0xE0
  1102    3A07    XORIA	0x7
  1103    1903    SZB	0x3,2
  1104    28E2    JP	0xE2
  1105    3A01    XORIA	0x1
  1106    1903    SZB	0x3,2
  1107    28E4    JP	0xE4
  1108    3A03    XORIA	0x3
  1109    1903    SZB	0x3,2
  110A    28E6    JP	0xE6
  110B    3A01    XORIA	0x1
  110C    1903    SZB	0x3,2
  110D    28E8    JP	0xE8
  110E    3A0F    XORIA	0xF
  110F    1903    SZB	0x3,2
  1110    28EA    JP	0xEA
  1111    3A01    XORIA	0x1
  1112    1903    SZB	0x3,2
  1113    28EC    JP	0xEC
  1114    3A03    XORIA	0x3
  1115    1903    SZB	0x3,2
  1116    28EE    JP	0xEE
  1117    3A01    XORIA	0x1
  1118    1903    SZB	0x3,2
  1119    28F0    JP	0xF0
  111A    3A07    XORIA	0x7
  111B    1903    SZB	0x3,2
  111C    28F2    JP	0xF2
  111D    3A01    XORIA	0x1
  111E    1903    SZB	0x3,2
  111F    28F4    JP	0xF4
  1120    3A03    XORIA	0x3
  1121    1903    SZB	0x3,2
  1122    28F6    JP	0xF6
  1123    2924    JP	0x124
192:              
193:              		}
194:              	}
195:              		
196:              	//定时模式显示估算烹饪时间
197:              	if(PresetState == TIMER_STATE)
  1124    0B39    SZDECA	0x39
  1125    2981    JP	0x181
198:              	{
199:              		if(ChooseFun == FUN_OPENEHEAT || ChooseFun == FUN_FASTHEAT || ChooseFun == FUN_CAKE)	//开盖收汁和蛋糕功能，显示定时时间不增加15分钟
  1126    300E    LDIA	0xE
  1127    063C    XORA	0x3C
  1128    1903    SZB	0x3,2
  1129    2932    JP	0x132
  112A    300D    LDIA	0xD
  112B    063C    XORA	0x3C
  112C    1903    SZB	0x3,2
  112D    2932    JP	0x132
  112E    300C    LDIA	0xC
  112F    063C    XORA	0x3C
  1130    1D03    SNZB	0x3,2
  1131    2940    JP	0x140
200:              		{
201:              			HourBuf = (CountDownTime)/60;
  1132    303C    LDIA	0x3C
  1133    00DA    LD	0x5A,A
  1134    0840    LD	A,0x40
  1135    271B    CALL	0x71B
  1136    160A    SETB	0xA,4
  1137    118A    CLRB	0xA,3
  1138    00B8    LD	0x38,A
202:              			MinBuf = (CountDownTime)%60;			
  1139    303C    LDIA	0x3C
  113A    00DA    LD	0x5A,A
  113B    0840    LD	A,0x40
  113C    26FF    CALL	0x6FF
  113D    160A    SETB	0xA,4
  113E    118A    CLRB	0xA,3
  113F    2955    JP	0x155
203:              		}
204:              		else
205:              		{
206:              			HourBuf = (CountDownTime+15)/60;
  1140    0840    LD	A,0x40
  1141    00DC    LD	0x5C,A
  1142    300F    LDIA	0xF
  1143    27D7    CALL	0x7D7
  1144    160A    SETB	0xA,4
  1145    118A    CLRB	0xA,3
  1146    2353    CALL	0x353
  1147    160A    SETB	0xA,4
  1148    118A    CLRB	0xA,3
  1149    085A    LD	A,0x5A
  114A    00B8    LD	0x38,A
207:              			MinBuf = (CountDownTime+15)%60;
  114B    0840    LD	A,0x40
  114C    00DC    LD	0x5C,A
  114D    300F    LDIA	0xF
  114E    27DF    CALL	0x7DF
  114F    160A    SETB	0xA,4
  1150    118A    CLRB	0xA,3
  1151    2398    CALL	0x398
  1152    160A    SETB	0xA,4
  1153    118A    CLRB	0xA,3
  1154    085A    LD	A,0x5A
  1155    00B7    LD	0x37,A
208:              		}
209:              		
210:              		DIG_DATA_4 |= 0;
211:              		DIG_DATA_3 |= SEG_MATH_TAB[HourBuf%10];
  1156    300A    LDIA	0xA
  1157    00DA    LD	0x5A,A
  1158    0838    LD	A,0x38
  1159    26FF    CALL	0x6FF
  115A    160A    SETB	0xA,4
  115B    118A    CLRB	0xA,3
  115C    2792    CALL	0x792
  115D    160A    SETB	0xA,4
  115E    158A    SETB	0xA,3
  115F    2000    CALL	0x0
  1162    04A1    ORR	0x21
212:              		DIG_DATA_2 |= SEG_MATH_TAB[MinBuf/10];
  1163    300A    LDIA	0xA
  1164    00DA    LD	0x5A,A
  1165    0837    LD	A,0x37
  1166    271B    CALL	0x71B
  1167    160A    SETB	0xA,4
  1168    118A    CLRB	0xA,3
  1169    2792    CALL	0x792
  116A    160A    SETB	0xA,4
  116B    158A    SETB	0xA,3
  116C    2000    CALL	0x0
  116F    04A2    ORR	0x22
213:              		DIG_DATA_1 |= SEG_MATH_TAB[MinBuf%10];
  1170    300A    LDIA	0xA
  1171    00DA    LD	0x5A,A
  1172    0837    LD	A,0x37
  1173    26FF    CALL	0x6FF
  1174    160A    SETB	0xA,4
  1175    118A    CLRB	0xA,3
  1176    2792    CALL	0x792
  1177    160A    SETB	0xA,4
  1178    158A    SETB	0xA,3
  1179    2000    CALL	0x0
  117A    04A3    ORR	0x23
214:              		SEGM_TWO_POINT;
  117B    17A2    SETB	0x22,7
  117C    17A1    SETB	0x21,7
215:              		
216:              		if(PresetTimeH > 0)
  117D    0836    LD	A,0x36
  117E    1D03    SNZB	0x3,2
217:              		{
218:              			ON_LED_PRESETTIME;     //预约过, 预约状态灯常亮	
  117F    14A4    SETB	0x24,1
  1180    0008    RET
219:              		}	
220:              	}
221:              	//预约模式
222:              	else if(PresetState == PRESET_STATE)              
  1181    3002    LDIA	0x2
  1182    0639    XORA	0x39
  1183    1D03    SNZB	0x3,2
  1184    0008    RET
223:              	{
224:              		//调整预约时间, 预约灯闪烁
225:              		if(b_LedCol)
  1185    1AF0    SZB	0x70,5
226:              		{
227:              			ON_LED_PRESETTIME;			
  1186    14A4    SETB	0x24,1
228:              		}
229:              		DIG_Show_Time(PresetTimeH, PresetTimeM, 1);   //显示预约时间
  1187    0835    LD	A,0x35
  1188    00DF    LD	0x5F,A
  1189    01E0    CLR	0x60
  118A    0AE0    INCR	0x60
  118B    0836    LD	A,0x36
  118C    2F4F    JP	0x74F
230:              	}
231:              		
232:              }
233:              
234:              
235:              /*****************************************************************
236:               @fun:      Work_Mode_Show
237:               @brief:    工作模式显示
238:               @param:    None                             
239:               @retval:   None
240:              *****************************************************************/
241:              void Work_Mode_Show(void)
242:              {				
243:              	//12个功能灯
244:              	switch(ChooseFun)
  13F9    2C16    JP	0x416
245:              	{
246:              		case FUN_RICE		: 		ON_LED8;		break;
  13FA    1424    SETB	0x24,0
  13FB    2C42    JP	0x442
247:              		case FUN_MIXRICE	:		ON_LED16;		break;
  13FC    1425    SETB	0x25,0
  13FD    2C42    JP	0x442
248:              		case FUN_PORRIDGE	:		ON_LED1;		break;
  13FE    1724    SETB	0x24,6
  13FF    2C42    JP	0x442
249:              		case FUN_CONGEE		:		ON_LED9;		break;
  1400    1725    SETB	0x25,6
  1401    2C42    JP	0x442
250:              
251:              		case FUN_SOUP		:		ON_LED10;  		break;
  1402    15A5    SETB	0x25,3
  1403    2C42    JP	0x442
252:              		case FUN_COOKMEAT	:		ON_LED11;		break;
  1404    1525    SETB	0x25,2
  1405    2C42    JP	0x442
253:              		case FUN_RIB		:		ON_LED12;		break;
  1406    1625    SETB	0x25,4
  1407    2C42    JP	0x442
254:              		case FUN_CHICKEN	:		ON_LED13;		break;
  1408    16A5    SETB	0x25,5
  1409    2C42    JP	0x442
255:              
256:              		case FUN_EIGHTCONGEE:		ON_LED2;		break;
  140A    15A4    SETB	0x24,3
  140B    2C42    JP	0x442
257:              		case FUN_BEEF		:		ON_LED3;		break;
  140C    1524    SETB	0x24,2
  140D    2C42    JP	0x442
258:              		case FUN_BEAN		:		ON_LED4;		break;
  140E    1624    SETB	0x24,4
  140F    2C42    JP	0x442
259:              		case FUN_CAKE		:		ON_LED5;		break;
  1410    16A4    SETB	0x24,5
  1411    2C42    JP	0x442
260:              
261:              		case FUN_FASTHEAT	:		ON_LED7;		break;
  1412    17A4    SETB	0x24,7
  1413    2C42    JP	0x442
262:              		case FUN_OPENEHEAT	:		ON_LED14;		break;
  1414    14A5    SETB	0x25,1
  1415    2C42    JP	0x442
  1416    083C    LD	A,0x3C
  1417    3A01    XORIA	0x1
  1418    1903    SZB	0x3,2
  1419    2BFA    JP	0x3FA
  141A    3A03    XORIA	0x3
  141B    1903    SZB	0x3,2
  141C    2BFC    JP	0x3FC
  141D    3A01    XORIA	0x1
  141E    1903    SZB	0x3,2
  141F    2BFE    JP	0x3FE
  1420    3A07    XORIA	0x7
  1421    1903    SZB	0x3,2
  1422    2C00    JP	0x400
  1423    3A01    XORIA	0x1
  1424    1903    SZB	0x3,2
  1425    2C02    JP	0x402
  1426    3A03    XORIA	0x3
  1427    1903    SZB	0x3,2
  1428    2C04    JP	0x404
  1429    3A01    XORIA	0x1
  142A    1903    SZB	0x3,2
  142B    2C06    JP	0x406
  142C    3A0F    XORIA	0xF
  142D    1903    SZB	0x3,2
  142E    2C08    JP	0x408
  142F    3A01    XORIA	0x1
  1430    1903    SZB	0x3,2
  1431    2C0A    JP	0x40A
  1432    3A03    XORIA	0x3
  1433    1903    SZB	0x3,2
  1434    2C0C    JP	0x40C
  1435    3A01    XORIA	0x1
  1436    1903    SZB	0x3,2
  1437    2C0E    JP	0x40E
  1438    3A07    XORIA	0x7
  1439    1903    SZB	0x3,2
  143A    2C10    JP	0x410
  143B    3A01    XORIA	0x1
  143C    1903    SZB	0x3,2
  143D    2C12    JP	0x412
  143E    3A03    XORIA	0x3
  143F    1903    SZB	0x3,2
  1440    2C14    JP	0x414
  1441    2C42    JP	0x442
263:              	} 
264:              
265:              	//进度灯
266:              	// if(ChooseFun >=FUN_RICE && ChooseFun <= FUN_CAKE)
267:              	// {
268:              		if(ChooseFun >=FUN_RICE && ChooseFun <= FUN_FASTHEAT)
  1442    083C    LD	A,0x3C
  1443    1903    SZB	0x3,2
  1444    2C69    JP	0x469
  1445    300E    LDIA	0xE
  1446    023C    SUBA	0x3C
  1447    1803    SZB	0x3,0
  1448    2C69    JP	0x469
269:              		{
270:              			if(WorkStage != WORK_PRESET_STAGE)
  1449    033F    DECA	0x3F
  144A    1903    SZB	0x3,2
  144B    2C99    JP	0x499
271:              			{
272:              				if(WorkTimeS > 0 || WorkTimeM > 0)   ON_LED_STEP_1;
  144C    0834    LD	A,0x34
  144D    1903    SZB	0x3,2
  144E    083D    LD	A,0x3D
  144F    1D03    SNZB	0x3,2
  1450    14A6    SETB	0x26,1
273:              				if(Ad_Bot >= BOT_TEMP_100)           Led_Step_100C = 1;
  1451    309A    LDIA	0x9A
  1452    024F    SUBA	0x4F
  1453    1C03    SNZB	0x3,0
  1454    2C58    JP	0x458
  1455    3001    LDIA	0x1
  1456    1683    SETB	0x3,5
  1457    00CD    LD	0x4D,A
274:              				if(Led_Step_100C)                        ON_LED_STEP_2;
  1458    1683    SETB	0x3,5
  1459    084D    LD	A,0x4D
  145A    1283    CLRB	0x3,5
  145B    1D03    SNZB	0x3,2
  145C    17A6    SETB	0x26,7
275:              				if(WorkStage == WORK_COUNTDOWN_STAGE)
  145D    3003    LDIA	0x3
  145E    1283    CLRB	0x3,5
  145F    063F    XORA	0x3F
  1460    1D03    SNZB	0x3,2
  1461    2C99    JP	0x499
276:              				{
277:              					if(4*WorkTimeM >= 2*TotalTimeSave) ON_LED_STEP_3;
  1462    083E    LD	A,0x3E
  1463    00E2    LD	0x62,A
278:              					if(4*WorkTimeM >= 3*TotalTimeSave) ON_LED_STEP_4;
  1464    2799    CALL	0x799
  1465    160A    SETB	0xA,4
  1466    118A    CLRB	0xA,3
  1467    083E    LD	A,0x3E
  1468    2C81    JP	0x481
279:              				}		
280:              			}
281:              		}
282:              		else	//开盖收汁
283:              		{
284:              			ON_LED_STEP_1;
  1469    14A6    SETB	0x26,1
285:              			if(4*WorkTimeM >= 1*CountDownTimeSave) ON_LED_STEP_2;
  146A    083D    LD	A,0x3D
  146B    27C5    CALL	0x7C5
  146C    160A    SETB	0xA,4
  146D    118A    CLRB	0xA,3
  146E    3080    LDIA	0x80
  146F    0264    SUBA	0x64
  1470    1D03    SNZB	0x3,2
  1471    2C74    JP	0x474
  1472    0833    LD	A,0x33
  1473    0262    SUBA	0x62
  1474    1C03    SNZB	0x3,0
  1475    2C79    JP	0x479
  1476    1283    CLRB	0x3,5
  1477    1303    CLRB	0x3,6
  1478    17A6    SETB	0x26,7
286:              			if(4*WorkTimeM >= 2*CountDownTimeSave) ON_LED_STEP_3;
  1479    1283    CLRB	0x3,5
  147A    1303    CLRB	0x3,6
  147B    0833    LD	A,0x33
  147C    00E2    LD	0x62,A
287:              			if(4*WorkTimeM >= 3*CountDownTimeSave) ON_LED_STEP_4;
  147D    2799    CALL	0x799
  147E    160A    SETB	0xA,4
  147F    118A    CLRB	0xA,3
  1480    0833    LD	A,0x33
  1481    00DA    LD	0x5A,A
  1482    3003    LDIA	0x3
  1483    01DB    CLR	0x5B
  1484    00DC    LD	0x5C,A
  1485    01DD    CLR	0x5D
  1486    2736    CALL	0x736
  1487    160A    SETB	0xA,4
  1488    118A    CLRB	0xA,3
  1489    083D    LD	A,0x3D
  148A    27C5    CALL	0x7C5
  148B    160A    SETB	0xA,4
  148C    118A    CLRB	0xA,3
  148D    085B    LD	A,0x5B
  148E    3A80    XORIA	0x80
  148F    0264    SUBA	0x64
  1490    1D03    SNZB	0x3,2
  1491    2C94    JP	0x494
  1492    085A    LD	A,0x5A
  1493    0262    SUBA	0x62
  1494    1C03    SNZB	0x3,0
  1495    2C99    JP	0x499
  1496    1283    CLRB	0x3,5
  1497    1303    CLRB	0x3,6
  1498    1526    SETB	0x26,2
288:              		}
289:              
290:              		// if(WorkStage==WORK_HEAT_STAGE || WorkStage==WORK_COUNTDOWN_STAGE)
291:              		// {
292:              		// 	if(Ad_Bot < BOT_TEMP_100)	//底部小于100C
293:              		// 	{
294:              		// 		if(Led_Step_100C == TRUE)
295:              		// 		{
296:              		// 			ON_LED_STEP_1;	//闪烁
297:              		// 		}
298:              		// 		else
299:              		// 		{
300:              		// 			if(b_LedCol)	ON_LED_STEP_1;	//闪烁
301:              		// 		}
302:              		// 	}
303:              		// 	else
304:              		// 	{	
305:              		// 		Led_Step_100C = TRUE;
306:              		// 		ON_LED_STEP_1;	
307:              		// 		if(WorkStage==WORK_HEAT_STAGE)	//加热阶段
308:              		// 		{
309:              		// 			if(b_LedCol)	ON_LED_STEP_2;	//闪烁
310:              		// 		}
311:              		// 		if(WorkStage==WORK_COUNTDOWN_STAGE)	//加热阶段
312:              		// 		{
313:              		// 			ON_LED_STEP_2;
314:              		// 			if(CountDownTime >= CountDownTimeSave/2)
315:              		// 			{
316:              		// 				if(b_LedCol)	ON_LED_STEP_3;	//闪烁
317:              		// 			}
318:              		// 			else
319:              		// 			{
320:              		// 				ON_LED_STEP_3;
321:              		// 				if(b_LedCol)	ON_LED_STEP_4;	//闪烁
322:              		// 			}					
323:              		// 		}
324:              		// 	}
325:              		// }
326:              	//}
327:              
328:                  //预约阶段
329:              	if(WorkStage == WORK_PRESET_STAGE)
  1499    1283    CLRB	0x3,5
  149A    1303    CLRB	0x3,6
  149B    0B3F    SZDECA	0x3F
  149C    2CA6    JP	0x4A6
330:              	{
331:              		ON_LED_PRESETTIME;                                          //预约灯亮                                           
  149D    14A4    SETB	0x24,1
332:              		DIG_Show_Time(PresetTimeH, PresetTimeM, b_LedCol);       //预约倒计时   
  149E    0835    LD	A,0x35
  149F    00DF    LD	0x5F,A
  14A0    3000    LDIA	0x0
  14A1    1AF0    SZB	0x70,5
  14A2    3001    LDIA	0x1
  14A3    00E0    LD	0x60,A
  14A4    0836    LD	A,0x36
  14A5    2F4F    JP	0x74F
333:              	}
334:              	//加热阶段
335:              	else if(WorkStage == WORK_HEAT_STAGE)
  14A6    3002    LDIA	0x2
  14A7    063F    XORA	0x3F
  14A8    1D03    SNZB	0x3,2
  14A9    2CF0    JP	0x4F0
336:              	{
337:              		DIG_DATA_4 |= HOT_RUN_TAB[HorseCount][0];
  14AA    0832    LD	A,0x32
  14AB    00E2    LD	0x62,A
  14AC    3001    LDIA	0x1
  14AD    1003    CLRB	0x3,0
  14AE    0DE2    RLCR	0x62
  14AF    3EFF    ADDIA	0xFF
  14B0    1003    CLRB	0x3,0
  14B1    1D03    SNZB	0x3,2
  14B2    2CAE    JP	0x4AE
  14B3    0D62    RLCA	0x62
  14B4    27B8    CALL	0x7B8
  14B5    160A    SETB	0xA,4
  14B6    158A    SETB	0xA,3
  14B7    2000    CALL	0x0
  14BA    04A0    ORR	0x20
338:              	  	DIG_DATA_3 |= HOT_RUN_TAB[HorseCount][1];
  14BB    0832    LD	A,0x32
  14BC    00E2    LD	0x62,A
  14BD    3001    LDIA	0x1
  14BE    1003    CLRB	0x3,0
  14BF    0DE2    RLCR	0x62
  14C0    3EFF    ADDIA	0xFF
  14C1    1003    CLRB	0x3,0
  14C2    1D03    SNZB	0x3,2
  14C3    2CBF    JP	0x4BF
  14C4    0D62    RLCA	0x62
  14C5    3E01    ADDIA	0x1
  14C6    27B8    CALL	0x7B8
  14C7    160A    SETB	0xA,4
  14C8    158A    SETB	0xA,3
  14C9    2000    CALL	0x0
  14CC    04A1    ORR	0x21
339:              		DIG_DATA_2 |= HOT_RUN_TAB[HorseCount][2];
  14CD    0832    LD	A,0x32
  14CE    00E2    LD	0x62,A
  14CF    3001    LDIA	0x1
  14D0    1003    CLRB	0x3,0
  14D1    0DE2    RLCR	0x62
  14D2    3EFF    ADDIA	0xFF
  14D3    1003    CLRB	0x3,0
  14D4    1D03    SNZB	0x3,2
  14D5    2CD1    JP	0x4D1
  14D6    0D62    RLCA	0x62
  14D7    3E02    ADDIA	0x2
  14D8    27B8    CALL	0x7B8
  14D9    160A    SETB	0xA,4
  14DA    158A    SETB	0xA,3
  14DB    2000    CALL	0x0
  14DE    04A2    ORR	0x22
340:              	  	DIG_DATA_1 |= HOT_RUN_TAB[HorseCount][3];
  14DF    0832    LD	A,0x32
  14E0    00E2    LD	0x62,A
  14E1    3001    LDIA	0x1
  14E2    1003    CLRB	0x3,0
  14E3    0DE2    RLCR	0x62
  14E4    3EFF    ADDIA	0xFF
  14E5    1003    CLRB	0x3,0
  14E6    1D03    SNZB	0x3,2
  14E7    2CE3    JP	0x4E3
  14E8    0D62    RLCA	0x62
  14E9    3E03    ADDIA	0x3
  14EA    27B8    CALL	0x7B8
  14EB    160A    SETB	0xA,4
  14EC    158A    SETB	0xA,3
  14ED    2000    CALL	0x0
  14EE    04A3    ORR	0x23
341:              
342:              	}
  14EF    0008    RET
343:              	//倒计时阶段
344:              	else if(WorkStage == WORK_COUNTDOWN_STAGE)
  14F0    3003    LDIA	0x3
  14F1    063F    XORA	0x3F
  14F2    1D03    SNZB	0x3,2
  14F3    0008    RET
345:              	{
346:              		if( ChooseFun == FUN_OPENEHEAT || ChooseFun == FUN_CAKE)
  14F4    300E    LDIA	0xE
  14F5    063C    XORA	0x3C
  14F6    1903    SZB	0x3,2
  14F7    2CFC    JP	0x4FC
  14F8    300C    LDIA	0xC
  14F9    063C    XORA	0x3C
  14FA    1D03    SNZB	0x3,2
  14FB    2D36    JP	0x536
347:              		{
348:              			HourBuf = (CountDownTime)/60;
  14FC    303C    LDIA	0x3C
  14FD    00DA    LD	0x5A,A
  14FE    0840    LD	A,0x40
  14FF    271B    CALL	0x71B
  1500    160A    SETB	0xA,4
  1501    118A    CLRB	0xA,3
  1502    00B8    LD	0x38,A
349:              			MinBuf = (CountDownTime)%60;
350:              			DIG_DATA_4 |= 0;
  1503    303C    LDIA	0x3C
  1504    00DA    LD	0x5A,A
  1505    0840    LD	A,0x40
  1506    26FF    CALL	0x6FF
  1507    160A    SETB	0xA,4
  1508    118A    CLRB	0xA,3
  1509    00B7    LD	0x37,A
351:              			DIG_DATA_3 |= SEG_MATH_TAB[HourBuf%10];
  150A    300A    LDIA	0xA
  150B    00DA    LD	0x5A,A
  150C    0838    LD	A,0x38
  150D    26FF    CALL	0x6FF
  150E    160A    SETB	0xA,4
  150F    118A    CLRB	0xA,3
  1510    2792    CALL	0x792
  1511    160A    SETB	0xA,4
  1512    158A    SETB	0xA,3
  1513    2000    CALL	0x0
  1516    04A1    ORR	0x21
352:              			DIG_DATA_2 |= SEG_MATH_TAB[MinBuf/10];
  1517    300A    LDIA	0xA
  1518    00DA    LD	0x5A,A
  1519    0837    LD	A,0x37
  151A    271B    CALL	0x71B
  151B    160A    SETB	0xA,4
  151C    118A    CLRB	0xA,3
  151D    2792    CALL	0x792
  151E    160A    SETB	0xA,4
  151F    158A    SETB	0xA,3
  1520    2000    CALL	0x0
  1523    04A2    ORR	0x22
353:              			DIG_DATA_1 |= SEG_MATH_TAB[MinBuf%10];
  1524    300A    LDIA	0xA
  1525    00DA    LD	0x5A,A
  1526    0837    LD	A,0x37
  1527    26FF    CALL	0x6FF
  1528    160A    SETB	0xA,4
  1529    118A    CLRB	0xA,3
  152A    2792    CALL	0x792
  152B    160A    SETB	0xA,4
  152C    158A    SETB	0xA,3
  152D    2000    CALL	0x0
  1530    04A3    ORR	0x23
354:              			if(b_LedCol)
  1531    1EF0    SNZB	0x70,5
  1532    0008    RET
355:              			{
356:              				SEGM_TWO_POINT;
  1533    17A2    SETB	0x22,7
  1534    17A1    SETB	0x21,7
  1535    0008    RET
357:              			}
358:              		}
359:              		else
360:              		{
361:              			DIG_Show_Time(0, CountDownTime, 1);	      //保压时间右2位显示
  1536    0840    LD	A,0x40
  1537    00DF    LD	0x5F,A
  1538    3000    LDIA	0x0
  1539    01E0    CLR	0x60
  153A    0AE0    INCR	0x60
  153B    2F4F    JP	0x74F
362:              		}		
363:              	}
364:              	// //降压阶段
365:              	// else if(WorkStage == WORK_PREREDUCE_STAGE)	  
366:              	// {
367:              	// 	DIG_DATA_1 |= SEG_MATH_TAB[15];            //F
368:              	// }			
369:              }
370:              
371:              /*****************************************************************
372:               @fun:      Keepwarm_Show
373:               @brief:    保温模式显示
374:               @param:    None                             
375:               @retval:   None
376:              *****************************************************************/
377:              void Keepwarm_Show(void)
378:              {
379:              	//保温状态灯
380:                  ON_LED_KEEP_WARM;
  0204    17A5    SETB	0x25,7
381:              	//b	
382:              	DIG_DATA_1 |= SEG_MATH_TAB[11];	
  0205    3083    LDIA	0x83
  0206    0084    LD	0x4,A
  0207    3099    LDIA	0x99
  0208    00FF    LD	0x7F,A
  0209    160A    SETB	0xA,4
  020A    158A    SETB	0xA,3
  020B    2000    CALL	0x0
  020E    04A3    ORR	0x23
383:              	if(b_AutoKeepWarm)
  020F    1E70    SNZB	0x70,4
  0210    0008    RET
  0211    2A2E    JP	0x22E
384:              	{
385:              		//自动进入保温显示功能灯
386:              		switch(ChooseFunSave)
387:              		{
388:              			case FUN_RICE		: 		ON_LED8;		break;
  0212    1424    SETB	0x24,0
  0213    2A5A    JP	0x25A
389:              			case FUN_MIXRICE	:		ON_LED16;		break;
  0214    1425    SETB	0x25,0
  0215    2A5A    JP	0x25A
390:              			case FUN_PORRIDGE	:		ON_LED1;		break;
  0216    1724    SETB	0x24,6
  0217    2A5A    JP	0x25A
391:              			case FUN_CONGEE		:		ON_LED9;		break;
  0218    1725    SETB	0x25,6
  0219    2A5A    JP	0x25A
392:              
393:              			case FUN_SOUP		:		ON_LED10;  		break;
  021A    15A5    SETB	0x25,3
  021B    2A5A    JP	0x25A
394:              			case FUN_COOKMEAT	:		ON_LED11;		break;
  021C    1525    SETB	0x25,2
  021D    2A5A    JP	0x25A
395:              			case FUN_RIB		:		ON_LED12;		break;
  021E    1625    SETB	0x25,4
  021F    2A5A    JP	0x25A
396:              			case FUN_CHICKEN	:		ON_LED13;		break;
  0220    16A5    SETB	0x25,5
  0221    2A5A    JP	0x25A
397:              
398:              			case FUN_EIGHTCONGEE:		ON_LED2;		break;
  0222    15A4    SETB	0x24,3
  0223    2A5A    JP	0x25A
399:              			case FUN_BEEF		:		ON_LED3;		break;
  0224    1524    SETB	0x24,2
  0225    2A5A    JP	0x25A
400:              			case FUN_BEAN		:		ON_LED4;		break;
  0226    1624    SETB	0x24,4
  0227    2A5A    JP	0x25A
401:              			case FUN_CAKE		:		ON_LED5;		break;
  0228    16A4    SETB	0x24,5
  0229    2A5A    JP	0x25A
402:              
403:              			case FUN_FASTHEAT	:		ON_LED7;		break;
  022A    17A4    SETB	0x24,7
  022B    2A5A    JP	0x25A
404:              			case FUN_OPENEHEAT	:		ON_LED14;		break;
  022C    14A5    SETB	0x25,1
  022D    2A5A    JP	0x25A
  022E    087B    LD	A,0x7B
  022F    3A01    XORIA	0x1
  0230    1903    SZB	0x3,2
  0231    2A12    JP	0x212
  0232    3A03    XORIA	0x3
  0233    1903    SZB	0x3,2
  0234    2A14    JP	0x214
  0235    3A01    XORIA	0x1
  0236    1903    SZB	0x3,2
  0237    2A16    JP	0x216
  0238    3A07    XORIA	0x7
  0239    1903    SZB	0x3,2
  023A    2A18    JP	0x218
  023B    3A01    XORIA	0x1
  023C    1903    SZB	0x3,2
  023D    2A1A    JP	0x21A
  023E    3A03    XORIA	0x3
  023F    1903    SZB	0x3,2
  0240    2A1C    JP	0x21C
  0241    3A01    XORIA	0x1
  0242    1903    SZB	0x3,2
  0243    2A1E    JP	0x21E
  0244    3A0F    XORIA	0xF
  0245    1903    SZB	0x3,2
  0246    2A20    JP	0x220
  0247    3A01    XORIA	0x1
  0248    1903    SZB	0x3,2
  0249    2A22    JP	0x222
  024A    3A03    XORIA	0x3
  024B    1903    SZB	0x3,2
  024C    2A24    JP	0x224
  024D    3A01    XORIA	0x1
  024E    1903    SZB	0x3,2
  024F    2A26    JP	0x226
  0250    3A07    XORIA	0x7
  0251    1903    SZB	0x3,2
  0252    2A28    JP	0x228
  0253    3A01    XORIA	0x1
  0254    1903    SZB	0x3,2
  0255    2A2A    JP	0x22A
  0256    3A03    XORIA	0x3
  0257    1903    SZB	0x3,2
  0258    2A2C    JP	0x22C
  0259    2A5A    JP	0x25A
405:              		}
406:              		ON_LED_STEP_1;
  025A    14A6    SETB	0x26,1
407:              		ON_LED_STEP_2;
  025B    17A6    SETB	0x26,7
408:              		ON_LED_STEP_3;
  025C    1626    SETB	0x26,4
409:              		ON_LED_STEP_4;
  025D    1526    SETB	0x26,2
410:              		ON_LED_STEP_KEEP_WARM;
  025E    15A6    SETB	0x26,3
  025F    0008    RET
411:              	}
412:                					
413:              }
414:              
415:              /*****************************************************************
416:               @fun:      Error_Show
417:               @brief:    报警错误显示E0-E11
418:               @param:    None                             
419:               @retval:   None
420:              *****************************************************************/
421:              void Error_Show(void)
422:              {
423:              	DIG_DATA_4 = 0;						
  01E6    01A0    CLR	0x20
424:              	DIG_DATA_3 = SEG_MATH_TAB[14];				 
  01E7    3086    LDIA	0x86
  01E8    0084    LD	0x4,A
  01E9    3099    LDIA	0x99
  01EA    00FF    LD	0x7F,A
  01EB    160A    SETB	0xA,4
  01EC    158A    SETB	0xA,3
  01ED    2000    CALL	0x0
  01F0    00A1    LD	0x21,A
425:              	DIG_DATA_2 = SEG_MATH_TAB[ErrorCode%10];
  01F1    300A    LDIA	0xA
  01F2    00DA    LD	0x5A,A
  01F3    0858    LD	A,0x58
  01F4    160A    SETB	0xA,4
  01F5    118A    CLRB	0xA,3
  01F6    26FF    CALL	0x6FF
  01F9    160A    SETB	0xA,4
  01FA    118A    CLRB	0xA,3
  01FB    2792    CALL	0x792
  01FE    160A    SETB	0xA,4
  01FF    158A    SETB	0xA,3
  0200    2000    CALL	0x0
  0201    00A2    LD	0x22,A
426:              	DIG_DATA_1 = 0;		
  0202    01A3    CLR	0x23
  0203    0008    RET
427:              }
428:              
429:              /*****************************************************************
430:               @fun:      Test_Mode_Show
431:               @brief:    查看参数显示
432:               @param:    None                             
433:               @retval:   None
434:              *****************************************************************/
435:              void Test_Mode_Show(void)
436:              {
437:              	if(TestShow < TEST_SHOW_NUM)
  118D    3002    LDIA	0x2
  118E    0231    SUBA	0x31
  118F    1803    SZB	0x3,0
  1190    2995    JP	0x195
438:              	{
439:              		//参数显示清除数码管显示内容
440:              		DIG_DATA_4 = 0;
  1191    01A0    CLR	0x20
441:              		DIG_DATA_3 = 0;				
  1192    01A1    CLR	0x21
442:              		DIG_DATA_2 = 0;
  1193    01A2    CLR	0x22
443:              		DIG_DATA_1 = 0;
  1194    01A3    CLR	0x23
  1195    0831    LD	A,0x31
  1196    3A00    XORIA	0x0
  1197    1903    SZB	0x3,2
  1198    299D    JP	0x19D
  1199    3A01    XORIA	0x1
  119A    1903    SZB	0x3,2
  119B    2ABE    JP	0x2BE
  119C    2B14    JP	0x314
444:              	}
445:              		
446:              	switch(TestShow)
447:              	{
448:              		case 0:					//1--b  基本传感器数据
449:              			if(SendShow == 0)
  119D    0830    LD	A,0x30
  119E    1D03    SNZB	0x3,2
  119F    29BA    JP	0x1BA
450:              			{
451:              				DIG_Show_Data(SEG_MATH_TAB[1], SEGM_G, SEGM_G, SEG_MATH_TAB[11]);
  11A0    3040    LDIA	0x40
  11A1    00DF    LD	0x5F,A
  11A2    00E0    LD	0x60,A
  11A3    3083    LDIA	0x83
  11A4    0084    LD	0x4,A
  11A5    3099    LDIA	0x99
  11A6    00FF    LD	0x7F,A
  11A7    160A    SETB	0xA,4
  11A8    158A    SETB	0xA,3
  11A9    2000    CALL	0x0
  11AC    00E1    LD	0x61,A
  11AD    3079    LDIA	0x79
  11AE    0084    LD	0x4,A
  11AF    3099    LDIA	0x99
  11B0    00FF    LD	0x7F,A
  11B1    160A    SETB	0xA,4
  11B2    158A    SETB	0xA,3
  11B3    2000    CALL	0x0
  11B6    2315    CALL	0x315
  11B7    160A    SETB	0xA,4
  11B8    118A    CLRB	0xA,3
452:              			}
  11B9    2A8E    JP	0x28E
453:              			else if(SendShow == 1)              //Bot_Temp 底部温度
  11BA    0B30    SZDECA	0x30
  11BB    29D0    JP	0x1D0
454:              			{
455:              				HourBuf = Bot_Temp/100;		  
  11BC    3064    LDIA	0x64
  11BD    00DA    LD	0x5A,A
  11BE    084E    LD	A,0x4E
  11BF    271B    CALL	0x71B
  11C0    160A    SETB	0xA,4
  11C1    118A    CLRB	0xA,3
  11C2    00B8    LD	0x38,A
456:              				MinBuf = Bot_Temp%100;				
  11C3    3064    LDIA	0x64
  11C4    00DA    LD	0x5A,A
  11C5    084E    LD	A,0x4E
  11C6    26FF    CALL	0x6FF
  11C7    160A    SETB	0xA,4
  11C8    118A    CLRB	0xA,3
  11C9    00B7    LD	0x37,A
457:              				DIG_DATA_4 = SEGM_D;
  11CA    3008    LDIA	0x8
  11CB    00A0    LD	0x20,A
458:              				
459:              				if(REL_PORT) 
  11CC    1C87    SNZB	0x7,1
  11CD    2A8E    JP	0x28E
460:              				{
461:              					DIG_DATA_4 |= SEGM_G;	
  11CE    1720    SETB	0x20,6
  11CF    2A8E    JP	0x28E
462:              				} 						
463:              			}
464:              			else if(SendShow == 2)              //底部AD值
  11D0    3002    LDIA	0x2
  11D1    0630    XORA	0x30
  11D2    1D03    SNZB	0x3,2
  11D3    29E4    JP	0x1E4
465:              			{
466:              				HourBuf = Ad_Bot/100;
  11D4    3064    LDIA	0x64
  11D5    00DA    LD	0x5A,A
  11D6    084F    LD	A,0x4F
  11D7    271B    CALL	0x71B
  11D8    160A    SETB	0xA,4
  11D9    118A    CLRB	0xA,3
  11DA    00B8    LD	0x38,A
467:              				MinBuf = Ad_Bot%100;				
  11DB    3064    LDIA	0x64
  11DC    00DA    LD	0x5A,A
  11DD    084F    LD	A,0x4F
  11DE    26FF    CALL	0x6FF
  11DF    160A    SETB	0xA,4
  11E0    118A    CLRB	0xA,3
  11E1    00B7    LD	0x37,A
468:              				DIG_DATA_4 = DIG_b;	      
  11E2    307C    LDIA	0x7C
  11E3    2A8D    JP	0x28D
469:              			}
470:              			else if(SendShow == 3)              //压力开关AD值
  11E4    3003    LDIA	0x3
  11E5    0630    XORA	0x30
  11E6    1D03    SNZB	0x3,2
  11E7    2A03    JP	0x203
471:              			{
472:              				HourBuf = b_PressureOn/100;
  11E8    3064    LDIA	0x64
  11E9    00DA    LD	0x5A,A
  11EA    01DB    CLR	0x5B
  11EB    1003    CLRB	0x3,0
  11EC    1AF2    SZB	0x72,5
  11ED    1403    SETB	0x3,0
  11EE    27EE    CALL	0x7EE
  11EF    160A    SETB	0xA,4
  11F0    118A    CLRB	0xA,3
  11F1    2353    CALL	0x353
  11F2    160A    SETB	0xA,4
  11F3    118A    CLRB	0xA,3
473:              				MinBuf = b_PressureOn%100;
  11F4    27E7    CALL	0x7E7
  11F5    160A    SETB	0xA,4
  11F6    118A    CLRB	0xA,3
  11F7    1AF2    SZB	0x72,5
  11F8    1403    SETB	0x3,0
  11F9    27FA    CALL	0x7FA
  11FA    160A    SETB	0xA,4
  11FB    118A    CLRB	0xA,3
  11FC    2398    CALL	0x398
  11FD    160A    SETB	0xA,4
  11FE    118A    CLRB	0xA,3
  11FF    085A    LD	A,0x5A
  1200    00B7    LD	0x37,A
474:              				
475:              				DIG_DATA_4 = DIG_P;	       
  1201    3073    LDIA	0x73
  1202    2A8D    JP	0x28D
476:              			}
477:              			else if(SendShow == 4)            //干簧管信号            
  1203    3004    LDIA	0x4
  1204    0630    XORA	0x30
  1205    1D03    SNZB	0x3,2
  1206    2A22    JP	0x222
478:              			{
479:              				HourBuf = b_LidClosed/100;
  1207    3064    LDIA	0x64
  1208    00DA    LD	0x5A,A
  1209    01DB    CLR	0x5B
  120A    1003    CLRB	0x3,0
  120B    1BF2    SZB	0x72,7
  120C    1403    SETB	0x3,0
  120D    27EE    CALL	0x7EE
  120E    160A    SETB	0xA,4
  120F    118A    CLRB	0xA,3
  1210    2353    CALL	0x353
  1211    160A    SETB	0xA,4
  1212    118A    CLRB	0xA,3
480:              				MinBuf = b_LidClosed%100;
  1213    27E7    CALL	0x7E7
  1214    160A    SETB	0xA,4
  1215    118A    CLRB	0xA,3
  1216    1BF2    SZB	0x72,7
  1217    1403    SETB	0x3,0
  1218    27FA    CALL	0x7FA
  1219    160A    SETB	0xA,4
  121A    118A    CLRB	0xA,3
  121B    2398    CALL	0x398
  121C    160A    SETB	0xA,4
  121D    118A    CLRB	0xA,3
  121E    085A    LD	A,0x5A
  121F    00B7    LD	0x37,A
481:              				
482:              				DIG_DATA_4 = DIG_L;		      
  1220    3038    LDIA	0x38
  1221    2A8D    JP	0x28D
483:              			}
484:              			else if(SendShow == 5)            //市电电压有效值           
  1222    3005    LDIA	0x5
  1223    0630    XORA	0x30
  1224    1D03    SNZB	0x3,2
  1225    2A40    JP	0x240
485:              			{
486:              				HourBuf = AC_Vol_Rms/100;
  1226    3064    LDIA	0x64
  1227    00DA    LD	0x5A,A
  1228    01DB    CLR	0x5B
  1229    0868    LD	A,0x68
  122A    00DD    LD	0x5D,A
  122B    0867    LD	A,0x67
  122C    00DC    LD	0x5C,A
  122D    2329    CALL	0x329
  122E    160A    SETB	0xA,4
  122F    118A    CLRB	0xA,3
  1230    085A    LD	A,0x5A
  1231    00B8    LD	0x38,A
487:              				MinBuf = AC_Vol_Rms%100;
  1232    3064    LDIA	0x64
  1233    00DA    LD	0x5A,A
  1234    01DB    CLR	0x5B
  1235    0868    LD	A,0x68
  1236    00DD    LD	0x5D,A
  1237    0867    LD	A,0x67
  1238    00DC    LD	0x5C,A
  1239    23D5    CALL	0x3D5
  123A    160A    SETB	0xA,4
  123B    118A    CLRB	0xA,3
  123C    085A    LD	A,0x5A
  123D    00B7    LD	0x37,A
488:              				
489:              				DIG_DATA_4 = DIG_U;		      
  123E    303E    LDIA	0x3E
  123F    2A8D    JP	0x28D
490:              			}
491:              			else if(SendShow == 6)            //单次零点检测时间250us*次数          
  1240    3006    LDIA	0x6
  1241    0630    XORA	0x30
  1242    1D03    SNZB	0x3,2
  1243    2A66    JP	0x266
492:              			{
493:              				HourBuf = ZeroTimesShow/100;
  1244    3064    LDIA	0x64
  1245    00DA    LD	0x5A,A
  1246    01DB    CLR	0x5B
  1247    1683    SETB	0x3,5
  1248    0839    LD	A,0x39
  1249    1283    CLRB	0x3,5
  124A    00DD    LD	0x5D,A
  124B    1683    SETB	0x3,5
  124C    0838    LD	A,0x38
  124D    1283    CLRB	0x3,5
  124E    00DC    LD	0x5C,A
  124F    2329    CALL	0x329
  1250    160A    SETB	0xA,4
  1251    118A    CLRB	0xA,3
  1252    085A    LD	A,0x5A
  1253    00B8    LD	0x38,A
494:              				MinBuf = ZeroTimesShow%100;
  1254    3064    LDIA	0x64
  1255    00DA    LD	0x5A,A
  1256    01DB    CLR	0x5B
  1257    1683    SETB	0x3,5
  1258    0839    LD	A,0x39
  1259    1283    CLRB	0x3,5
  125A    00DD    LD	0x5D,A
  125B    1683    SETB	0x3,5
  125C    0838    LD	A,0x38
  125D    1283    CLRB	0x3,5
  125E    00DC    LD	0x5C,A
  125F    23D5    CALL	0x3D5
  1260    160A    SETB	0xA,4
  1261    118A    CLRB	0xA,3
  1262    085A    LD	A,0x5A
  1263    00B7    LD	0x37,A
495:              				
496:              				DIG_DATA_4 = SEGM_D+SEGM_E+SEGM_F+SEGM_G;		      
  1264    3078    LDIA	0x78
  1265    2A8D    JP	0x28D
497:              			}
498:              			else if(SendShow == 7)            //继电器强制动作次数        
  1266    3007    LDIA	0x7
  1267    0630    XORA	0x30
  1268    1D03    SNZB	0x3,2
  1269    2A7A    JP	0x27A
499:              			{
500:              				HourBuf = ZeroTimeoutCnt/100;
  126A    3064    LDIA	0x64
  126B    00DA    LD	0x5A,A
  126C    083A    LD	A,0x3A
  126D    271B    CALL	0x71B
  126E    160A    SETB	0xA,4
  126F    118A    CLRB	0xA,3
  1270    00B8    LD	0x38,A
501:              				MinBuf = ZeroTimeoutCnt%100;
  1271    3064    LDIA	0x64
  1272    00DA    LD	0x5A,A
  1273    083A    LD	A,0x3A
  1274    26FF    CALL	0x6FF
  1275    160A    SETB	0xA,4
  1276    118A    CLRB	0xA,3
  1277    00B7    LD	0x37,A
502:              				
503:              				DIG_DATA_4 = SEGM_B;		      
  1278    3002    LDIA	0x2
  1279    2A8D    JP	0x28D
504:              			}
505:              			else if(SendShow == SEND_SHOW_NUM_1)            //食物量的时间        
  127A    3008    LDIA	0x8
  127B    0630    XORA	0x30
  127C    1D03    SNZB	0x3,2
  127D    2A8E    JP	0x28E
506:              			{
507:              				HourBuf = JudgeLidMin/100;
  127E    3064    LDIA	0x64
  127F    00DA    LD	0x5A,A
  1280    082F    LD	A,0x2F
  1281    271B    CALL	0x71B
  1282    160A    SETB	0xA,4
  1283    118A    CLRB	0xA,3
  1284    00B8    LD	0x38,A
508:              				MinBuf = JudgeLidMin%100;
  1285    3064    LDIA	0x64
  1286    00DA    LD	0x5A,A
  1287    082F    LD	A,0x2F
  1288    26FF    CALL	0x6FF
  1289    160A    SETB	0xA,4
  128A    118A    CLRB	0xA,3
  128B    00B7    LD	0x37,A
509:              				
510:              				DIG_DATA_4 = DIG_J;		      
  128C    301E    LDIA	0x1E
  128D    00A0    LD	0x20,A
511:              			}
512:              			
513:              			
514:              			//更新内容
515:              			if(SendShow >= 1 && SendShow <= SEND_SHOW_NUM_1)
  128E    0830    LD	A,0x30
  128F    1903    SZB	0x3,2
  1290    0008    RET
  1291    3009    LDIA	0x9
  1292    0230    SUBA	0x30
  1293    1803    SZB	0x3,0
  1294    0008    RET
516:              			{							
517:              				DIG_Show_Data(0, SEG_MATH_TAB[HourBuf%10], SEG_MATH_TAB[MinBuf/10], SEG_MATH_TAB[MinBuf%10]);			
  1295    300A    LDIA	0xA
  1296    00DA    LD	0x5A,A
  1297    0838    LD	A,0x38
  1298    26FF    CALL	0x6FF
  1299    160A    SETB	0xA,4
  129A    118A    CLRB	0xA,3
  129B    2792    CALL	0x792
  129C    160A    SETB	0xA,4
  129D    158A    SETB	0xA,3
  129E    2000    CALL	0x0
  12A1    00DF    LD	0x5F,A
  12A2    300A    LDIA	0xA
  12A3    00DA    LD	0x5A,A
  12A4    0837    LD	A,0x37
  12A5    271B    CALL	0x71B
  12A6    160A    SETB	0xA,4
  12A7    118A    CLRB	0xA,3
  12A8    2792    CALL	0x792
  12A9    160A    SETB	0xA,4
  12AA    158A    SETB	0xA,3
  12AB    2000    CALL	0x0
  12AE    00E0    LD	0x60,A
  12AF    300A    LDIA	0xA
  12B0    00DA    LD	0x5A,A
  12B1    0837    LD	A,0x37
  12B2    26FF    CALL	0x6FF
  12B3    160A    SETB	0xA,4
  12B4    118A    CLRB	0xA,3
  12B5    2792    CALL	0x792
  12B6    160A    SETB	0xA,4
  12B7    158A    SETB	0xA,3
  12B8    2000    CALL	0x0
  12BB    00E1    LD	0x61,A
  12BC    3000    LDIA	0x0
  12BD    2B15    JP	0x315
518:              			}
519:              						
520:              			break;
521:              
522:              		case 1:					//2--S  发送操作指令
523:              			if(SendShow==0)
  12BE    0830    LD	A,0x30
  12BF    1D03    SNZB	0x3,2
  12C0    2AE0    JP	0x2E0
524:              			{
525:              				DIG_Show_Data(0,0,SEG_MATH_TAB[Fc_ID[SendShow]>>4],SEG_MATH_TAB[Fc_ID[SendShow]&0x0f]);
  12C1    01DF    CLR	0x5F
  12C2    27D1    CALL	0x7D1
  12C3    160A    SETB	0xA,4
  12C4    118A    CLRB	0xA,3
  12C5    2792    CALL	0x792
  12C6    160A    SETB	0xA,4
  12C7    158A    SETB	0xA,3
  12C8    2000    CALL	0x0
  12CB    00E0    LD	0x60,A
  12CC    0830    LD	A,0x30
  12CD    27BF    CALL	0x7BF
  12CE    160A    SETB	0xA,4
  12CF    118A    CLRB	0xA,3
  12D0    2792    CALL	0x792
  12D1    160A    SETB	0xA,4
  12D2    158A    SETB	0xA,3
  12D3    2000    CALL	0x0
  12D6    00E1    LD	0x61,A
  12D7    3000    LDIA	0x0
  12D8    2315    CALL	0x315
526:              				DIG_DATA_4 = DIG_I;
  12D9    3006    LDIA	0x6
  12DA    00A0    LD	0x20,A
527:              				DIG_DATA_3 = DIG_D;
  12DB    305E    LDIA	0x5E
  12DC    00A1    LD	0x21,A
528:              				SEGM_TWO_POINT;
  12DD    17A2    SETB	0x22,7
  12DE    17A1    SETB	0x21,7
529:              			}
  12DF    0008    RET
530:              			else
531:              			{
532:              				DIG_Show_Data(SEG_MATH_TAB[Fc_ID[(SendShow-1)*2+1]>>4],SEG_MATH_TAB[(Fc_ID[(SendShow-1)*2+1]&0x0f)],SEG_MATH_TAB[Fc_ID[(SendShow-1)*2+2]>>4],SEG_MATH_TAB[(Fc_ID[(SendShow-1)*2+2]&0x0f)]);
  12E0    1003    CLRB	0x3,0
  12E1    0D30    RLCA	0x30
  12E2    3E9F    ADDIA	0x9F
  12E3    0084    LD	0x4,A
  12E4    1383    CLRB	0x3,7
  12E5    0800    LD	A,0x0
  12E6    390F    ANDIA	0xF
  12E7    2792    CALL	0x792
  12E8    160A    SETB	0xA,4
  12E9    158A    SETB	0xA,3
  12EA    2000    CALL	0x0
  12ED    00DF    LD	0x5F,A
  12EE    1003    CLRB	0x3,0
  12EF    0D30    RLCA	0x30
  12F0    27D1    CALL	0x7D1
  12F1    160A    SETB	0xA,4
  12F2    118A    CLRB	0xA,3
  12F3    2792    CALL	0x792
  12F4    160A    SETB	0xA,4
  12F5    158A    SETB	0xA,3
  12F6    2000    CALL	0x0
  12F9    00E0    LD	0x60,A
  12FA    1003    CLRB	0x3,0
  12FB    0D30    RLCA	0x30
  12FC    27BF    CALL	0x7BF
  12FD    160A    SETB	0xA,4
  12FE    118A    CLRB	0xA,3
  12FF    2792    CALL	0x792
  1300    160A    SETB	0xA,4
  1301    158A    SETB	0xA,3
  1302    2000    CALL	0x0
  1305    00E1    LD	0x61,A
  1306    1003    CLRB	0x3,0
  1307    0D30    RLCA	0x30
  1308    3E9F    ADDIA	0x9F
  1309    0084    LD	0x4,A
  130A    1383    CLRB	0x3,7
  130B    0E00    SWAPA	0x0
  130C    390F    ANDIA	0xF
  130D    2792    CALL	0x792
  130E    160A    SETB	0xA,4
  130F    158A    SETB	0xA,3
  1310    2000    CALL	0x0
  1313    2B15    JP	0x315
  1314    0008    RET
533:              			}																																																																																		
534:              			break;
535:              			
536:              		default: break;	
537:              	}			
538:              }
539:              
540:              
541:              /*****************************************************************
542:               @fun:      Factory_Show
543:               @brief:    工厂检测模式显示
544:               @param:    None                             
545:               @retval:   None
546:              *****************************************************************/
547:              void Factory_Show(void)
548:              {
549:              
550:              	switch(FactoryTestData)	
  153C    2E8D    JP	0x68D
551:              	{
552:              		case FACTORY_TEST_COUNT: 		    				
553:              			if(b_Auto_test) 
  153D    1DF1    SNZB	0x71,3
  153E    2D59    JP	0x559
554:              			{
555:              				//显示PASS
556:              				DIG_DATA_4 |= DIG_P;    
  153F    3073    LDIA	0x73
  1540    04A0    ORR	0x20
557:              				DIG_DATA_3 |= SEG_MATH_TAB[10];
  1541    3082    LDIA	0x82
  1542    0084    LD	0x4,A
  1543    3099    LDIA	0x99
  1544    00FF    LD	0x7F,A
  1545    160A    SETB	0xA,4
  1546    158A    SETB	0xA,3
  1547    2000    CALL	0x0
  154A    04A1    ORR	0x21
558:              				DIG_DATA_2 |= SEG_MATH_TAB[5];
  154B    307D    LDIA	0x7D
  154C    0084    LD	0x4,A
  154D    3099    LDIA	0x99
  154E    00FF    LD	0x7F,A
  154F    160A    SETB	0xA,4
  1550    158A    SETB	0xA,3
  1551    2000    CALL	0x0
  1554    04A2    ORR	0x22
559:              				DIG_DATA_1 |= SEG_MATH_TAB[5];	
  1555    307D    LDIA	0x7D
  1556    0084    LD	0x4,A
  1557    3099    LDIA	0x99
  1558    2E1D    JP	0x61D
560:              				break;	
561:              			}
562:              		   // LED_TEST_COUNT; 				        		   		 					
563:              			DIG_DATA_4 |= SEG_MATH_TAB[0];
  1559    3078    LDIA	0x78
  155A    0084    LD	0x4,A
  155B    3099    LDIA	0x99
  155C    00FF    LD	0x7F,A
  155D    160A    SETB	0xA,4
  155E    158A    SETB	0xA,3
  155F    2000    CALL	0x0
  1562    04A0    ORR	0x20
564:              			DIG_DATA_3 |= SEG_MATH_TAB[0];		 
  1563    3078    LDIA	0x78
  1564    0084    LD	0x4,A
  1565    3099    LDIA	0x99
  1566    00FF    LD	0x7F,A
  1567    160A    SETB	0xA,4
  1568    158A    SETB	0xA,3
  1569    2000    CALL	0x0
  156C    04A1    ORR	0x21
565:              			DIG_DATA_2 |= SEG_MATH_TAB[CountDownTime/10];	 
  156D    300A    LDIA	0xA
  156E    00DA    LD	0x5A,A
  156F    0840    LD	A,0x40
  1570    271B    CALL	0x71B
  1571    160A    SETB	0xA,4
  1572    118A    CLRB	0xA,3
  1573    2792    CALL	0x792
  1574    160A    SETB	0xA,4
  1575    158A    SETB	0xA,3
  1576    2000    CALL	0x0
  1579    04A2    ORR	0x22
566:              			DIG_DATA_1 |= SEG_MATH_TAB[CountDownTime%10];
  157A    300A    LDIA	0xA
  157B    00DA    LD	0x5A,A
  157C    0840    LD	A,0x40
  157D    26FF    CALL	0x6FF
  157E    160A    SETB	0xA,4
  157F    118A    CLRB	0xA,3
  1580    2792    CALL	0x792
  1581    160A    SETB	0xA,4
  1582    158A    SETB	0xA,3
  1583    2000    CALL	0x0
  1586    04A3    ORR	0x23
567:              			if(b_LedCol)	
  1587    1EF0    SNZB	0x70,5
  1588    2ECE    JP	0x6CE
568:              			{
569:              				SEGM_TWO_POINT;		
  1589    17A2    SETB	0x22,7
  158A    17A1    SETB	0x21,7
  158B    2ECE    JP	0x6CE
570:              			}
571:              
572:              			break;	
573:              		case FACTORY_TEST_START:					    	
574:              			if(b_Auto_test)
  158C    1DF1    SNZB	0x71,3
  158D    2DD0    JP	0x5D0
575:              			{				
576:              				if(b_LidClosed == FALSE)
  158E    1BF2    SZB	0x72,7
  158F    2D93    JP	0x593
577:              				{
578:              					//开关量变高,显示PASS
579:              					FactoryTestData = FACTORY_TEST_COUNT;
  1590    3014    LDIA	0x14
  1591    00C1    LD	0x41,A
580:              				}
  1592    2ECE    JP	0x6CE
581:              				else
582:              				{
583:              					DIG_DATA_4 |= HOT_RUN_TAB[HorseCount][0];    
  1593    0832    LD	A,0x32
  1594    00DF    LD	0x5F,A
  1595    3001    LDIA	0x1
  1596    1003    CLRB	0x3,0
  1597    0DDF    RLCR	0x5F
  1598    3EFF    ADDIA	0xFF
  1599    1003    CLRB	0x3,0
  159A    1D03    SNZB	0x3,2
  159B    2D97    JP	0x597
  159C    0D5F    RLCA	0x5F
  159D    27B8    CALL	0x7B8
  159E    160A    SETB	0xA,4
  159F    158A    SETB	0xA,3
  15A0    2000    CALL	0x0
  15A3    04A0    ORR	0x20
584:              					DIG_DATA_3 |= HOT_RUN_TAB[HorseCount][1];
  15A4    0832    LD	A,0x32
  15A5    00DF    LD	0x5F,A
  15A6    3001    LDIA	0x1
  15A7    1003    CLRB	0x3,0
  15A8    0DDF    RLCR	0x5F
  15A9    3EFF    ADDIA	0xFF
  15AA    1003    CLRB	0x3,0
  15AB    1D03    SNZB	0x3,2
  15AC    2DA8    JP	0x5A8
  15AD    0D5F    RLCA	0x5F
  15AE    3E01    ADDIA	0x1
  15AF    27B8    CALL	0x7B8
  15B0    160A    SETB	0xA,4
  15B1    158A    SETB	0xA,3
  15B2    2000    CALL	0x0
  15B5    04A1    ORR	0x21
585:              					DIG_DATA_2 |= HOT_RUN_TAB[HorseCount][2];
  15B6    0832    LD	A,0x32
  15B7    00DF    LD	0x5F,A
  15B8    3001    LDIA	0x1
  15B9    1003    CLRB	0x3,0
  15BA    0DDF    RLCR	0x5F
  15BB    3EFF    ADDIA	0xFF
  15BC    1003    CLRB	0x3,0
  15BD    1D03    SNZB	0x3,2
  15BE    2DBA    JP	0x5BA
  15BF    0D5F    RLCA	0x5F
  15C0    3E02    ADDIA	0x2
  15C1    27B8    CALL	0x7B8
  15C2    160A    SETB	0xA,4
  15C3    158A    SETB	0xA,3
  15C4    2000    CALL	0x0
586:              					DIG_DATA_1 |= HOT_RUN_TAB[HorseCount][3];					
  15C7    27F4    CALL	0x7F4
  15C8    160A    SETB	0xA,4
  15C9    118A    CLRB	0xA,3
  15CA    0DDF    RLCR	0x5F
  15CB    3EFF    ADDIA	0xFF
  15CC    1003    CLRB	0x3,0
  15CD    1D03    SNZB	0x3,2
  15CE    2DCA    JP	0x5CA
  15CF    2E16    JP	0x616
587:              				}
588:              				break;
589:              			} 
590:              		   // LED_TEST_START;				
591:              			//超温报警显示HOT
592:              			if(b_BotTempOut == 1)   
  15D0    1D71    SNZB	0x71,2
  15D1    2DDA    JP	0x5DA
593:              			{
594:              				if(b_LedCol)
  15D2    1EF0    SNZB	0x70,5
  15D3    2ECE    JP	0x6CE
595:              				{
596:              					DIG_DATA_3 |= DIG_H;		 
  15D4    3076    LDIA	0x76
  15D5    04A1    ORR	0x21
597:              					DIG_DATA_2 |= SEGM_C|SEGM_D|SEGM_E|SEGM_G;	 
  15D6    305C    LDIA	0x5C
  15D7    04A2    ORR	0x22
598:              					DIG_DATA_1 |= SEGM_D|SEGM_E|SEGM_F|SEGM_G;			
  15D8    3078    LDIA	0x78
  15D9    2E23    JP	0x623
599:              				}	    					    		
600:              			}
601:              			else
602:              			{
603:              				DIG_DATA_4 |= HOT_RUN_TAB[HorseCount][0];    
  15DA    0832    LD	A,0x32
  15DB    00DF    LD	0x5F,A
  15DC    3001    LDIA	0x1
  15DD    1003    CLRB	0x3,0
  15DE    0DDF    RLCR	0x5F
  15DF    3EFF    ADDIA	0xFF
  15E0    1003    CLRB	0x3,0
  15E1    1D03    SNZB	0x3,2
  15E2    2DDE    JP	0x5DE
  15E3    0D5F    RLCA	0x5F
  15E4    27B8    CALL	0x7B8
  15E5    160A    SETB	0xA,4
  15E6    158A    SETB	0xA,3
  15E7    2000    CALL	0x0
  15EA    04A0    ORR	0x20
604:              				DIG_DATA_3 |= HOT_RUN_TAB[HorseCount][1];
  15EB    0832    LD	A,0x32
  15EC    00DF    LD	0x5F,A
  15ED    3001    LDIA	0x1
  15EE    1003    CLRB	0x3,0
  15EF    0DDF    RLCR	0x5F
  15F0    3EFF    ADDIA	0xFF
  15F1    1003    CLRB	0x3,0
  15F2    1D03    SNZB	0x3,2
  15F3    2DEF    JP	0x5EF
  15F4    0D5F    RLCA	0x5F
  15F5    3E01    ADDIA	0x1
  15F6    27B8    CALL	0x7B8
  15F7    160A    SETB	0xA,4
  15F8    158A    SETB	0xA,3
  15F9    2000    CALL	0x0
  15FC    04A1    ORR	0x21
605:              				DIG_DATA_2 |= HOT_RUN_TAB[HorseCount][2];
  15FD    0832    LD	A,0x32
  15FE    00DF    LD	0x5F,A
  15FF    3001    LDIA	0x1
  1600    1003    CLRB	0x3,0
  1601    0DDF    RLCR	0x5F
  1602    3EFF    ADDIA	0xFF
  1603    1003    CLRB	0x3,0
  1604    1D03    SNZB	0x3,2
  1605    2E01    JP	0x601
  1606    0D5F    RLCA	0x5F
  1607    3E02    ADDIA	0x2
  1608    27B8    CALL	0x7B8
  1609    160A    SETB	0xA,4
  160A    158A    SETB	0xA,3
  160B    2000    CALL	0x0
606:              				DIG_DATA_1 |= HOT_RUN_TAB[HorseCount][3];				
  160E    27F4    CALL	0x7F4
  160F    160A    SETB	0xA,4
  1610    118A    CLRB	0xA,3
  1611    0DDF    RLCR	0x5F
  1612    3EFF    ADDIA	0xFF
  1613    1003    CLRB	0x3,0
  1614    1D03    SNZB	0x3,2
  1615    2E11    JP	0x611
  1616    0D5F    RLCA	0x5F
  1617    3E03    ADDIA	0x3
  1618    3E44    ADDIA	0x44
  1619    0084    LD	0x4,A
  161A    3099    LDIA	0x99
  161B    1803    SZB	0x3,0
  161C    3E01    ADDIA	0x1
  161D    00FF    LD	0x7F,A
  161E    160A    SETB	0xA,4
  161F    158A    SETB	0xA,3
  1620    2000    CALL	0x0
  1623    04A3    ORR	0x23
  1624    2ECE    JP	0x6CE
607:              			}		    				    	
608:              			break;
609:              		case FACTORY_TEST_STEP18: FACTORY_TEST_LED18;
610:              			break;
611:              
612:              		case FACTORY_TEST_STEP17: FACTORY_TEST_LED17;
613:              			break;
614:              		
615:              		case FACTORY_TEST_STEP16: FACTORY_TEST_LED16;
  1625    2E28    JP	0x628
616:              			break;
  1626    17A4    SETB	0x24,7
  1627    14A6    SETB	0x26,1
  1628    14A5    SETB	0x25,1
617:              			
618:              		case FACTORY_TEST_STEP15: FACTORY_TEST_LED15;
619:              			break;
  1629    2ECE    JP	0x6CE
620:              
621:              		case FACTORY_TEST_STEP14: FACTORY_TEST_LED14;
  162A    17A5    SETB	0x25,7
  162B    1626    SETB	0x26,4
  162C    17A6    SETB	0x26,7
622:              			break;
  162D    2ECE    JP	0x6CE
623:              
624:              		case FACTORY_TEST_STEP13: FACTORY_TEST_LED13;
  162E    14A4    SETB	0x24,1
  162F    15A6    SETB	0x26,3
  1630    1526    SETB	0x26,2
625:              			break;
  1631    2ECE    JP	0x6CE
626:              		
627:              		case FACTORY_TEST_STEP12: FACTORY_TEST_LED12; 
  1632    1624    SETB	0x24,4
628:              			break;
  1633    2ECE    JP	0x6CE
629:              
630:              		case FACTORY_TEST_STEP11: FACTORY_TEST_LED11;
  1634    1524    SETB	0x24,2
631:              			break;
  1635    2ECE    JP	0x6CE
632:              	
633:              		case FACTORY_TEST_STEP10: FACTORY_TEST_LED10;
  1636    16A4    SETB	0x24,5
634:              			break;
  1637    2ECE    JP	0x6CE
635:              
636:              		case FACTORY_TEST_STEP9: FACTORY_TEST_LED9;
  1638    15A4    SETB	0x24,3
637:              			break;
  1639    2ECE    JP	0x6CE
638:              	
639:              		case FACTORY_TEST_STEP8: FACTORY_TEST_LED8;
  163A    1625    SETB	0x25,4
640:              			break;
  163B    2ECE    JP	0x6CE
641:              		
642:              		case FACTORY_TEST_STEP7: FACTORY_TEST_LED7;
  163C    1525    SETB	0x25,2
643:              			break;
  163D    2ECE    JP	0x6CE
644:              	
645:              		case FACTORY_TEST_STEP6: FACTORY_TEST_LED6;	
  163E    16A5    SETB	0x25,5
646:              			break;	
  163F    2ECE    JP	0x6CE
647:              		
648:              		case FACTORY_TEST_STEP5: FACTORY_TEST_LED5;	
  1640    15A5    SETB	0x25,3
649:              			break;	      
  1641    2ECE    JP	0x6CE
650:              		
651:              		case FACTORY_TEST_STEP4: FACTORY_TEST_LED4;
  1642    1724    SETB	0x24,6
652:              			break;
  1643    2ECE    JP	0x6CE
653:              			
654:              		case FACTORY_TEST_STEP3: FACTORY_TEST_LED3;
  1644    1425    SETB	0x25,0
655:              			break;
  1645    2ECE    JP	0x6CE
656:                						
657:              		case FACTORY_TEST_STEP2: FACTORY_TEST_LED2;
  1646    1725    SETB	0x25,6
658:              			break;					
  1647    2ECE    JP	0x6CE
659:              					
660:              		case FACTORY_TEST_STEP1: FACTORY_TEST_LED1;	
  1648    1424    SETB	0x24,0
661:              			break;		
  1649    2ECE    JP	0x6CE
662:              							
663:              		case FACTORY_TEST_STEP0:           //版本号
664:              			FACTORY_TEST_LED0;
  164A    1424    SETB	0x24,0
  164B    1725    SETB	0x25,6
  164C    1425    SETB	0x25,0
  164D    1724    SETB	0x24,6
  164E    15A5    SETB	0x25,3
  164F    16A5    SETB	0x25,5
  1650    1525    SETB	0x25,2
  1651    1625    SETB	0x25,4
  1652    15A4    SETB	0x24,3
  1653    16A4    SETB	0x24,5
  1654    1524    SETB	0x24,2
  1655    1624    SETB	0x24,4
  1656    14A4    SETB	0x24,1
  1657    15A6    SETB	0x26,3
  1658    1526    SETB	0x26,2
  1659    17A5    SETB	0x25,7
  165A    1626    SETB	0x26,4
  165B    17A6    SETB	0x26,7
  165C    17A4    SETB	0x24,7
  165D    14A6    SETB	0x26,1
  165E    14A5    SETB	0x25,1
  165F    14A5    SETB	0x25,1
  1660    14A5    SETB	0x25,1
665:              			if(FactoryTestData == FACTORY_TEST_STEP0)
  1661    0841    LD	A,0x41
  1662    1D03    SNZB	0x3,2
  1663    2ECE    JP	0x6CE
666:              			{
667:              				DIG_DATA_4 = SEG_MATH_TAB[PROGRAMMER_VERSION];				
  1664    3082    LDIA	0x82
  1665    0084    LD	0x4,A
  1666    3099    LDIA	0x99
  1667    00FF    LD	0x7F,A
  1668    160A    SETB	0xA,4
  1669    158A    SETB	0xA,3
  166A    2000    CALL	0x0
  166D    00A0    LD	0x20,A
668:              				DIG_DATA_3 = SEG_MATH_TAB[PROGRAMMER_NUM1];		 
  166E    3078    LDIA	0x78
  166F    0084    LD	0x4,A
  1670    3099    LDIA	0x99
  1671    00FF    LD	0x7F,A
  1672    160A    SETB	0xA,4
  1673    158A    SETB	0xA,3
  1674    2000    CALL	0x0
  1677    00A1    LD	0x21,A
669:              				DIG_DATA_2 = SEG_MATH_TAB[PROGRAMMER_NUM2];	 
  1678    3078    LDIA	0x78
  1679    0084    LD	0x4,A
  167A    3099    LDIA	0x99
  167B    00FF    LD	0x7F,A
  167C    160A    SETB	0xA,4
  167D    158A    SETB	0xA,3
  167E    2000    CALL	0x0
  1681    00A2    LD	0x22,A
670:              				DIG_DATA_1 = SEG_MATH_TAB[PROGRAMMER_NUM3];					
  1682    3080    LDIA	0x80
  1683    0084    LD	0x4,A
  1684    3099    LDIA	0x99
  1685    00FF    LD	0x7F,A
  1686    160A    SETB	0xA,4
  1687    158A    SETB	0xA,3
  1688    2000    CALL	0x0
  168B    00A3    LD	0x23,A
  168C    2ECE    JP	0x6CE
  168D    0841    LD	A,0x41
  168E    3A00    XORIA	0x0
  168F    1903    SZB	0x3,2
  1690    2E4A    JP	0x64A
  1691    3A01    XORIA	0x1
  1692    1903    SZB	0x3,2
  1693    2E48    JP	0x648
  1694    3A03    XORIA	0x3
  1695    1903    SZB	0x3,2
  1696    2E46    JP	0x646
  1697    3A01    XORIA	0x1
  1698    1903    SZB	0x3,2
  1699    2E44    JP	0x644
  169A    3A07    XORIA	0x7
  169B    1903    SZB	0x3,2
  169C    2E42    JP	0x642
  169D    3A01    XORIA	0x1
  169E    1903    SZB	0x3,2
  169F    2E40    JP	0x640
  16A0    3A03    XORIA	0x3
  16A1    1903    SZB	0x3,2
  16A2    2E3E    JP	0x63E
  16A3    3A01    XORIA	0x1
  16A4    1903    SZB	0x3,2
  16A5    2E3C    JP	0x63C
  16A6    3A0F    XORIA	0xF
  16A7    1903    SZB	0x3,2
  16A8    2E3A    JP	0x63A
  16A9    3A01    XORIA	0x1
  16AA    1903    SZB	0x3,2
  16AB    2E38    JP	0x638
  16AC    3A03    XORIA	0x3
  16AD    1903    SZB	0x3,2
  16AE    2E36    JP	0x636
  16AF    3A01    XORIA	0x1
  16B0    1903    SZB	0x3,2
  16B1    2E34    JP	0x634
  16B2    3A07    XORIA	0x7
  16B3    1903    SZB	0x3,2
  16B4    2E32    JP	0x632
  16B5    3A01    XORIA	0x1
  16B6    1903    SZB	0x3,2
  16B7    2E2E    JP	0x62E
  16B8    3A03    XORIA	0x3
  16B9    1903    SZB	0x3,2
  16BA    2E2A    JP	0x62A
  16BB    3A01    XORIA	0x1
  16BC    1903    SZB	0x3,2
  16BD    2E26    JP	0x626
  16BE    3A1F    XORIA	0x1F
  16BF    1903    SZB	0x3,2
  16C0    2E25    JP	0x625
  16C1    3A01    XORIA	0x1
  16C2    1903    SZB	0x3,2
  16C3    2ECE    JP	0x6CE
  16C4    3A03    XORIA	0x3
  16C5    1903    SZB	0x3,2
  16C6    2ECE    JP	0x6CE
  16C7    3A01    XORIA	0x1
  16C8    1903    SZB	0x3,2
  16C9    2D8C    JP	0x58C
  16CA    3A07    XORIA	0x7
  16CB    1903    SZB	0x3,2
  16CC    2D3D    JP	0x53D
  16CD    2ECE    JP	0x6CE
671:              			}
672:              								
673:              			break;			
674:              		default:  break;	
675:              	}
676:              	//数码管显示12：34
677:              	if(FactoryTestData >= FACTORY_TEST_STEP2 && FactoryTestData <= FACTORY_TEST_STEP15)
  16CE    3002    LDIA	0x2
  16CF    0241    SUBA	0x41
  16D0    1C03    SNZB	0x3,0
  16D1    0008    RET
  16D2    3010    LDIA	0x10
  16D3    0241    SUBA	0x41
  16D4    1803    SZB	0x3,0
  16D5    0008    RET
678:              	{
679:              		DIG_DATA_4 = SEG_MATH_TAB[1];				
  16D6    3079    LDIA	0x79
  16D7    0084    LD	0x4,A
  16D8    3099    LDIA	0x99
  16D9    00FF    LD	0x7F,A
  16DA    160A    SETB	0xA,4
  16DB    158A    SETB	0xA,3
  16DC    2000    CALL	0x0
  16DF    00A0    LD	0x20,A
680:              		DIG_DATA_3 = SEG_MATH_TAB[2];		 
  16E0    307A    LDIA	0x7A
  16E1    0084    LD	0x4,A
  16E2    3099    LDIA	0x99
  16E3    00FF    LD	0x7F,A
  16E4    160A    SETB	0xA,4
  16E5    158A    SETB	0xA,3
  16E6    2000    CALL	0x0
  16E9    00A1    LD	0x21,A
681:              		DIG_DATA_2 = SEG_MATH_TAB[3];	 
  16EA    307B    LDIA	0x7B
  16EB    0084    LD	0x4,A
  16EC    3099    LDIA	0x99
  16ED    00FF    LD	0x7F,A
  16EE    160A    SETB	0xA,4
  16EF    158A    SETB	0xA,3
  16F0    2000    CALL	0x0
  16F3    00A2    LD	0x22,A
682:              		DIG_DATA_1 = SEG_MATH_TAB[4];
  16F4    307C    LDIA	0x7C
  16F5    0084    LD	0x4,A
  16F6    3099    LDIA	0x99
  16F7    00FF    LD	0x7F,A
  16F8    160A    SETB	0xA,4
  16F9    158A    SETB	0xA,3
  16FA    2000    CALL	0x0
  16FB    00A3    LD	0x23,A
683:              		SEGM_TWO_POINT;			
  16FC    17A2    SETB	0x22,7
  16FD    17A1    SETB	0x21,7
  16FE    0008    RET
684:              	}	
685:              }								
686:              
687:              
688:              /***********************************************************
689:              设置显示数据函数 主函数8ms调用
690:              ***********************************************************/
691:              void LED_Task(void)
692:              {	
693:              	//复位所有LED
694:              	LED_Off();
  0183    2260    CALL	0x260
  0184    120A    CLRB	0xA,4
  0185    118A    CLRB	0xA,3
695:              
696:              	//跑马圈计数 160ms=8ms*20
697:              	if(++HorseShowTime160ms >= 20)	
  0186    3014    LDIA	0x14
  0187    1683    SETB	0x3,5
  0188    0ACC    INCR	0x4C
  0189    024C    SUBA	0x4C
  018A    1C03    SNZB	0x3,0
  018B    2995    JP	0x195
698:              	{
699:              		HorseShowTime160ms = 0;
  018C    01CC    CLR	0x4C
700:              		if(++HorseCount >= 13)
  018D    300D    LDIA	0xD
  018E    1283    CLRB	0x3,5
  018F    0AB2    INCR	0x32
  0190    0232    SUBA	0x32
  0191    1C03    SNZB	0x3,0
  0192    2995    JP	0x195
701:              		{
702:              			HorseCount = 1;			
  0193    3001    LDIA	0x1
  0194    00B2    LD	0x32,A
703:              		}
704:              	}
705:              	
706:                  //上电显示
707:              	if(SysStatus == POWERON_MODE)         
  0195    3006    LDIA	0x6
  0196    1283    CLRB	0x3,5
  0197    066A    XORA	0x6A
  0198    1D03    SNZB	0x3,2
  0199    299E    JP	0x19E
708:              	{
709:              		Power_On_Show();	
  019A    226C    CALL	0x26C
  019B    120A    CLRB	0xA,4
  019C    118A    CLRB	0xA,3
710:              	}
  019D    29E1    JP	0x1E1
711:              	else if(SysStatus == WAITING_MODE)    //待机
  019E    0B6A    SZDECA	0x6A
  019F    29AC    JP	0x1AC
712:              	{
713:              		if(b_Standby)     //省电模式显示
  01A0    1F72    SNZB	0x72,6
  01A1    29A8    JP	0x1A8
714:              		{
715:              			if(b_LedCol)
  01A2    1EF0    SNZB	0x70,5
  01A3    29E1    JP	0x1E1
716:              			{
717:              	    			//--:--闪烁			
718:              				DIG_DATA_4 |= SEGM_G;
719:              				DIG_DATA_3 |= SEGM_G;
720:              				DIG_DATA_2 |= SEGM_G;
721:              				DIG_DATA_1 |= SEGM_G;	
722:              				SEGM_TWO_POINT;	
  01A4    227A    CALL	0x27A
  01A5    120A    CLRB	0xA,4
  01A6    118A    CLRB	0xA,3
  01A7    29E1    JP	0x1E1
723:              			}
724:              		}
725:              		else
726:              		{
727:              			Waiting_Mode_Show();
  01A8    2278    CALL	0x278
  01A9    120A    CLRB	0xA,4
  01AA    118A    CLRB	0xA,3
728:              		}	
729:              
730:              	}
  01AB    29E1    JP	0x1E1
731:              	else if(SysStatus == CHOOSE_FUN_MODE)                              //选择功能
  01AC    3002    LDIA	0x2
  01AD    066A    XORA	0x6A
  01AE    1D03    SNZB	0x3,2
  01AF    29B6    JP	0x1B6
732:              	{
733:              		Fun_Choose_Show();
  01B0    160A    SETB	0xA,4
  01B1    118A    CLRB	0xA,3
  01B2    20D9    CALL	0xD9
734:              	}
  01B5    29E1    JP	0x1E1
735:              	else if(SysStatus == WORK_MODE && ErrorCode == NO_ERROR)           //工作
  01B6    3003    LDIA	0x3
  01B7    066A    XORA	0x6A
  01B8    1D03    SNZB	0x3,2
  01B9    29C3    JP	0x1C3
  01BA    0858    LD	A,0x58
  01BB    1D03    SNZB	0x3,2
  01BC    29C3    JP	0x1C3
736:              	{
737:              		Work_Mode_Show();
  01BD    160A    SETB	0xA,4
  01BE    118A    CLRB	0xA,3
  01BF    23F9    CALL	0x3F9
738:              	}
  01C2    29E1    JP	0x1E1
739:              	else if(SysStatus == KEEP_WARM_MODE && ErrorCode == NO_ERROR)      //保温
  01C3    3004    LDIA	0x4
  01C4    066A    XORA	0x6A
  01C5    1D03    SNZB	0x3,2
  01C6    29CE    JP	0x1CE
  01C7    0858    LD	A,0x58
  01C8    1D03    SNZB	0x3,2
  01C9    29CE    JP	0x1CE
740:              	{
741:              		Keepwarm_Show();
  01CA    2204    CALL	0x204
  01CB    120A    CLRB	0xA,4
  01CC    118A    CLRB	0xA,3
742:              	}
  01CD    29E1    JP	0x1E1
743:              	else if(SysStatus == FACTORY_TEST_MODE && ErrorCode == NO_ERROR)   //工厂
  01CE    3005    LDIA	0x5
  01CF    066A    XORA	0x6A
  01D0    1D03    SNZB	0x3,2
  01D1    29DB    JP	0x1DB
  01D2    0858    LD	A,0x58
  01D3    1D03    SNZB	0x3,2
  01D4    29DB    JP	0x1DB
744:              	{
745:              		Factory_Show();
  01D5    160A    SETB	0xA,4
  01D6    118A    CLRB	0xA,3
  01D7    253C    CALL	0x53C
746:              	}
  01DA    29E1    JP	0x1E1
747:              	else if(ErrorCode != NO_ERROR)                                     //报警
  01DB    0858    LD	A,0x58
  01DC    1903    SZB	0x3,2
  01DD    29E1    JP	0x1E1
748:              	{
749:              		Error_Show();
  01DE    21E6    CALL	0x1E6
  01DF    120A    CLRB	0xA,4
  01E0    118A    CLRB	0xA,3
750:              	}
751:              	
752:              	//参数查看, 优先级最高
753:              	if(b_TestShow)
  01E1    1DF0    SNZB	0x70,3
  01E2    0008    RET
754:              	{
755:              		Test_Mode_Show();    
  01E3    160A    SETB	0xA,4
  01E4    118A    CLRB	0xA,3
  01E5    298D    JP	0x18D
756:              	}	
757:              }
758:              
759:              
760:              
761:              /**********************************************************
762:              函数名称：Set_Addr_Value
763:              函数功能：更新LED模块内部某个显示LEDDATA的数据
764:              入口参数：Addr - 需要更新的地址
765:              		  Mask - 数据掩码
766:              出口参数：
767:              备    注：
768:              **********************************************************/
769:              void Set_Addr_Value(unsigned char addr, unsigned char mask)
  0524    00DB    LD	0x5B,A
770:              {
771:              	unsigned char data = 0;
  0525    01DC    CLR	0x5C
772:              	
773:              	#ifdef MODE_COM_8
774:              	LEDADD = addr;
775:              	#endif
776:              
777:              	#ifdef MODE_COM_16
778:              	LEDADD = addr | 0x10;
  0526    3810    ORIA	0x10
  0527    1683    SETB	0x3,5
  0528    1703    SETB	0x3,6
  0529    0092    LD	0x12,A
779:              	#endif
780:              		
781:              	if(DispData[0] & mask)
  052A    1283    CLRB	0x3,5
  052B    1303    CLRB	0x3,6
  052C    0820    LD	A,0x20
  052D    055A    ANDA	0x5A
  052E    1D03    SNZB	0x3,2
782:              		BSET(data, C_LED_COM0);
  052F    15DC    SETB	0x5C,3
783:              	#if COM_NUMBER >=2
784:              	if(DispData[1] & mask)
  0530    0821    LD	A,0x21
  0531    055A    ANDA	0x5A
  0532    1D03    SNZB	0x3,2
785:              		BSET(data, C_LED_COM1);
  0533    145C    SETB	0x5C,0
786:              	#endif
787:              	#if COM_NUMBER >=3
788:              	if(DispData[2] & mask)
  0534    0822    LD	A,0x22
  0535    055A    ANDA	0x5A
  0536    1D03    SNZB	0x3,2
789:              		BSET(data, C_LED_COM2);
  0537    14DC    SETB	0x5C,1
790:              	#endif
791:              	#if COM_NUMBER >=4
792:              	if(DispData[3] & mask)
  0538    0823    LD	A,0x23
  0539    055A    ANDA	0x5A
  053A    1D03    SNZB	0x3,2
793:              		BSET(data, C_LED_COM3);
  053B    155C    SETB	0x5C,2
794:              	#endif
795:              	#if COM_NUMBER >=5
796:              	if(DispData[4] & mask)
  053C    0824    LD	A,0x24
  053D    055A    ANDA	0x5A
  053E    1D03    SNZB	0x3,2
797:              		BSET(data, C_LED_COM4);
  053F    17DC    SETB	0x5C,7
798:              	#endif
799:              	#if COM_NUMBER >=6
800:              	if(DispData[5] & mask)
  0540    0825    LD	A,0x25
  0541    055A    ANDA	0x5A
  0542    1D03    SNZB	0x3,2
801:              		BSET(data, C_LED_COM5);
  0543    175C    SETB	0x5C,6
802:              	#endif
803:              	#if COM_NUMBER >=7
804:              	if(DispData[6] & mask)
  0544    0826    LD	A,0x26
  0545    055A    ANDA	0x5A
  0546    1D03    SNZB	0x3,2
805:              		BSET(data, C_LED_COM6);	
  0547    16DC    SETB	0x5C,5
806:              	#endif
807:              	#if COM_NUMBER >=8
808:              	if(DispData[7] & mask)
809:              		BSET(data, C_LED_COM7);	
810:              	#endif
811:              	LEDDATA = data;
  0548    085C    LD	A,0x5C
  0549    1683    SETB	0x3,5
  054A    1703    SETB	0x3,6
  054B    0093    LD	0x13,A
  054C    0008    RET
812:              }
813:              
814:              /***********************************************************
815:              初始化LED模块
816:              ***********************************************************/
817:              void Init_LED_Module(void)
818:              {
819:              	
820:              	LCDCON0 = 0B00000000;                  //COM0-COM7设为普通IO
  039F    1683    SETB	0x3,5
  03A0    1703    SETB	0x3,6
  03A1    0190    CLR	0x10
821:              	LCDCON1 = 0B11111111;                  //COM8-COM15设为COM
  03A2    30FF    LDIA	0xFF
  03A3    0091    LD	0x11,A
822:              	SEGEN0 = 0B11111111;                   //SEG0-SEG7设为SEG
  03A4    0096    LD	0x16,A
823:              	SEGEN1 = 0B00000000;                   //SEG8-SEG15设为普通IO
  03A5    0195    CLR	0x15
824:              	SEGEN2 = C_LED_SEGCUR;           //设置SEG驱动电流	
  03A6    3070    LDIA	0x70
  03A7    0094    LD	0x14,A
825:              	
826:              	LEDADD = 0X10;					//使用16COM
  03A8    3010    LDIA	0x10
  03A9    0092    LD	0x12,A
827:              	LCDCON = (0x40 | FRENQUENCY);    //使能LED,禁止LCD,设置频率
  03AA    3042    LDIA	0x42
  03AB    1283    CLRB	0x3,5
  03AC    0094    LD	0x14,A
  03AD    0008    RET
828:              
829:              }
830:              
831:              /***********************************************************
832:              LED模块驱动函数,循环点亮所有com口
833:              ***********************************************************/
834:              void LED_Drive(void)
835:              {
836:              	LED_COM_OUT;
  04E2    1683    SETB	0x3,5
  04E3    0188    CLR	0x8
837:              	LED_SEG_OUT;
  04E4    0185    CLR	0x5
838:              	//设置LED内部显示RAM的值
839:              	Set_Addr_Value(C_LED_SEGA|0X80, 0x01);//设置SEGA
  04E5    1283    CLRB	0x3,5
  04E6    3089    LDIA	0x89
  04E7    01DA    CLR	0x5A
  04E8    0ADA    INCR	0x5A
  04E9    2524    CALL	0x524
  04EA    120A    CLRB	0xA,4
  04EB    118A    CLRB	0xA,3
840:              	#if SEG_NUMBER >=2
841:              	Set_Addr_Value(C_LED_SEGB|0X80, 0x02);//设置SEGB
  04EC    3002    LDIA	0x2
  04ED    1283    CLRB	0x3,5
  04EE    1303    CLRB	0x3,6
  04EF    00DA    LD	0x5A,A
  04F0    3088    LDIA	0x88
  04F1    2524    CALL	0x524
  04F2    120A    CLRB	0xA,4
  04F3    118A    CLRB	0xA,3
842:              	#endif
843:              	#if SEG_NUMBER >=3
844:              	Set_Addr_Value(C_LED_SEGC|0X80, 0x04);//设置SEGC
  04F4    3004    LDIA	0x4
  04F5    1283    CLRB	0x3,5
  04F6    1303    CLRB	0x3,6
  04F7    00DA    LD	0x5A,A
  04F8    308E    LDIA	0x8E
  04F9    2524    CALL	0x524
  04FA    120A    CLRB	0xA,4
  04FB    118A    CLRB	0xA,3
845:              	#endif
846:              	#if SEG_NUMBER >=4
847:              	Set_Addr_Value(C_LED_SEGD|0X80, 0x08);//设置SEGD
  04FC    3008    LDIA	0x8
  04FD    1283    CLRB	0x3,5
  04FE    1303    CLRB	0x3,6
  04FF    00DA    LD	0x5A,A
  0500    308F    LDIA	0x8F
  0501    2524    CALL	0x524
  0502    120A    CLRB	0xA,4
  0503    118A    CLRB	0xA,3
848:              	#endif
849:              	#if SEG_NUMBER >=5
850:              	Set_Addr_Value(C_LED_SEGE|0X80, 0x10);//设置SEGE
  0504    3010    LDIA	0x10
  0505    1283    CLRB	0x3,5
  0506    1303    CLRB	0x3,6
  0507    00DA    LD	0x5A,A
  0508    308D    LDIA	0x8D
  0509    2524    CALL	0x524
  050A    120A    CLRB	0xA,4
  050B    118A    CLRB	0xA,3
851:              	#endif
852:              	#if SEG_NUMBER >=6
853:              	Set_Addr_Value(C_LED_SEGF|0X80, 0x20);//设置SEGF
  050C    3020    LDIA	0x20
  050D    1283    CLRB	0x3,5
  050E    1303    CLRB	0x3,6
  050F    00DA    LD	0x5A,A
  0510    308B    LDIA	0x8B
  0511    2524    CALL	0x524
  0512    120A    CLRB	0xA,4
  0513    118A    CLRB	0xA,3
854:              	#endif
855:              	#if SEG_NUMBER >=7
856:              	Set_Addr_Value(C_LED_SEGG|0X80, 0x40);//设置SEGG
  0514    3040    LDIA	0x40
  0515    1283    CLRB	0x3,5
  0516    1303    CLRB	0x3,6
  0517    00DA    LD	0x5A,A
  0518    308C    LDIA	0x8C
  0519    2524    CALL	0x524
  051A    120A    CLRB	0xA,4
  051B    118A    CLRB	0xA,3
857:              	#endif
858:              	#if SEG_NUMBER >=8
859:              	Set_Addr_Value(C_LED_SEGP|0X80, 0x80);//设置SEGP
  051C    3080    LDIA	0x80
  051D    1283    CLRB	0x3,5
  051E    1303    CLRB	0x3,6
  051F    00DA    LD	0x5A,A
  0520    308A    LDIA	0x8A
  0521    2524    CALL	0x524
860:              	#endif
861:              	#if SEG_NUMBER >=9
862:              	Set_Addr_Value(C_LED_SEGH|0X80, 0x100);//设置SEG9
863:              	#endif
864:              	#if SEG_NUMBER >=10
865:              	Set_Addr_Value(C_LED_SEGI|0X80, 0x200);//设置SEG10
866:              	#endif
867:              	#if SEG_NUMBER >=11
868:              	Set_Addr_Value(C_LED_SEGJ|0X80, 0x400);//设置SEG11
869:              	#endif
870:              	
871:              	LEDADD |= 0x40;					//SEG口输出LCDDATA的数据
  0522    1712    SETB	0x12,6
  0523    0008    RET
872:              }
873:              
874:              
875:              
876:              
877:              
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\key.c ----------------------------------------------------------------------
1:                #include "key.h"
2:                
3:                //保压时间表
4:                const uint8 TIME_TAB[15][4] = 
5:                {
6:                	//保压时间
7:                	//最小时间/标准时间/最大时间/压力档位//
8:                	{	 0,	    0,	  	0,	   0},//补位
9:                	{	16,	   	18,	  	20,	   0},//FUN_RICE		//米饭
10:               	{	15,		17,		21,	   0},//FUN_MIXRICE		//杂粮饭
11:               	{	5,	   	10,	  	15,	   0},//FUN_PORRIDGE	//稀饭
12:               	{	10,   	15,	  	20,	   0},//FUN_CONGEE		//煮粥
13:               	{	20,	   	28,	  	35,	   0},//FUN_SOUP	  	//煲汤	
14:               	{   15,     20,    	25,    0},//FUN_COOKMEAT	//炖肉	
15:               	{	12,		15,	  	20,	   0},//FUN_RIB			//排骨
16:               	{   15,	   	20,	  	30,	   0},//FUN_CHICKEN		//鸡鸭肉
17:               	{   18,    	25,    	30,    0},//FUN_EIGHTCONGEE	//八宝粥
18:               	{	20,	   	25,	  	35,	   0},//FUN_BEEF		//牛羊肉
19:               	{   30,    	35,    	45,    0},//FUN_BEAN		//豆蹄筋
20:               	{   40,     40,    	40,    0},//FUN_CAKE		//蛋糕
21:               	{    8,      8,    	 8,    0},//FUN_FASTHEAT	//冷食加热
22:               	{    8,      8,    	 8,    0},//FUN_OPENEHEAT	//开盖收汁 
23:               };
24:               
25:               
26:               /***********************************************************
27:               保温取消键响应
28:               ***********************************************************/
29:               void Maink_Cancel(void)
30:               {
31:               	//待机进保温
32:               	if(SysStatus == WAITING_MODE)
  0D5C    0B6A    SZDECA	0x6A
  0D5D    2D66    JP	0x566
33:               	{
34:               		SysStatus = KEEP_WARM_MODE;
  0D5E    3004    LDIA	0x4
  0D5F    00EA    LD	0x6A,A
35:               		ChooseFunSave = 0;
  0D60    01FB    CLR	0x7B
36:               		KEY_LONG_SOUND;		
  0D61    3001    LDIA	0x1
  0D62    1283    CLRB	0x3,5
  0D63    00D7    LD	0x57,A
  0D64    3025    LDIA	0x25
37:               	}
  0D65    2F88    JP	0x788
38:               	//取消
39:               	else if(SysStatus == CHOOSE_FUN_MODE || SysStatus == WORK_MODE || SysStatus == KEEP_WARM_MODE)
  0D66    3002    LDIA	0x2
  0D67    066A    XORA	0x6A
  0D68    1903    SZB	0x3,2
  0D69    2D72    JP	0x572
  0D6A    3003    LDIA	0x3
  0D6B    066A    XORA	0x6A
  0D6C    1903    SZB	0x3,2
  0D6D    2D72    JP	0x572
  0D6E    3004    LDIA	0x4
  0D6F    066A    XORA	0x6A
  0D70    1D03    SNZB	0x3,2
  0D71    0008    RET
40:               	{
41:               		Cancel();
  0D72    2577    CALL	0x577
  0D73    120A    CLRB	0xA,4
  0D74    158A    SETB	0xA,3
42:               		b_AutoKeepWarm = 0;
  0D75    1270    CLRB	0x70,4
  0D76    2D61    JP	0x561
43:               		KEY_LONG_SOUND;
44:               	}
45:               	
46:               }
47:               
48:               /***********************************************************
49:               预约定时键
50:               ***********************************************************/
51:               // void MainK_PresetTimer()
52:               // {		
53:               // 	if(SysStatus == CHOOSE_FUN_MODE)
54:               // 	{		
55:               
56:               // 		if(ChooseFun == FUN_CAKE ||  ChooseFun == FUN_OPENEHEAT)
57:               // 		{
58:               // 			return;
59:               // 		}
60:               // 		KEY_SHORT_SOUND;
61:               // 		if(PresetState == TIMER_STATE)
62:               // 		{			
63:               // 			PresetState = PRESET_STATE;
64:               // 			b_LedCol = 1;
65:               // 			if(PresetTimeH == 0 && PresetTimeM == 0)	
66:               // 			{
67:               // 				PresetTimeH = 2;
68:               // 			}
69:               // 			return;
70:               // 		}
71:               
72:               // 		if(PresetState == PRESET_STATE)
73:               // 		{
74:               // 			if(PresetTimeH == 24 && PresetTimeM == 0)
75:               // 			{
76:               // 				PresetTimeH = 2;
77:               // 				PresetTimeM=0;
78:               // 				return;
79:               // 			}				
80:               // 			PresetTimeM += 30;
81:               // 			if(PresetTimeM>=60)
82:               // 			{
83:               // 				PresetTimeM = 0;
84:               // 				PresetTimeH ++;
85:               // 			}
86:               // 		}
87:               // 	}
88:               // }
89:               
90:               
91:               
92:               
93:               /***********************************************************
94:               预约键响应
95:               ***********************************************************/
96:               void MainK_Preset(void)
97:               {
98:               	if(SysStatus == CHOOSE_FUN_MODE)
  0D15    3002    LDIA	0x2
  0D16    1283    CLRB	0x3,5
  0D17    066A    XORA	0x6A
  0D18    1D03    SNZB	0x3,2
  0D19    0008    RET
99:               	{
100:              		if(ChooseFun == FUN_CAKE ||  ChooseFun == FUN_OPENEHEAT)
  0D1A    300C    LDIA	0xC
  0D1B    063C    XORA	0x3C
  0D1C    1903    SZB	0x3,2
  0D1D    0008    RET
  0D1E    300E    LDIA	0xE
  0D1F    063C    XORA	0x3C
  0D20    1903    SZB	0x3,2
  0D21    0008    RET
101:              		{
102:              			return;
  0D22    0B39    SZDECA	0x39
  0D23    2D36    JP	0x536
103:              		}
104:              		//定时状态下进入预约状态
105:              		if(PresetState == TIMER_STATE)
106:              		{	 					 
107:              			PresetState = PRESET_STATE;          //切换到预约调整
  0D24    3002    LDIA	0x2
  0D25    00B9    LD	0x39,A
108:              			
109:              			if(PresetTimeH == 0 && PresetTimeM == 0)	
  0D26    0836    LD	A,0x36
  0D27    1D03    SNZB	0x3,2
  0D28    2D2E    JP	0x52E
  0D29    0835    LD	A,0x35
  0D2A    1D03    SNZB	0x3,2
  0D2B    2D2E    JP	0x52E
110:              			{
111:              				PresetTimeH = 2;                 //第一次预约, 默认2小时开始
  0D2C    3002    LDIA	0x2
  0D2D    00B6    LD	0x36,A
112:              			}
113:              			
114:              			//闪烁时基重置
115:              			LedCol_500ms = 0;
  0D2E    1683    SETB	0x3,5
  0D2F    01CB    CLR	0x4B
116:              			b_LedCol = 1;
  0D30    16F0    SETB	0x70,5
117:              			
118:              			KEY_SHORT_SOUND;
  0D31    3001    LDIA	0x1
  0D32    1283    CLRB	0x3,5
  0D33    00D7    LD	0x57,A
  0D34    300C    LDIA	0xC
119:              		}
  0D35    2F88    JP	0x788
120:              		//预约状态下，调整时间
121:              		else if(PresetState == PRESET_STATE)
  0D36    3002    LDIA	0x2
  0D37    0639    XORA	0x39
  0D38    1D03    SNZB	0x3,2
  0D39    0008    RET
122:              		{
123:              			//短按			
124:              			if((KeyFlag & 0x04) == 0)
  0D3A    192D    SZB	0x2D,2
  0D3B    2D41    JP	0x541
125:              			{
126:              				KEY_SHORT_SOUND;				
  0D3C    3001    LDIA	0x1
  0D3D    2790    CALL	0x790
  0D3E    120A    CLRB	0xA,4
  0D3F    158A    SETB	0xA,3
127:              				PresetTimeM += 30;
  0D48    301E    LDIA	0x1E
  0D49    1283    CLRB	0x3,5
  0D4A    07B5    ADDR	0x35
128:              				
129:              			}
  0D40    2D48    JP	0x548
130:              			else    //长按
131:              			{
132:              				if(++LongKeyCount >= 40)    //间隔增加时间:调用周期8ms*40=320ms
  0D41    3028    LDIA	0x28
  0D42    1683    SETB	0x3,5
  0D43    0ACA    INCR	0x4A
  0D44    024A    SUBA	0x4A
  0D45    1C03    SNZB	0x3,0
  0D46    0008    RET
133:              				{
134:              					LongKeyCount = 0;
  0D47    01CA    CLR	0x4A
135:              					PresetTimeM += 30;
136:              				}
137:              				else
138:              				{
139:              					return;
140:              				}
141:              			}			
142:              			if(PresetTimeM >= 60)
  0D4B    303C    LDIA	0x3C
  0D4C    0235    SUBA	0x35
  0D4D    1C03    SNZB	0x3,0
  0D4E    2D51    JP	0x551
143:              			{
144:              				PresetTimeM = 0;
  0D4F    01B5    CLR	0x35
145:              				PresetTimeH++;
  0D50    0AB6    INCR	0x36
146:              			}
147:              			
148:              			if(PresetTimeH >= 24 && PresetTimeM > 0)
  0D51    3018    LDIA	0x18
  0D52    0236    SUBA	0x36
  0D53    1C03    SNZB	0x3,0
  0D54    0008    RET
  0D55    0835    LD	A,0x35
  0D56    1903    SZB	0x3,2
  0D57    0008    RET
149:              			{
150:              				PresetTimeH = 2;
  0D58    3002    LDIA	0x2
  0D59    00B6    LD	0x36,A
151:              				PresetTimeM = 0;	
  0D5A    01B5    CLR	0x35
  0D5B    0008    RET
152:              			}
153:              		}		
154:              	}		
155:              }
156:              
157:              /***********************************************************
158:              快捷功能键响应
159:              ***********************************************************/
160:              void Maink_Fast_Fun(void)
161:              {
162:              	if(SysStatus == WAITING_MODE || SysStatus == CHOOSE_FUN_MODE)
  0E7C    1283    CLRB	0x3,5
  0E7D    036A    DECA	0x6A
  0E7E    1903    SZB	0x3,2
  0E7F    2E84    JP	0x684
  0E80    3002    LDIA	0x2
  0E81    066A    XORA	0x6A
  0E82    1D03    SNZB	0x3,2
  0E83    0008    RET
163:              	{ 
164:              		//切换功能时，预约时间不清零//其他无预约功能的需清零	(蛋糕、开盖收汁)
165:              		if(PresetState == NO_PRESET_STATE || ChooseFun == FUN_CAKE ||  ChooseFun == FUN_OPENEHEAT)  		
  0E84    0839    LD	A,0x39
  0E85    1903    SZB	0x3,2
  0E86    2E8F    JP	0x68F
  0E87    300C    LDIA	0xC
  0E88    063C    XORA	0x3C
  0E89    1903    SZB	0x3,2
  0E8A    2E8F    JP	0x68F
  0E8B    300E    LDIA	0xE
  0E8C    063C    XORA	0x3C
  0E8D    1D03    SNZB	0x3,2
  0E8E    2E91    JP	0x691
166:              		{
167:              			//第一次选功能清除预约时间
168:              			PresetTimeM = 0;
  0E8F    01B5    CLR	0x35
169:              			PresetTimeH = 0;
  0E90    01B6    CLR	0x36
170:              		}
171:              		SysStatus = CHOOSE_FUN_MODE;
  0E91    3002    LDIA	0x2
  0E92    00EA    LD	0x6A,A
172:              		//TasteCase = STANDARD_TASTE_CASE;                        //快捷功能不显示口感
173:              		PresetState = TIMER_STATE;                        //选择功能直接显示保压时间		
  0E93    3001    LDIA	0x1
  0E94    00B9    LD	0x39,A
174:              		CountDownTime = TIME_TAB[ChooseFun][1];  //保压时间				
  0E95    083C    LD	A,0x3C
  0E96    00DA    LD	0x5A,A
  0E97    3001    LDIA	0x1
  0E98    1003    CLRB	0x3,0
  0E99    0DDA    RLCR	0x5A
  0E9A    3EFF    ADDIA	0xFF
  0E9B    1003    CLRB	0x3,0
  0E9C    1D03    SNZB	0x3,2
  0E9D    2E99    JP	0x699
  0E9E    0D5A    RLCA	0x5A
  0E9F    3E01    ADDIA	0x1
  0EA0    3E08    ADDIA	0x8
  0EA1    0084    LD	0x4,A
  0EA2    3099    LDIA	0x99
  0EA3    1803    SZB	0x3,0
  0EA4    3E01    ADDIA	0x1
  0EA5    00FF    LD	0x7F,A
  0EA6    160A    SETB	0xA,4
  0EA7    158A    SETB	0xA,3
  0EA8    2000    CALL	0x0
  0EAB    00C0    LD	0x40,A
175:              		//时基清零
176:              		b_LedCol = 1;
  0EAC    16F0    SETB	0x70,5
177:              		LedCol_500ms = 0;		
  0EAD    1683    SETB	0x3,5
  0EAE    01CB    CLR	0x4B
178:              		MainTime_500ms = 0;	
  0EAF    01C9    CLR	0x49
179:              		Led_Step_100C = FALSE;
  0EB0    01CD    CLR	0x4D
180:              		KEY_SHORT_SOUND;
  0EB1    3001    LDIA	0x1
  0EB2    1283    CLRB	0x3,5
  0EB3    00D7    LD	0x57,A
  0EB4    300C    LDIA	0xC
  0EB5    2F88    JP	0x788
181:              	}	
182:              }
183:              
184:              /***********************************************************
185:              参数查看键响应
186:              ***********************************************************/
187:              void Maink_Test(void)
188:              {
189:              	//退出参数查看模式
190:              	if(KeyData == KEY_CANCEL_KEEPWARM)
  0EB6    3010    LDIA	0x10
  0EB7    1283    CLRB	0x3,5
  0EB8    0628    XORA	0x28
  0EB9    0427    ORA	0x27
  0EBA    1D03    SNZB	0x3,2
  0EBB    2EC1    JP	0x6C1
191:              	{
192:              		b_TestShow = 0;
  0EBC    11F0    CLRB	0x70,3
193:              		KEY_LONG_SOUND;
  0EBD    3001    LDIA	0x1
  0EBE    00D7    LD	0x57,A
  0EBF    3025    LDIA	0x25
194:              		return;
  0EC0    2F88    JP	0x788
195:              	}
196:              	
197:              	//按预约键更换参数层
198:              	if(KeyData == KEY_PRESET_FUN)
  0EC1    3040    LDIA	0x40
  0EC2    0628    XORA	0x28
  0EC3    0427    ORA	0x27
  0EC4    1D03    SNZB	0x3,2
  0EC5    2ECF    JP	0x6CF
199:              	{
200:              		KEY_SHORT_SOUND;
  0EC6    3001    LDIA	0x1
  0EC7    2790    CALL	0x790
201:              		if(++TestShow >= (TEST_SHOW_NUM + 1))
  0EC8    3003    LDIA	0x3
  0EC9    0AB1    INCR	0x31
  0ECA    0231    SUBA	0x31
  0ECB    1803    SZB	0x3,0
202:              		{
203:              			TestShow = 0;			
  0ECC    01B1    CLR	0x31
204:              		}
205:              		SendShow = 0;		
  0ECD    01B0    CLR	0x30
  0ECE    0008    RET
206:              		return;
207:              	}
208:              	
209:              	//按冷食加热键更换参数页
210:              	if(KeyData == KEY_FASTHEAT_FUN)
  0ECF    3080    LDIA	0x80
  0ED0    0628    XORA	0x28
  0ED1    0427    ORA	0x27
  0ED2    1D03    SNZB	0x3,2
  0ED3    0008    RET
211:              	{
212:              		KEY_SHORT_SOUND;
  0ED4    3001    LDIA	0x1
  0ED5    2790    CALL	0x790
  0ED6    120A    CLRB	0xA,4
  0ED7    158A    SETB	0xA,3
213:              		if(TestShow == 0)
  0ED8    0831    LD	A,0x31
  0ED9    1D03    SNZB	0x3,2
  0EDA    2EE3    JP	0x6E3
214:              		{
215:              			if(++SendShow > SEND_SHOW_NUM_1)
  0EDB    3009    LDIA	0x9
  0EDC    0AB0    INCR	0x30
  0EDD    0230    SUBA	0x30
  0EDE    1C03    SNZB	0x3,0
  0EDF    0008    RET
216:              			{
217:              				SendShow = 1;	
  0EE0    3001    LDIA	0x1
  0EE1    00B0    LD	0x30,A
  0EE2    0008    RET
218:              			}			
219:              		}
220:              		else if(TestShow == 1)
  0EE3    0B31    SZDECA	0x31
  0EE4    0008    RET
221:              		{
222:              			if(++SendShow >= SEND_SHOW_NUM_2)
  0EE5    3003    LDIA	0x3
  0EE6    0AB0    INCR	0x30
  0EE7    0230    SUBA	0x30
  0EE8    1C03    SNZB	0x3,0
  0EE9    0008    RET
  0EEA    2ECD    JP	0x6CD
223:              			{
224:              				SendShow = 0;		
225:              			}	
226:              		}		
227:              		return;
228:              	}	
229:              }
230:              /***********************************************************
231:              工厂测试键响应
232:              ***********************************************************/
233:              void Maink_Factory(void)
234:              {
235:              	//测试模式按下取消键
236:              	if(KeyData == FACTORY_TEST_KEY_CANCEL && FactoryTestData != (KEY_CANCEL_NUM-1))
  0D9B    3010    LDIA	0x10
  0D9C    0628    XORA	0x28
  0D9D    0427    ORA	0x27
  0D9E    1D03    SNZB	0x3,2
  0D9F    2E12    JP	0x612
  0DA0    300D    LDIA	0xD
  0DA1    0641    XORA	0x41
  0DA2    1903    SZB	0x3,2
  0DA3    2E12    JP	0x612
237:              	{
238:              		Cancel();
  0DA4    2577    CALL	0x577
  0DA5    120A    CLRB	0xA,4
  0DA6    158A    SETB	0xA,3
239:              		b_JudgeLidOk = 0;
  0DA7    1170    CLRB	0x70,2
240:              		JudgeLidCnt = 0;
  0DA8    01C8    CLR	0x48
241:              		JudgeLidMin = 0;
  0DA9    1283    CLRB	0x3,5
  0DAA    01AF    CLR	0x2F
242:              		KEY_LONG_SOUND;	
  0DAB    3001    LDIA	0x1
  0DAC    00D7    LD	0x57,A
  0DAD    3025    LDIA	0x25
  0DAE    2F88    JP	0x788
243:              		return;		
244:              	}
245:              
246:              	//依次按键检测
247:              	switch(KeyData)
248:              	{
249:              		case FACTORY_TEST_KEY1:							
250:              			if(FactoryTestData == FACTORY_TEST_STEP0)
  0DAF    0841    LD	A,0x41
  0DB0    1D03    SNZB	0x3,2
  0DB1    2E71    JP	0x671
251:              			{
252:              				FactoryTestData = FACTORY_TEST_STEP1; 
  0DB2    3001    LDIA	0x1
  0DB3    00C1    LD	0x41,A
  0DB4    2E0E    JP	0x60E
253:              				KEY_SHORT_SOUND; 	
254:              			}	 
255:              			break;
256:              		#if SW_TOTAL_NUM >= 2	
257:              		case FACTORY_TEST_KEY2:				
258:              			if(FactoryTestData == FACTORY_TEST_STEP1)
  0DB5    0B41    SZDECA	0x41
  0DB6    2E71    JP	0x671
259:              			{
260:              				FactoryTestData = FACTORY_TEST_STEP2; 
  0DB7    3002    LDIA	0x2
  0DB8    2E0C    JP	0x60C
261:              				KEY_SHORT_SOUND; 	
262:              			}	 
263:              			break;	
264:              		#endif
265:              		#if SW_TOTAL_NUM >= 3							
266:              		case FACTORY_TEST_KEY3:				
267:              			if(FactoryTestData == FACTORY_TEST_STEP2)
  0DB9    3002    LDIA	0x2
  0DBA    0641    XORA	0x41
  0DBB    1D03    SNZB	0x3,2
  0DBC    2E71    JP	0x671
268:              			{
269:              				FactoryTestData = FACTORY_TEST_STEP3; 
  0DBD    3003    LDIA	0x3
  0DBE    2E0C    JP	0x60C
270:              				KEY_SHORT_SOUND; 	
271:              			}	 
272:              			break;	
273:              		#endif
274:              		#if SW_TOTAL_NUM >= 4							
275:              		case FACTORY_TEST_KEY4:				
276:              			if(FactoryTestData == FACTORY_TEST_STEP3)
  0DBF    3003    LDIA	0x3
  0DC0    0641    XORA	0x41
  0DC1    1D03    SNZB	0x3,2
  0DC2    2E71    JP	0x671
277:              			{
278:              				FactoryTestData = FACTORY_TEST_STEP4; 
  0DC3    3004    LDIA	0x4
  0DC4    2E0C    JP	0x60C
279:              				KEY_SHORT_SOUND; 	
280:              			}	 
281:              			break;	
282:              		#endif
283:              		#if SW_TOTAL_NUM >= 5							
284:              		case FACTORY_TEST_KEY5:				
285:              			if(FactoryTestData == FACTORY_TEST_STEP4)
  0DC5    3004    LDIA	0x4
  0DC6    0641    XORA	0x41
  0DC7    1D03    SNZB	0x3,2
  0DC8    2E71    JP	0x671
286:              			{
287:              				FactoryTestData = FACTORY_TEST_STEP5; 
  0DC9    3005    LDIA	0x5
  0DCA    2E0C    JP	0x60C
288:              				KEY_SHORT_SOUND; 	
289:              			}	 
290:              			break;	
291:              		#endif
292:              		#if SW_TOTAL_NUM >= 6									
293:              		case FACTORY_TEST_KEY6:				
294:              			if(FactoryTestData == FACTORY_TEST_STEP5)
  0DCB    3005    LDIA	0x5
  0DCC    0641    XORA	0x41
  0DCD    1D03    SNZB	0x3,2
  0DCE    2E71    JP	0x671
295:              			{
296:              				FactoryTestData = FACTORY_TEST_STEP6;
  0DCF    3006    LDIA	0x6
  0DD0    2E0C    JP	0x60C
297:              				KEY_SHORT_SOUND; 	
298:              			}	 
299:              			break;	
300:              		#endif
301:              		#if SW_TOTAL_NUM >= 7							    			
302:              		case FACTORY_TEST_KEY7:				
303:              			if(FactoryTestData == FACTORY_TEST_STEP6)
  0DD1    3006    LDIA	0x6
  0DD2    0641    XORA	0x41
  0DD3    1D03    SNZB	0x3,2
  0DD4    2E71    JP	0x671
304:              			{
305:              				FactoryTestData = FACTORY_TEST_STEP7; 
  0DD5    3007    LDIA	0x7
  0DD6    2E0C    JP	0x60C
306:              				KEY_SHORT_SOUND; 	
307:              			}	 
308:              			break;
309:              		#endif
310:              		#if SW_TOTAL_NUM >= 8									
311:              		case FACTORY_TEST_KEY8:				
312:              			if(FactoryTestData == FACTORY_TEST_STEP7)
  0DD7    3007    LDIA	0x7
  0DD8    0641    XORA	0x41
  0DD9    1D03    SNZB	0x3,2
  0DDA    2E71    JP	0x671
313:              			{
314:              				FactoryTestData = FACTORY_TEST_STEP8; 
  0DDB    3008    LDIA	0x8
  0DDC    2E0C    JP	0x60C
315:              				KEY_SHORT_SOUND; 	
316:              			}	 
317:              			break;
318:              		#endif
319:              		#if SW_TOTAL_NUM >= 9									
320:              		case FACTORY_TEST_KEY9:				
321:              			if(FactoryTestData == FACTORY_TEST_STEP8)
  0DDD    3008    LDIA	0x8
  0DDE    0641    XORA	0x41
  0DDF    1D03    SNZB	0x3,2
  0DE0    2E71    JP	0x671
322:              			{
323:              				FactoryTestData = FACTORY_TEST_STEP9; 
  0DE1    3009    LDIA	0x9
  0DE2    2E0C    JP	0x60C
324:              				KEY_SHORT_SOUND; 	
325:              			}	 
326:              			break;	
327:              		#endif
328:              		#if SW_TOTAL_NUM >= 10								
329:              		case FACTORY_TEST_KEY10:  		
330:              			if(FactoryTestData == FACTORY_TEST_STEP9)
  0DE3    3009    LDIA	0x9
  0DE4    0641    XORA	0x41
  0DE5    1D03    SNZB	0x3,2
  0DE6    2E71    JP	0x671
331:              			{
332:              				FactoryTestData = FACTORY_TEST_STEP10; 
  0DE7    300A    LDIA	0xA
  0DE8    2E0C    JP	0x60C
333:              				KEY_SHORT_SOUND; 	
334:              			}	 
335:              			break;	
336:              		#endif
337:              		#if SW_TOTAL_NUM >= 11				 
338:              		case FACTORY_TEST_KEY11:
339:              			if(FactoryTestData == FACTORY_TEST_STEP10)
  0DE9    300A    LDIA	0xA
  0DEA    0641    XORA	0x41
  0DEB    1D03    SNZB	0x3,2
  0DEC    2E71    JP	0x671
340:              			{
341:              				FactoryTestData = FACTORY_TEST_STEP11; 
  0DED    300B    LDIA	0xB
  0DEE    2E0C    JP	0x60C
342:              				KEY_SHORT_SOUND; 	
343:              			}					 
344:              			break;	
345:              		#endif
346:              		#if SW_TOTAL_NUM >= 12								
347:              		case FACTORY_TEST_KEY12:
348:              			if(FactoryTestData == FACTORY_TEST_STEP11)
  0DEF    300B    LDIA	0xB
  0DF0    0641    XORA	0x41
  0DF1    1D03    SNZB	0x3,2
  0DF2    2E71    JP	0x671
349:              			{
350:              				FactoryTestData = FACTORY_TEST_STEP12; 
  0DF3    300C    LDIA	0xC
  0DF4    2E0C    JP	0x60C
351:              				KEY_SHORT_SOUND; 	
352:              			}					 
353:              			break;	
354:              		#endif
355:              		#if SW_TOTAL_NUM >= 13				
356:              		case FACTORY_TEST_KEY13:			
357:              			if(FactoryTestData == FACTORY_TEST_STEP12)
  0DF5    300C    LDIA	0xC
  0DF6    0641    XORA	0x41
  0DF7    1D03    SNZB	0x3,2
  0DF8    2E71    JP	0x671
358:              			{
359:              				FactoryTestData = FACTORY_TEST_STEP13; 
  0DF9    300D    LDIA	0xD
  0DFA    2E0C    JP	0x60C
360:              				KEY_SHORT_SOUND;
361:              			}						    	
362:              			break;	
363:              		#endif
364:              		#if SW_TOTAL_NUM >= 14
365:              		case FACTORY_TEST_KEY14:			
366:              			if(FactoryTestData == FACTORY_TEST_STEP13)
  0DFB    300D    LDIA	0xD
  0DFC    0641    XORA	0x41
  0DFD    1D03    SNZB	0x3,2
  0DFE    2E71    JP	0x671
367:              			{
368:              				FactoryTestData = FACTORY_TEST_STEP14; 
  0DFF    300E    LDIA	0xE
  0E00    2E0C    JP	0x60C
369:              				KEY_SHORT_SOUND;
370:              			}						    	
371:              			break;
372:              		#endif
373:              		#if SW_TOTAL_NUM >= 15
374:              		case FACTORY_TEST_KEY15:			
375:              			if(FactoryTestData == FACTORY_TEST_STEP14)
  0E01    300E    LDIA	0xE
  0E02    0641    XORA	0x41
  0E03    1D03    SNZB	0x3,2
  0E04    2E71    JP	0x671
376:              			{
377:              				FactoryTestData = FACTORY_TEST_STEP15; 
  0E05    300F    LDIA	0xF
  0E06    2E0C    JP	0x60C
378:              				KEY_SHORT_SOUND;
379:              			}						    	
380:              			break;
381:              		#endif
382:              		#if SW_TOTAL_NUM >= 16
383:              		case FACTORY_TEST_KEY16:			
384:              			if(FactoryTestData == FACTORY_TEST_STEP15)
  0E07    300F    LDIA	0xF
  0E08    0641    XORA	0x41
385:              			{
386:              				FactoryTestData = FACTORY_TEST_STEP16; 
  0E09    3010    LDIA	0x10
  0E0A    1D03    SNZB	0x3,2
  0E0B    2E72    JP	0x672
  0E0C    00C1    LD	0x41,A
387:              				KEY_SHORT_SOUND;
  0E0D    3001    LDIA	0x1
  0E0E    2790    CALL	0x790
  0E0F    120A    CLRB	0xA,4
  0E10    158A    SETB	0xA,3
  0E11    2E71    JP	0x671
  0E12    0828    LD	A,0x28
  0E13    3A00    XORIA	0x0
  0E14    1903    SZB	0x3,2
  0E15    2E2F    JP	0x62F
  0E16    3A01    XORIA	0x1
  0E17    1903    SZB	0x3,2
  0E18    2E49    JP	0x649
  0E19    3A03    XORIA	0x3
  0E1A    1903    SZB	0x3,2
  0E1B    2E4E    JP	0x64E
  0E1C    3A06    XORIA	0x6
  0E1D    1903    SZB	0x3,2
  0E1E    2E53    JP	0x653
  0E1F    3A0C    XORIA	0xC
  0E20    1903    SZB	0x3,2
  0E21    2E58    JP	0x658
  0E22    3A18    XORIA	0x18
  0E23    1903    SZB	0x3,2
  0E24    2E5D    JP	0x65D
  0E25    3A30    XORIA	0x30
  0E26    1903    SZB	0x3,2
  0E27    2E62    JP	0x662
  0E28    3A60    XORIA	0x60
  0E29    1903    SZB	0x3,2
  0E2A    2E67    JP	0x667
  0E2B    3AC0    XORIA	0xC0
  0E2C    1903    SZB	0x3,2
  0E2D    2E6C    JP	0x66C
  0E2E    2E71    JP	0x671
  0E2F    0827    LD	A,0x27
  0E30    3A01    XORIA	0x1
  0E31    1903    SZB	0x3,2
  0E32    2DB5    JP	0x5B5
  0E33    3A03    XORIA	0x3
  0E34    1903    SZB	0x3,2
  0E35    2DBF    JP	0x5BF
  0E36    3A06    XORIA	0x6
  0E37    1903    SZB	0x3,2
  0E38    2DB9    JP	0x5B9
  0E39    3A0C    XORIA	0xC
  0E3A    1903    SZB	0x3,2
  0E3B    2DAF    JP	0x5AF
  0E3C    3A18    XORIA	0x18
  0E3D    1903    SZB	0x3,2
  0E3E    2DCB    JP	0x5CB
  0E3F    3A30    XORIA	0x30
  0E40    1903    SZB	0x3,2
  0E41    2DD7    JP	0x5D7
  0E42    3A60    XORIA	0x60
  0E43    1903    SZB	0x3,2
  0E44    2DD1    JP	0x5D1
  0E45    3AC0    XORIA	0xC0
  0E46    1903    SZB	0x3,2
  0E47    2DC5    JP	0x5C5
  0E48    2E71    JP	0x671
  0E49    0827    LD	A,0x27
  0E4A    3A00    XORIA	0x0
  0E4B    1903    SZB	0x3,2
  0E4C    2DE3    JP	0x5E3
  0E4D    2E71    JP	0x671
  0E4E    0827    LD	A,0x27
  0E4F    3A00    XORIA	0x0
  0E50    1903    SZB	0x3,2
  0E51    2DEF    JP	0x5EF
  0E52    2E71    JP	0x671
  0E53    0827    LD	A,0x27
  0E54    3A00    XORIA	0x0
  0E55    1903    SZB	0x3,2
  0E56    2DE9    JP	0x5E9
  0E57    2E71    JP	0x671
  0E58    0827    LD	A,0x27
  0E59    3A00    XORIA	0x0
  0E5A    1903    SZB	0x3,2
  0E5B    2DDD    JP	0x5DD
  0E5C    2E71    JP	0x671
  0E5D    0827    LD	A,0x27
  0E5E    3A00    XORIA	0x0
  0E5F    1903    SZB	0x3,2
  0E60    2DFB    JP	0x5FB
  0E61    2E71    JP	0x671
  0E62    0827    LD	A,0x27
  0E63    3A00    XORIA	0x0
  0E64    1903    SZB	0x3,2
  0E65    2E07    JP	0x607
  0E66    2E71    JP	0x671
  0E67    0827    LD	A,0x27
  0E68    3A00    XORIA	0x0
  0E69    1903    SZB	0x3,2
  0E6A    2DF5    JP	0x5F5
  0E6B    2E71    JP	0x671
  0E6C    0827    LD	A,0x27
  0E6D    3A00    XORIA	0x0
  0E6E    1903    SZB	0x3,2
  0E6F    2E01    JP	0x601
  0E70    2E71    JP	0x671
388:              			}						    	
389:              			break;
390:              		#endif
391:              		#if SW_TOTAL_NUM >= 17
392:              		case FACTORY_TEST_KEY17:			
393:              			if(FactoryTestData == FACTORY_TEST_STEP16)
394:              			{
395:              				FactoryTestData = FACTORY_TEST_STEP17; 
396:              				KEY_SHORT_SOUND;
397:              			}						    	
398:              			break;
399:              		#endif
400:              		#if SW_TOTAL_NUM >= 18
401:              		case FACTORY_TEST_KEY18:			
402:              			if(FactoryTestData == FACTORY_TEST_STEP17)
403:              			{
404:              				FactoryTestData = FACTORY_TEST_STEP18; 
405:              				KEY_SHORT_SOUND;
406:              			}						    	
407:              			break;
408:              		#endif
409:              		#if SW_TOTAL_NUM >= 19
410:              		case FACTORY_TEST_KEY19:			
411:              			if(FactoryTestData == FACTORY_TEST_STEP18)
412:              			{
413:              				FactoryTestData = FACTORY_TEST_START; 
414:              				KEY_SHORT_SOUND;
415:              			}						    	
416:              			break;
417:              		#endif
418:              		default: break;
419:              	}
420:              	//开始加热
421:              	if(FactoryTestData == SW_TOTAL_NUM)
  0E71    3010    LDIA	0x10
  0E72    0641    XORA	0x41
  0E73    1D03    SNZB	0x3,2
  0E74    0008    RET
422:              	{
423:              		FactoryTestData = FACTORY_TEST_START; 
  0E75    3013    LDIA	0x13
  0E76    00C1    LD	0x41,A
424:              		WorkStep = 0;
  0E77    01C2    CLR	0x42
425:              		START_SOUND;		
  0E78    3003    LDIA	0x3
  0E79    00D7    LD	0x57,A
  0E7A    3019    LDIA	0x19
  0E7B    2DAE    JP	0x5AE
426:              	}		
427:              }
428:              
429:              /***********************************************************
430:              按键处理函数
431:              ***********************************************************/
432:              void Key_Task(void)
433:              {
434:              	//无按键
435:              	if(KeyFlag == 0x00)
  0C07    1283    CLRB	0x3,5
  0C08    082D    LD	A,0x2D
  0C09    1D03    SNZB	0x3,2
  0C0A    2C0E    JP	0x40E
436:              	{
437:              		LongKeyCount = 0;
  0C0B    1683    SETB	0x3,5
  0C0C    01CA    CLR	0x4A
438:              		return;	
  0C0D    0008    RET
439:              	}
440:              	
441:              	//长按模式
442:              	if(KeyFlag & 0x04)
  0C0E    1D2D    SNZB	0x2D,2
  0C0F    2C38    JP	0x438
443:              	{
444:              		//长按进入参数查看
445:              		if( b_TestShow == FALSE && KeyData == KEY_TSET)
  0C10    19F0    SZB	0x70,3
  0C11    2C1E    JP	0x41E
  0C12    30C0    LDIA	0xC0
  0C13    0628    XORA	0x28
  0C14    0427    ORA	0x27
  0C15    1D03    SNZB	0x3,2
  0C16    2C1E    JP	0x41E
446:              		{
447:              			b_TestShow = TRUE;
  0C17    15F0    SETB	0x70,3
448:              			TestShow = 0;
  0C18    01B1    CLR	0x31
449:              			SendShow = 0;			
  0C19    01B0    CLR	0x30
450:              			KEY_SHORT_SOUND;
  0C1A    3001    LDIA	0x1
  0C1B    00D7    LD	0x57,A
  0C1C    300C    LDIA	0xC
  0C1D    2F88    JP	0x788
451:              			return;	
452:              		}
453:              		//待机模式长按进入工厂模式
454:              		if((SysStatus == WAITING_MODE || SysStatus == CHOOSE_FUN_MODE) && KeyData == KEY_FACTORY)	
  0C1E    036A    DECA	0x6A
  0C1F    1903    SZB	0x3,2
  0C20    2C25    JP	0x425
  0C21    3002    LDIA	0x2
  0C22    066A    XORA	0x6A
  0C23    1D03    SNZB	0x3,2
  0C24    2C2E    JP	0x42E
  0C25    3050    LDIA	0x50
  0C26    0628    XORA	0x28
  0C27    0427    ORA	0x27
  0C28    1D03    SNZB	0x3,2
  0C29    2C2E    JP	0x42E
455:              		{
456:              			SysStatus = FACTORY_TEST_MODE;
  0C2A    3005    LDIA	0x5
  0C2B    00EA    LD	0x6A,A
457:              			FactoryTestData = 0;
  0C2C    01C1    CLR	0x41
  0C2D    2C1A    JP	0x41A
458:              			
459:              			KEY_SHORT_SOUND;
460:              			return;
461:              		}
462:              		//预约长按快速调整时间
463:              		if(SysStatus == CHOOSE_FUN_MODE && KeyData == KEY_PRESET_FUN)
  0C2E    3002    LDIA	0x2
  0C2F    066A    XORA	0x6A
  0C30    1D03    SNZB	0x3,2
  0C31    0008    RET
  0C32    3040    LDIA	0x40
  0C33    0628    XORA	0x28
  0C34    0427    ORA	0x27
  0C35    1D03    SNZB	0x3,2
  0C36    0008    RET
464:              		{
465:              			MainK_Preset(); 
  0C37    2D15    JP	0x515
466:              			return;	
467:              		}
468:              		
469:              		return;		 //返回,有长按下不响应短按			
470:              	}
471:              
472:              	//短按
473:              	if(KeyFlag & 0x01)
  0C38    1C2D    SNZB	0x2D,0
  0C39    0008    RET
474:              	{		
475:              		BCLR(KeyFlag,0);    //清除按键标志
  0C3A    102D    CLRB	0x2D,0
476:              		
477:              		StandbyTimeCnt = 0;    //有按键自动计时清零  
  0C3B    01D9    CLR	0x59
478:              		
479:              		//有按键，退出省电
480:              		if(b_Standby)
  0C3C    1F72    SNZB	0x72,6
  0C3D    2C43    JP	0x443
481:              		{
482:              			b_Standby = 0;
  0C3E    1372    CLRB	0x72,6
483:              			KEY_SHORT_SOUND;
  0C3F    3001    LDIA	0x1
  0C40    00D7    LD	0x57,A
  0C41    300C    LDIA	0xC
  0C42    2F88    JP	0x788
484:              			return;
485:              		}
486:              		
487:              		//参数查看模式下优先响应
488:              		if(b_TestShow)
  0C43    1DF0    SNZB	0x70,3
  0C44    2C8D    JP	0x48D
489:              		{
490:              			//厂家预留最后8个字节，我们只使用最后6个字节。
491:              							//Fc_ID_1;	//@0x1ff8;	// Fc_ID_2;          //防串码ID第1字节
492:              			 				//Fc_ID_2;	//@0x1ff9;	// Fc_ID_3;          //防串码ID第2字节
493:              			Fc_ID[0] = Fc_ID_3;	//@0x1ffa;	// Fc_ID_4;          //防串码ID第3字节
  0C45    30FA    LDIA	0xFA
  0C46    0084    LD	0x4,A
  0C47    309F    LDIA	0x9F
  0C48    00FF    LD	0x7F,A
  0C49    160A    SETB	0xA,4
  0C4A    158A    SETB	0xA,3
  0C4B    2000    CALL	0x0
  0C4E    1683    SETB	0x3,5
  0C4F    00A0    LD	0x20,A
494:              			Fc_ID[1] = Fc_ID_4;	//@0x1ffb;	// Fc_ID_5;          //防串码ID第4字节
  0C50    30FB    LDIA	0xFB
  0C51    0084    LD	0x4,A
  0C52    309F    LDIA	0x9F
  0C53    1283    CLRB	0x3,5
  0C54    00FF    LD	0x7F,A
  0C55    160A    SETB	0xA,4
  0C56    158A    SETB	0xA,3
  0C57    2000    CALL	0x0
  0C5A    1683    SETB	0x3,5
  0C5B    00A1    LD	0x21,A
495:              			Fc_ID[2] = Fc_ID_5;	//@0x1ffc;	// Fc_ID_6;          //防串码ID第4字节
  0C5C    30FC    LDIA	0xFC
  0C5D    0084    LD	0x4,A
  0C5E    309F    LDIA	0x9F
  0C5F    1283    CLRB	0x3,5
  0C60    00FF    LD	0x7F,A
  0C61    160A    SETB	0xA,4
  0C62    158A    SETB	0xA,3
  0C63    2000    CALL	0x0
  0C66    1683    SETB	0x3,5
  0C67    00A2    LD	0x22,A
496:              			Fc_ID[3] = Fc_ID_6;	//@0x1ffd;	// Fc_ID_7;          //防串码ID第6字节
  0C68    30FD    LDIA	0xFD
  0C69    0084    LD	0x4,A
  0C6A    309F    LDIA	0x9F
  0C6B    1283    CLRB	0x3,5
  0C6C    00FF    LD	0x7F,A
  0C6D    160A    SETB	0xA,4
  0C6E    158A    SETB	0xA,3
  0C6F    2000    CALL	0x0
  0C72    1683    SETB	0x3,5
  0C73    00A3    LD	0x23,A
497:              			Fc_ID[4] = Fc_ID_7;	//@0x1ffe;	// Fc_ID_8;          //防串码ID第4字节
  0C74    30FE    LDIA	0xFE
  0C75    0084    LD	0x4,A
  0C76    309F    LDIA	0x9F
  0C77    1283    CLRB	0x3,5
  0C78    00FF    LD	0x7F,A
  0C79    160A    SETB	0xA,4
  0C7A    158A    SETB	0xA,3
  0C7B    2000    CALL	0x0
  0C7E    1683    SETB	0x3,5
  0C7F    00A4    LD	0x24,A
498:              			Fc_ID[5] = Fc_ID_8;	//@0x1fff;	// Fc_ID_8;          //防串码ID第6字节
  0C80    30FF    LDIA	0xFF
  0C81    0084    LD	0x4,A
  0C82    309F    LDIA	0x9F
  0C83    1283    CLRB	0x3,5
  0C84    00FF    LD	0x7F,A
  0C85    160A    SETB	0xA,4
  0C86    158A    SETB	0xA,3
  0C87    2000    CALL	0x0
  0C8A    1683    SETB	0x3,5
  0C8B    00A5    LD	0x25,A
499:              			//Fc_ID[6] = 		
500:              			//Fc_ID[7] =
501:              
502:              			Maink_Test(); 
  0C8C    2EB6    JP	0x6B6
503:              			return;	
504:              		}
505:              		//工厂模式
506:              		if(SysStatus == FACTORY_TEST_MODE)
  0C8D    3005    LDIA	0x5
  0C8E    066A    XORA	0x6A
  0C8F    1D03    SNZB	0x3,2
  0C90    2C92    JP	0x492
507:              		{
508:              			Maink_Factory();
  0C91    2D9B    JP	0x59B
509:              			return;	
510:              		}
511:              		if(KeyData == KEY_CANCEL_KEEPWARM)
  0C92    3010    LDIA	0x10
  0C93    0628    XORA	0x28
  0C94    0427    ORA	0x27
  0C95    1D03    SNZB	0x3,2
  0C96    2C98    JP	0x498
512:              		{
513:              			Maink_Cancel();
  0C97    2D5C    JP	0x55C
514:              			return;
515:              		}
516:              		if(SysStatus==WAITING_MODE || SysStatus==CHOOSE_FUN_MODE)
  0C98    036A    DECA	0x6A
  0C99    1903    SZB	0x3,2
  0C9A    2CBD    JP	0x4BD
  0C9B    3002    LDIA	0x2
  0C9C    066A    XORA	0x6A
  0C9D    1D03    SNZB	0x3,2
  0C9E    0008    RET
  0C9F    2CBD    JP	0x4BD
  0CA0    3001    LDIA	0x1
  0CA1    00BC    LD	0x3C,A
  0CA2    2E7C    JP	0x67C
  0CA3    3002    LDIA	0x2
  0CA4    2CA1    JP	0x4A1
  0CA5    3003    LDIA	0x3
  0CA6    2CA1    JP	0x4A1
  0CA7    3004    LDIA	0x4
  0CA8    2CA1    JP	0x4A1
  0CA9    3005    LDIA	0x5
  0CAA    2CA1    JP	0x4A1
  0CAB    3006    LDIA	0x6
  0CAC    2CA1    JP	0x4A1
  0CAD    3007    LDIA	0x7
  0CAE    2CA1    JP	0x4A1
  0CAF    3008    LDIA	0x8
  0CB0    2CA1    JP	0x4A1
  0CB1    3009    LDIA	0x9
  0CB2    2CA1    JP	0x4A1
  0CB3    300A    LDIA	0xA
  0CB4    2CA1    JP	0x4A1
  0CB5    300B    LDIA	0xB
  0CB6    2CA1    JP	0x4A1
  0CB7    300C    LDIA	0xC
  0CB8    2CA1    JP	0x4A1
  0CB9    300D    LDIA	0xD
  0CBA    2CA1    JP	0x4A1
  0CBB    300E    LDIA	0xE
  0CBC    2CA1    JP	0x4A1
  0CBD    0828    LD	A,0x28
  0CBE    3A00    XORIA	0x0
  0CBF    1903    SZB	0x3,2
  0CC0    2CD7    JP	0x4D7
  0CC1    3A01    XORIA	0x1
  0CC2    1903    SZB	0x3,2
  0CC3    2CF1    JP	0x4F1
  0CC4    3A03    XORIA	0x3
  0CC5    1903    SZB	0x3,2
  0CC6    2CF6    JP	0x4F6
  0CC7    3A06    XORIA	0x6
  0CC8    1903    SZB	0x3,2
  0CC9    2CFB    JP	0x4FB
  0CCA    3A0C    XORIA	0xC
  0CCB    1903    SZB	0x3,2
  0CCC    2D00    JP	0x500
  0CCD    3A28    XORIA	0x28
  0CCE    1903    SZB	0x3,2
  0CCF    2D05    JP	0x505
  0CD0    3A60    XORIA	0x60
  0CD1    1903    SZB	0x3,2
  0CD2    2D0A    JP	0x50A
  0CD3    3AC0    XORIA	0xC0
  0CD4    1903    SZB	0x3,2
  0CD5    2D0F    JP	0x50F
  0CD6    2C0D    JP	0x40D
  0CD7    0827    LD	A,0x27
  0CD8    3A01    XORIA	0x1
  0CD9    1903    SZB	0x3,2
  0CDA    2CA7    JP	0x4A7
  0CDB    3A03    XORIA	0x3
  0CDC    1903    SZB	0x3,2
  0CDD    2CA5    JP	0x4A5
  0CDE    3A06    XORIA	0x6
  0CDF    1903    SZB	0x3,2
  0CE0    2CA3    JP	0x4A3
  0CE1    3A0C    XORIA	0xC
  0CE2    1903    SZB	0x3,2
  0CE3    2CA0    JP	0x4A0
  0CE4    3A18    XORIA	0x18
  0CE5    1903    SZB	0x3,2
  0CE6    2CAF    JP	0x4AF
  0CE7    3A30    XORIA	0x30
  0CE8    1903    SZB	0x3,2
  0CE9    2CAD    JP	0x4AD
  0CEA    3A60    XORIA	0x60
  0CEB    1903    SZB	0x3,2
  0CEC    2CAB    JP	0x4AB
  0CED    3AC0    XORIA	0xC0
  0CEE    1903    SZB	0x3,2
  0CEF    2CA9    JP	0x4A9
  0CF0    2C0D    JP	0x40D
  0CF1    0827    LD	A,0x27
  0CF2    3A00    XORIA	0x0
  0CF3    1903    SZB	0x3,2
  0CF4    2CB7    JP	0x4B7
  0CF5    2C0D    JP	0x40D
  0CF6    0827    LD	A,0x27
  0CF7    3A00    XORIA	0x0
  0CF8    1903    SZB	0x3,2
  0CF9    2CB5    JP	0x4B5
  0CFA    2C0D    JP	0x40D
  0CFB    0827    LD	A,0x27
  0CFC    3A00    XORIA	0x0
  0CFD    1903    SZB	0x3,2
  0CFE    2CB3    JP	0x4B3
  0CFF    2C0D    JP	0x40D
  0D00    0827    LD	A,0x27
  0D01    3A00    XORIA	0x0
  0D02    1903    SZB	0x3,2
  0D03    2CB1    JP	0x4B1
  0D04    2C0D    JP	0x40D
  0D05    0827    LD	A,0x27
  0D06    3A00    XORIA	0x0
  0D07    1903    SZB	0x3,2
  0D08    2CBB    JP	0x4BB
  0D09    2C0D    JP	0x40D
  0D0A    0827    LD	A,0x27
  0D0B    3A00    XORIA	0x0
  0D0C    1903    SZB	0x3,2
  0D0D    2C37    JP	0x437
  0D0E    2C0D    JP	0x40D
  0D0F    0827    LD	A,0x27
  0D10    3A00    XORIA	0x0
  0D11    1903    SZB	0x3,2
  0D12    2CB9    JP	0x4B9
  0D13    2C0D    JP	0x40D
  0D14    0008    RET
517:              		{					
518:              			switch(KeyData)
519:              			{			
520:              				case KEY_RICE_FUN:			ChooseFun = FUN_RICE;		Maink_Fast_Fun(); break;
521:              				case KEY_MIXRICE_FUN: 	 	ChooseFun = FUN_MIXRICE;	Maink_Fast_Fun(); break;
522:              				case KEY_PORRIDGE_PRESET:	ChooseFun = FUN_PORRIDGE;	Maink_Fast_Fun(); break;
523:              				case KEY_CONGEE_FUN:		ChooseFun = FUN_CONGEE;		Maink_Fast_Fun(); break;
524:              				
525:              				case KEY_SOUP_FUN:			ChooseFun = FUN_SOUP;		Maink_Fast_Fun(); break;
526:              				case KEY_COOKMEAT_FUN:		ChooseFun = FUN_COOKMEAT;	Maink_Fast_Fun(); break;
527:              				case KEY_RIB_FUN:			ChooseFun = FUN_RIB;		Maink_Fast_Fun(); break;
528:              				case KEY_CHICKEN_FUN:		ChooseFun = FUN_CHICKEN;	Maink_Fast_Fun(); break;
529:              
530:              				case KEY_EIGHTCONGEE_FUN: 	ChooseFun = FUN_EIGHTCONGEE;Maink_Fast_Fun(); break;
531:              				case KEY_BEEF_FUN:			ChooseFun = FUN_BEEF;		Maink_Fast_Fun(); break;
532:              				case KEY_BEAN_FUN:			ChooseFun = FUN_BEAN;		Maink_Fast_Fun(); break;
533:              				case KEY_CAKE_FUN:			ChooseFun = FUN_CAKE;		Maink_Fast_Fun(); break;
534:              
535:              				case KEY_PRESET_FUN:		MainK_Preset(); break;
536:              				case KEY_FASTHEAT_FUN:		ChooseFun = FUN_FASTHEAT;	Maink_Fast_Fun(); break;
537:              				case KEY_OPENEHEAT_FUN:		ChooseFun = FUN_OPENEHEAT;	Maink_Fast_Fun(); break;
538:              
539:              				default:	break;
540:              			}								
541:              		}
542:              	}
543:              }
544:              
545:              
546:              /***********************************************************
547:              取消处理函数
548:              ***********************************************************/
549:              void Cancel(void)
550:              {
551:              	//系统变量
552:              	SysStatus = WAITING_MODE;	
  0D77    3001    LDIA	0x1
  0D78    00EA    LD	0x6A,A
553:              	WorkStage = NO_WORK_STAGE;	
  0D79    01BF    CLR	0x3F
554:              	ChooseFun = NO_FUN;
  0D7A    01BC    CLR	0x3C
555:              	//TasteCase = NO_TASTE_CASE;
556:              	PresetState = NO_PRESET_STATE;
  0D7B    01B9    CLR	0x39
557:              	ErrorCode = NO_ERROR;
  0D7C    01D8    CLR	0x58
558:              	CountDownTime = 0;
  0D7D    01C0    CLR	0x40
559:              	CountDownTimeSave = 0;
  0D7E    01B3    CLR	0x33
560:              	WorkStep = 0;
  0D7F    01C2    CLR	0x42
561:              	FactoryTestData = 0;
  0D80    01C1    CLR	0x41
562:              	PressureData = 0;
  0D81    1683    SETB	0x3,5
  0D82    01C7    CLR	0x47
563:              	PressureCountTime = 0;
  0D83    01C6    CLR	0x46
564:              	 				
565:              	//时间
566:              	b_ShortOn = 0;		
  0D84    1271    CLRB	0x71,4
567:              	ShortCntL = 0;
  0D85    1283    CLRB	0x3,5
  0D86    01C4    CLR	0x44
568:              	ShortCntM = 0;
  0D87    01C3    CLR	0x43
569:              	
570:              	PresetTimeH = 0;
  0D88    01B6    CLR	0x36
571:              	PresetTimeM = 0;
  0D89    01B5    CLR	0x35
572:              	PresetTimeS = 0;
  0D8A    01AC    CLR	0x2C
573:              	
574:              	WorkTimeH = 0;
  0D8B    01AE    CLR	0x2E
575:              	WorkTimeM = 0;
  0D8C    01BD    CLR	0x3D
576:              	WorkTimeS = 0;
  0D8D    01B4    CLR	0x34
577:              	
578:              	KeepWarmH = 0;
  0D8E    01AB    CLR	0x2B
579:              	KeepWarmM = 0;
  0D8F    1683    SETB	0x3,5
  0D90    01C5    CLR	0x45
580:              	KeepWarmS = 0;
  0D91    01C4    CLR	0x44
581:              	
582:              	CountTimeS = 0;
  0D92    1283    CLRB	0x3,5
  0D93    01AA    CLR	0x2A
583:              		
584:              	//继电器关闭
585:              	b_BotHeatEn = FALSE;
  0D94    1371    CLRB	0x71,6
586:              	b_BotHeatOn = FALSE;  
  0D95    12F1    CLRB	0x71,5
587:              	
588:              	//检测信号  
589:              	b_BotTempOut = 0;
  0D96    1171    CLRB	0x71,2
590:              	b_Opencook_OK = 0;
  0D97    10F1    CLRB	0x71,1
591:              
592:              	Led_Step_100C = FALSE;	
  0D98    1683    SETB	0x3,5
  0D99    01CD    CLR	0x4D
  0D9A    0008    RET
593:              }
594:              
595:              
596:              /***********************************************************
597:              按键IO扫描函数
598:              ***********************************************************/
599:              void KscanIo(void) 	
600:              {
601:              	unsigned char i = 0;
602:              
603:              	//KeySeg设为上拉输入,KeyCom设为输入
604:              	KEY_SEG1_IN;
  02CE    1683    SETB	0x3,5
  02CF    1486    SETB	0x6,1
  02D0    1495    SETB	0x15,1
605:              	KEY_SEG2_IN;
  02D1    1608    SETB	0x8,4
  02D2    1703    SETB	0x3,6
  02D3    1605    SETB	0x5,4
606:              	KEY_SEG3_IN;
  02D4    1303    CLRB	0x3,6
  02D5    1506    SETB	0x6,2
  02D6    1515    SETB	0x15,2
607:              	KEY_SEG4_IN;
  02D7    1686    SETB	0x6,5
  02D8    1695    SETB	0x15,5
608:              		
609:              	KEY_COM1_IN;
  02D9    1586    SETB	0x6,3
610:              	KEY_COM2_IN;
  02DA    1606    SETB	0x6,4
611:              	KEY_COM3_IN;
  02DB    1706    SETB	0x6,6
612:              	KEY_COM4_IN;
  02DC    1786    SETB	0x6,7
613:              		
614:              	NOP();				//短延时，确保KeySeg口的电平被拉高
  02DD    0000    NOP
615:              	NOP();
  02DE    0000    NOP
616:              	NOP();
  02DF    0000    NOP
617:              	NOP();
  02E0    0000    NOP
618:              	NOP();
  02E1    0000    NOP
619:              			
620:              	//扫描key_com
621:              	for(i = 0; i < 4; i++)
  02E2    1283    CLRB	0x3,5
  02E3    1303    CLRB	0x3,6
  02E4    01DE    CLR	0x5E
  02E5    2B43    JP	0x343
622:              	{
623:              		switch(i)
624:              		{
625:              			case 0:
626:              				KEY_COM1 = 0;	
  02E6    1186    CLRB	0x6,3
627:              				KEY_COM1_OUT; 				
  02E7    1683    SETB	0x3,5
  02E8    1186    CLRB	0x6,3
628:              				break;
  02E9    2AFE    JP	0x2FE
629:              			case 1:
630:              				KEY_COM1_IN;
  02EA    1683    SETB	0x3,5
  02EB    1586    SETB	0x6,3
631:              				KEY_COM2 = 0;
  02EC    1283    CLRB	0x3,5
  02ED    1206    CLRB	0x6,4
632:              				KEY_COM2_OUT; 					
  02EE    1683    SETB	0x3,5
  02EF    1206    CLRB	0x6,4
633:              				break;
  02F0    2AFE    JP	0x2FE
634:              			case 2:
635:              				KEY_COM2_IN;
  02F1    1683    SETB	0x3,5
  02F2    1606    SETB	0x6,4
636:              				KEY_COM3 = 0;
  02F3    1283    CLRB	0x3,5
  02F4    1306    CLRB	0x6,6
637:              				KEY_COM3_OUT; 					
  02F5    1683    SETB	0x3,5
  02F6    1306    CLRB	0x6,6
638:              				break;
  02F7    2AFE    JP	0x2FE
639:              			case 3:
640:              				KEY_COM3_IN;
  02F8    1683    SETB	0x3,5
  02F9    1706    SETB	0x6,6
641:              				KEY_COM4 = 0;
  02FA    1283    CLRB	0x3,5
  02FB    1386    CLRB	0x6,7
642:              				KEY_COM4_OUT; 					
  02FC    1683    SETB	0x3,5
  02FD    1386    CLRB	0x6,7
643:              				break;
644:              			default: break;	
645:              		}
646:              		//保存按键数据到KeyData
647:              		if(!KEY_SEG1)
  02FE    1283    CLRB	0x3,5
  02FF    1886    SZB	0x6,1
  0300    2B0E    JP	0x30E
648:              			BSET(KeyData,0+i*4);
  0301    085E    LD	A,0x5E
  0302    00DA    LD	0x5A,A
  0303    3001    LDIA	0x1
  0304    1003    CLRB	0x3,0
  0305    0DDA    RLCR	0x5A
  0306    3EFF    ADDIA	0xFF
  0307    1003    CLRB	0x3,0
  0308    1D03    SNZB	0x3,2
  0309    2B05    JP	0x305
  030A    0D5A    RLCA	0x5A
  030B    2352    CALL	0x352
  030C    120A    CLRB	0xA,4
  030D    118A    CLRB	0xA,3
649:              		if(!KEY_SEG2)
  030E    1A08    SZB	0x8,4
  030F    2B1E    JP	0x31E
650:              			BSET(KeyData,1+i*4);
  0310    085E    LD	A,0x5E
  0311    00DA    LD	0x5A,A
  0312    3001    LDIA	0x1
  0313    1003    CLRB	0x3,0
  0314    0DDA    RLCR	0x5A
  0315    3EFF    ADDIA	0xFF
  0316    1003    CLRB	0x3,0
  0317    1D03    SNZB	0x3,2
  0318    2B14    JP	0x314
  0319    0D5A    RLCA	0x5A
  031A    3E01    ADDIA	0x1
  031B    2352    CALL	0x352
  031C    120A    CLRB	0xA,4
  031D    118A    CLRB	0xA,3
651:              		if(!KEY_SEG3)
  031E    1906    SZB	0x6,2
  031F    2B2E    JP	0x32E
652:              			BSET(KeyData,2+i*4);
  0320    085E    LD	A,0x5E
  0321    00DA    LD	0x5A,A
  0322    3001    LDIA	0x1
  0323    1003    CLRB	0x3,0
  0324    0DDA    RLCR	0x5A
  0325    3EFF    ADDIA	0xFF
  0326    1003    CLRB	0x3,0
  0327    1D03    SNZB	0x3,2
  0328    2B24    JP	0x324
  0329    0D5A    RLCA	0x5A
  032A    3E02    ADDIA	0x2
  032B    2352    CALL	0x352
  032C    120A    CLRB	0xA,4
  032D    118A    CLRB	0xA,3
653:              		if(!KEY_SEG4)
  032E    1A86    SZB	0x6,5
  032F    2B3E    JP	0x33E
654:              			BSET(KeyData,3+i*4);						
  0330    085E    LD	A,0x5E
  0331    00DA    LD	0x5A,A
  0332    3001    LDIA	0x1
  0333    1003    CLRB	0x3,0
  0334    0DDA    RLCR	0x5A
  0335    3EFF    ADDIA	0xFF
  0336    1003    CLRB	0x3,0
  0337    1D03    SNZB	0x3,2
  0338    2B34    JP	0x334
  0339    0D5A    RLCA	0x5A
  033A    3E03    ADDIA	0x3
  033B    2352    CALL	0x352
  033C    120A    CLRB	0xA,4
  033D    118A    CLRB	0xA,3
  033E    3004    LDIA	0x4
  033F    0ADE    INCR	0x5E
  0340    025E    SUBA	0x5E
  0341    1803    SZB	0x3,0
  0342    0008    RET
  0343    085E    LD	A,0x5E
  0344    3A00    XORIA	0x0
  0345    1903    SZB	0x3,2
  0346    2AE6    JP	0x2E6
  0347    3A01    XORIA	0x1
  0348    1903    SZB	0x3,2
  0349    2AEA    JP	0x2EA
  034A    3A03    XORIA	0x3
  034B    1903    SZB	0x3,2
  034C    2AF1    JP	0x2F1
  034D    3A01    XORIA	0x1
  034E    1903    SZB	0x3,2
  034F    2AF8    JP	0x2F8
  0350    2AFE    JP	0x2FE
  0351    2AFE    JP	0x2FE
655:              	}					 
656:              }	
657:              
658:              /***********************************************************
659:              按键扫描函数 主函数8ms调用
660:              ***********************************************************/
661:              void Key_Drive(void)
662:              {
663:              	static unsigned char keycount,nkeycount;     //有无按键去抖计数
664:              	static unsigned int keyold;                  //上一个按键值
665:              	static unsigned int keylong;                 //长按计数   
666:              	
667:              	KeyData = 0;	        //按键数据清理
  0281    01A7    CLR	0x27
  0282    01A8    CLR	0x28
668:              	KscanIo();              //读取按键数据
  0283    22CE    CALL	0x2CE
  0284    120A    CLRB	0xA,4
  0285    118A    CLRB	0xA,3
669:              	
670:              	if(KeyData != 0)		//不为0则表示有按键
  0286    0827    LD	A,0x27
  0287    0428    ORA	0x28
  0288    1903    SZB	0x3,2
  0289    2ABD    JP	0x2BD
671:              	{
672:              		nkeycount = 0;	    //无按键计数清零		
  028A    1683    SETB	0x3,5
  028B    01C2    CLR	0x42
673:              		if(KeyData == keyold)
  028C    082B    LD	A,0x2B
  028D    1283    CLRB	0x3,5
  028E    0628    XORA	0x28
  028F    1D03    SNZB	0x3,2
  0290    2A95    JP	0x295
  0291    1683    SETB	0x3,5
  0292    082A    LD	A,0x2A
  0293    1283    CLRB	0x3,5
  0294    0627    XORA	0x27
  0295    1D03    SNZB	0x3,2
  0296    2AB4    JP	0x2B4
674:              		{
675:              			if(KeyFlag & 0x02)			//有按键判断是否为长按键
  0297    1CAD    SNZB	0x2D,1
  0298    2AAA    JP	0x2AA
676:              			{
677:              				if(++keylong >= 125)	//长按时间1s=8ms*125
  0299    1683    SETB	0x3,5
  029A    0AA8    INCR	0x28
  029B    1903    SZB	0x3,2
  029C    0AA9    INCR	0x29
  029D    3000    LDIA	0x0
  029E    0229    SUBA	0x29
  029F    307D    LDIA	0x7D
  02A0    1903    SZB	0x3,2
  02A1    0228    SUBA	0x28
  02A2    1C03    SNZB	0x3,0
  02A3    0008    RET
678:              				{
679:              					keylong = 0;
  02A4    01A8    CLR	0x28
  02A5    01A9    CLR	0x29
680:              					BSET(KeyFlag,0);
  02A6    1283    CLRB	0x3,5
  02A7    142D    SETB	0x2D,0
681:              					BSET(KeyFlag,2);    //长按1s标志
  02A8    152D    SETB	0x2D,2
  02A9    0008    RET
682:              				}				
683:              			}			
684:              			else if(++keycount >= 5)	//无长按键则按键消抖，消抖时间为：5*10=50ms
  02AA    3005    LDIA	0x5
  02AB    1683    SETB	0x3,5
  02AC    0AC3    INCR	0x43
  02AD    0243    SUBA	0x43
  02AE    1C03    SNZB	0x3,0
  02AF    0008    RET
685:              			{
686:              				BSET(KeyFlag,0);        //第0位置1 按键标志		
  02B0    1283    CLRB	0x3,5
  02B1    142D    SETB	0x2D,0
687:              				BSET(KeyFlag,1);        //第1位置1 表示曾经有按键
  02B2    14AD    SETB	0x2D,1
  02B3    0008    RET
688:              			}
689:              		}
690:              		else
691:              		{
692:              			keyold = KeyData;			//保存当前值
  02B4    0828    LD	A,0x28
  02B5    1683    SETB	0x3,5
  02B6    00AB    LD	0x2B,A
  02B7    1283    CLRB	0x3,5
  02B8    0827    LD	A,0x27
  02B9    1683    SETB	0x3,5
  02BA    00AA    LD	0x2A,A
693:              			keycount = 0;	
  02BB    01C3    CLR	0x43
694:              		}		
695:              	}	
  02BC    0008    RET
696:              	else            //无按键
697:              	{
698:              		keycount = 0;
  02BD    1683    SETB	0x3,5
  02BE    3005    LDIA	0x5
  02BF    01C3    CLR	0x43
699:              		keylong = 0;
  02C0    01A8    CLR	0x28
  02C1    01A9    CLR	0x29
700:              		if(++nkeycount >= 5)     //去抖8*5=40ms
  02C2    0AC2    INCR	0x42
  02C3    0242    SUBA	0x42
  02C4    1C03    SNZB	0x3,0
  02C5    0008    RET
701:              		{
702:              			//清除按键数据与类型
703:              			KeyFlag = 0;
  02C6    1283    CLRB	0x3,5
  02C7    01AD    CLR	0x2D
704:              			KeyData = 0;
  02C8    01A7    CLR	0x27
  02C9    01A8    CLR	0x28
705:              			keyold = 0;
  02CA    1683    SETB	0x3,5
  02CB    01AA    CLR	0x2A
  02CC    01AB    CLR	0x2B
  02CD    0008    RET
706:              		}	
707:              	}
708:              }
709:              
710:              
711:              
712:              
713:              
714:              
715:              
716:              
717:              
718:              
719:              
720:              
721:              
722:              
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\delay.c ----------------------------------------------------------------------
1:                #include "delay.h"
2:                
3:                //微秒级非精准延时函数
4:                void DelayXus(unsigned int x)
5:                {
6:                	while(--x);
7:                }
8:                
9:                //毫秒级非精准延时函数
10:               void DelayXms(unsigned int x)
11:               {
12:               	unsigned char i = 0;;
  03D0    01DC    CLR	0x5C
13:               	
14:               	while(x--)
  03D1    3001    LDIA	0x1
  03D2    02DA    SUBR	0x5A
  03D3    3000    LDIA	0x0
  03D4    1C03    SNZB	0x3,0
  03D5    03DB    DECR	0x5B
  03D6    02DB    SUBR	0x5B
  03D7    0F5A    SZINCA	0x5A
  03D8    2BDC    JP	0x3DC
  03D9    0A5B    INCA	0x5B
  03DA    1903    SZB	0x3,2
  03DB    0008    RET
  03DC    0064    CLRWDT
15:               	{
16:               		asm("clrwdt");
17:               		while(--i)
  03DD    2BE3    JP	0x3E3
  03DE    0000    NOP
  03DF    0000    NOP
  03E0    0000    NOP
  03E1    0000    NOP
  03E2    0000    NOP
  03E3    1283    CLRB	0x3,5
  03E4    1303    CLRB	0x3,6
  03E5    0BDC    SZDECR	0x5C
  03E6    2BDE    JP	0x3DE
  03E7    2BD1    JP	0x3D1
18:               		{
19:               			asm("nop");
20:               			asm("nop");
21:               			asm("nop");
22:               			asm("nop");
23:               			asm("nop");
24:               		}
25:               	}
26:               }
27:               
28:               
29:               
30:               
31:               
32:               
33:               
34:               
35:               
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                
4:                /* NTC AD-温度表 下拉10K 
5:                   根据博远R25=100K+-1% B25/50=3990k +-1%换算
6:                */
7:                const uint8 REF_TEMP_TAB[]={ 	
8:                  	0,0,0,0,0,0,  0,0,1,3,5,                  //AD 0-10
9:                	7,9,11,13,14,  16,17,19,20,21,            //11-20
10:               	22,24,25,26,27,	28,29,30,31,32,           //21-30
11:               	32,33,34,35,36, 37,37,38,39,40,           //31-40
12:               	40,41,42,42,43, 44,44,45,46,46,           //41-50
13:               	47,48,48,49,49, 50,51,51,52,52,           //51-60
14:               	53,53,54,54,55, 56,56,57,57,58,           //61-70
15:               	58,59,59,60,60, 61,61,62,62,63,           //71-80
16:               	63,64,65,65,66, 66,67,67,68,68,           //81-90
17:               	68,69,69,70,70, 71,71,72,72,73,           //91-100
18:               	73,74,74,75,75, 76,76,77,77,78,           //101-110
19:               	78,79,79,80,80, 81,81,82,82,83,           //111-120
20:               	83,83,84,84,85, 85,86,86,87,87,           //121-130
21:               	88,88,89,89,90, 90,91,91,92,92,           //131-140
22:               	93,93,94,94,95, 95,96,97,97,98,           //141-150
23:               	98,99,99,100,100, 101,102,102,103,103,    //151-160
24:               	104,104,105,105,106, 107,107,108,108,109, //161-170
25:               	110,110,111,112,112, 113,114,114,115,116, //171-180
26:               	116,117,118,118,119, 120,120,121,122,123, //181-190
27:               	123,124,125,126,127, 127,128,129,130,131, //191-200
28:               	132,133,134,135,136, 137,138,139,140,141, //201-210
29:               	142,143,144,146,147, 148,149,150,152,153, //211-220
30:               	154,156,157,159,160, 162,164,166,167,169, //221-230
31:               	171,173,176,178,180, 183,186,189,192,195, //231-240
32:               	198,202,206,211,216,                      //241-245
33:               };
34:               
35:               
36:               /*****************************************************************
37:                @fun:      Get_Lid_Data
38:                @brief:    开合盖信号采样 主循环 8*25=200ms
39:                @param:    None                            
40:                @retval:   None
41:               *****************************************************************/
42:               void Get_Lid_Data(void)	   
43:               { 
44:               	static v_uint8 s_lidcount = 0;    //去抖变量	
45:                 
46:                   //当前开盖状态
47:               	if(b_LidClosed == FALSE)     
  0FA1    1BF2    SZB	0x72,7
  0FA2    2FBC    JP	0x7BC
48:               	{
49:               		if(LID_PORT == TRUE)           
  0FA3    1283    CLRB	0x3,5
  0FA4    1C07    SNZB	0x7,0
  0FA5    2FBA    JP	0x7BA
50:               		{
51:               			if(++s_lidcount >= LID_DEBOUNCE_TH)   //去抖25*8=200ms 
  0FA6    3019    LDIA	0x19
  0FA7    0ACD    INCR	0x4D
  0FA8    024D    SUBA	0x4D
  0FA9    1C03    SNZB	0x3,0
  0FAA    0008    RET
52:               			{
53:               				s_lidcount = 0;
  0FAB    01CD    CLR	0x4D
54:               				b_LidClosed = TRUE; 	    //合盖到位  
  0FAC    17F2    SETB	0x72,7
55:               				
56:               				b_Standby = 0;
  0FAD    1372    CLRB	0x72,6
57:               				StandbyTimeCnt = 0;
  0FAE    01D9    CLR	0x59
58:               				if(ErrorCode == NO_ERROR && SysStatus != POWERON_MODE)
  0FAF    0858    LD	A,0x58
  0FB0    1D03    SNZB	0x3,2
  0FB1    0008    RET
  0FB2    3006    LDIA	0x6
  0FB3    066A    XORA	0x6A
  0FB4    1903    SZB	0x3,2
  0FB5    0008    RET
59:               				{
60:               					CLOSELID_SOUND;	
  0FB6    3001    LDIA	0x1
  0FB7    00D7    LD	0x57,A
  0FB8    3019    LDIA	0x19
  0FB9    2F88    JP	0x788
61:               				}
62:               			}     
63:               		}
64:               		else
65:               		{
66:               			s_lidcount = 0;
  0FBA    01CD    CLR	0x4D
67:               		}
68:               	}
  0FBB    0008    RET
69:               	else                         //当前合盖状态
70:               	{
71:               		if(LID_PORT == FALSE)
  0FBC    1283    CLRB	0x3,5
  0FBD    1807    SZB	0x7,0
  0FBE    2FBA    JP	0x7BA
72:               		{
73:               			if(++s_lidcount >= LID_DEBOUNCE_TH)    //去抖
  0FBF    3019    LDIA	0x19
  0FC0    0ACD    INCR	0x4D
  0FC1    024D    SUBA	0x4D
  0FC2    1C03    SNZB	0x3,0
  0FC3    0008    RET
74:               			{
75:               				s_lidcount = 0;
  0FC4    01CD    CLR	0x4D
76:               			  	b_LidClosed = FALSE;      //开盖 
  0FC5    13F2    CLRB	0x72,7
77:               			  	
78:               				b_Standby = 0;
  0FC6    1372    CLRB	0x72,6
79:               				StandbyTimeCnt = 0;
  0FC7    01D9    CLR	0x59
80:               				if(ErrorCode == NO_ERROR && SysStatus != POWERON_MODE)
  0FC8    0858    LD	A,0x58
  0FC9    1D03    SNZB	0x3,2
  0FCA    0008    RET
  0FCB    3006    LDIA	0x6
  0FCC    066A    XORA	0x6A
  0FCD    1903    SZB	0x3,2
  0FCE    0008    RET
81:               				{
82:               					OPENLID_SOUND;	
  0FCF    3002    LDIA	0x2
  0FD0    00D7    LD	0x57,A
  0FD1    3007    LDIA	0x7
  0FD2    00D6    LD	0x56,A
  0FD3    300A    LDIA	0xA
  0FD4    2FD5    JP	0x7D5
83:               				}
84:               			}     
85:               		}
86:               		else
87:               		{
88:               			s_lidcount = 0;
89:               		}
90:               	}      	
91:               }
92:               
93:               
94:               /*****************************************************************
95:                @fun:      Get_Pressure_Switch_Data
96:                @brief:    压力开关检测  中断250us调用
97:                @param:    None                            
98:                @retval:   None
99:                @history:  V1.0  2019-3-21  初版本
100:              			V1.1  2019-4-25  压力开关闭合去抖时间由1s改为400ms
101:              *****************************************************************/
102:              void Get_Pressure_Switch_Data(void)
103:              {
104:              	static v_uint16 s_pscount = 0;    //压力开关去抖变量
105:              		
106:                  /*压力开关连接新方案*/
107:                  //压力开关闭合
108:              	if(b_PressureOn == FALSE)     
  00D1    1AF2    SZB	0x72,5
  00D2    28EA    JP	0xEA
109:              	{
110:              		if(Ad_Pressure_Raw < 15)   //2019.6.18              
  00D3    300F    LDIA	0xF
  00D4    0252    SUBA	0x52
  00D5    1803    SZB	0x3,0
  00D6    28E6    JP	0xE6
111:              		{
112:              			if(++s_pscount >= 1600)   //1600*250us=400ms
  00D7    1683    SETB	0x3,5
  00D8    0AB6    INCR	0x36
  00D9    1903    SZB	0x3,2
  00DA    0AB7    INCR	0x37
  00DB    3006    LDIA	0x6
  00DC    0237    SUBA	0x37
  00DD    3040    LDIA	0x40
  00DE    1903    SZB	0x3,2
  00DF    0236    SUBA	0x36
  00E0    1C03    SNZB	0x3,0
  00E1    0008    RET
113:              			{
114:              				s_pscount = 0;
  00E2    01B6    CLR	0x36
  00E3    01B7    CLR	0x37
115:              				b_PressureOn = TRUE;  //断开	 
  00E4    16F2    SETB	0x72,5
  00E5    0008    RET
116:              			}     
117:              		}
118:              		else
119:              		{
120:              			s_pscount = 0;
  00E6    1683    SETB	0x3,5
  00E7    01B6    CLR	0x36
  00E8    01B7    CLR	0x37
  00E9    0008    RET
121:              		}
122:              	}
123:              	else          //压力开关断开
124:              	{
125:              		if(Ad_Pressure_Raw > 20)
  00EA    3015    LDIA	0x15
  00EB    0252    SUBA	0x52
  00EC    1C03    SNZB	0x3,0
  00ED    28E6    JP	0xE6
126:              		{
127:              			if(++s_pscount >= 24)    //连续6ms有波形
  00EE    1683    SETB	0x3,5
  00EF    0AB6    INCR	0x36
  00F0    1903    SZB	0x3,2
  00F1    0AB7    INCR	0x37
  00F2    3000    LDIA	0x0
  00F3    0237    SUBA	0x37
  00F4    3018    LDIA	0x18
  00F5    1903    SZB	0x3,2
  00F6    0236    SUBA	0x36
  00F7    1C03    SNZB	0x3,0
  00F8    0008    RET
128:              			{
129:              				s_pscount = 0;
  00F9    01B6    CLR	0x36
  00FA    01B7    CLR	0x37
130:              			  	b_PressureOn = FALSE;      //闭合
  00FB    12F2    CLRB	0x72,5
  00FC    0008    RET
131:              			}     
132:              		}
133:              		else
134:              		{
135:              			s_pscount = 0;	
136:              		}
137:              	}				
138:              }
139:              
140:              /**********************************************************
141:               @fun:      Get_AC_Voltage
142:               @brief:    获取电压采样AD平均值  中断250us调用
143:              			连续采集100ms
144:               @param:    None                            
145:               @retval:   None
146:               @history:  V1.0  2019-3-21  初版本
147:                          V1.1  2019-4-25  停止采集条件增加继电器断开
148:              **********************************************************/
149:              void Get_AC_Voltage(void)
150:              {
151:              	static v_uint16 s_volcount = 0;            //电压AD去抖变量
152:              	
153:              	//压力开关断开或者继电器断开停止采集,清零变量
154:              	if(b_PressureOn == 1 || (REL_PORT == 0 && ErrorCode != ERROR_E8 && ErrorCode != ERROR_E9))
  00AB    1AF2    SZB	0x72,5
  00AC    28B8    JP	0xB8
  00AD    1283    CLRB	0x3,5
  00AE    1887    SZB	0x7,1
  00AF    28BE    JP	0xBE
  00B0    3008    LDIA	0x8
  00B1    0658    XORA	0x58
  00B2    1903    SZB	0x3,2
  00B3    28BE    JP	0xBE
  00B4    3009    LDIA	0x9
  00B5    0658    XORA	0x58
  00B6    1903    SZB	0x3,2
  00B7    28BE    JP	0xBE
155:              	{
156:              		Ad_Vol_Sum = 0;
  00B8    1683    SETB	0x3,5
  00B9    01BA    CLR	0x3A
  00BA    01BB    CLR	0x3B
157:              		s_volcount = 0;
  00BB    01B4    CLR	0x34
  00BC    01B5    CLR	0x35
  00BD    0008    RET
158:              		return;	
159:              	}
160:              		
161:              	Ad_Vol_Sum += Ad_Pressure_Raw;        //采样AD求和
  00BE    0852    LD	A,0x52
  00BF    1683    SETB	0x3,5
  00C0    07BA    ADDR	0x3A
  00C1    1803    SZB	0x3,0
  00C2    0ABB    INCR	0x3B
162:              	
163:              	if(++s_volcount >= 400)               //250us*400=100ms
  00C3    0AB4    INCR	0x34
  00C4    1903    SZB	0x3,2
  00C5    0AB5    INCR	0x35
  00C6    3001    LDIA	0x1
  00C7    0235    SUBA	0x35
  00C8    3090    LDIA	0x90
  00C9    1903    SZB	0x3,2
  00CA    0234    SUBA	0x34
  00CB    1C03    SNZB	0x3,0
  00CC    0008    RET
164:              	{
165:              		s_volcount = 0;
  00CD    01B4    CLR	0x34
  00CE    01B5    CLR	0x35
166:              		b_VolData_OK = 1;	              //400次采样求和完成,可以处理数据	
  00CF    1672    SETB	0x72,4
  00D0    0008    RET
167:              	}
168:              
169:              }
170:              
171:              /**********************************************************
172:               @fun:      Get_AC_Rms
173:               @brief:    获取AC电压有效值  主函数500ms调用  			
174:               @param:    None                            
175:               @retval:   None
176:               @history:  V1.0  2019-3-21  初版本
177:              			V1.1  2019-4-25  1-电压AD平均值去抖次数由18次改为6次 
178:              							 2-电压分档VRMS_LEVEL_220的范围由210-230V改为210-235V
179:              **********************************************************/
180:              void Get_AC_Rms(void)
181:              {
182:              	static v_uint8  s_maxvol = 0x00;     //存最大值
183:              	static v_uint8  s_minvol = 0xFF;	 //存最小值
184:              	static v_uint16 s_sumvol = 0;        //平均AD和
185:                  static v_uint8  s_voltimes = 0;      //平均AD扫描次数
186:              	
187:              	Ad_Vol_Raw = (v_uint8) (Ad_Vol_Sum/400);   //求出400次采样AD平均值
  1002    3090    LDIA	0x90
  1003    00DA    LD	0x5A,A
  1004    3001    LDIA	0x1
  1005    00DB    LD	0x5B,A
  1006    1683    SETB	0x3,5
  1007    083B    LD	A,0x3B
  1008    1283    CLRB	0x3,5
  1009    00DD    LD	0x5D,A
  100A    1683    SETB	0x3,5
  100B    083A    LD	A,0x3A
  100C    1283    CLRB	0x3,5
  100D    00DC    LD	0x5C,A
  100E    2329    CALL	0x329
  100F    160A    SETB	0xA,4
  1010    118A    CLRB	0xA,3
  1011    085A    LD	A,0x5A
  1012    00FC    LD	0x7C,A
188:              	Ad_Vol_Sum = 0;
  1013    1683    SETB	0x3,5
  1014    01BA    CLR	0x3A
  1015    01BB    CLR	0x3B
189:              	
190:              	s_sumvol += Ad_Vol_Raw;          //将AD平均值进行累加
  1016    087C    LD	A,0x7C
  1017    07B2    ADDR	0x32
  1018    1803    SZB	0x3,0
  1019    0AB3    INCR	0x33
191:              	
192:              	//获取最大最小值
193:              	if(Ad_Vol_Raw > s_maxvol)
  101A    087C    LD	A,0x7C
  101B    1283    CLRB	0x3,5
  101C    024C    SUBA	0x4C
  101D    1803    SZB	0x3,0
  101E    2821    JP	0x21
194:              	{
195:              		s_maxvol = Ad_Vol_Raw;	
  101F    087C    LD	A,0x7C
  1020    00CC    LD	0x4C,A
196:              	}
197:              	if(Ad_Vol_Raw < s_minvol)
  1021    086C    LD	A,0x6C
  1022    027C    SUBA	0x7C
  1023    1803    SZB	0x3,0
  1024    2827    JP	0x27
198:              	{
199:              		s_minvol = Ad_Vol_Raw;
  1025    087C    LD	A,0x7C
  1026    00EC    LD	0x6C,A
200:              	}	
201:              		
202:              	if(++s_voltimes >= 6)           //500ms*6=3s
  1027    3006    LDIA	0x6
  1028    0ACB    INCR	0x4B
  1029    024B    SUBA	0x4B
  102A    1C03    SNZB	0x3,0
  102B    288B    JP	0x8B
203:              	{
204:              		s_sumvol -= s_maxvol;
  102C    084C    LD	A,0x4C
  102D    1683    SETB	0x3,5
  102E    02B2    SUBR	0x32
  102F    1C03    SNZB	0x3,0
  1030    03B3    DECR	0x33
205:              		s_sumvol -= s_minvol;
  1031    1283    CLRB	0x3,5
  1032    086C    LD	A,0x6C
  1033    1683    SETB	0x3,5
  1034    02B2    SUBR	0x32
  1035    1C03    SNZB	0x3,0
  1036    03B3    DECR	0x33
206:              		
207:              		Ad_Vol_Avg = (v_uint8) (s_sumvol>>2); 
  1037    0833    LD	A,0x33
  1038    1283    CLRB	0x3,5
  1039    00E2    LD	0x62,A
  103A    1683    SETB	0x3,5
  103B    0832    LD	A,0x32
  103C    1283    CLRB	0x3,5
  103D    00E1    LD	0x61,A
  103E    1003    CLRB	0x3,0
  103F    0CE2    RRCR	0x62
  1040    0CE1    RRCR	0x61
  1041    1003    CLRB	0x3,0
  1042    0CE2    RRCR	0x62
  1043    0CE1    RRCR	0x61
  1044    0861    LD	A,0x61
  1045    00D1    LD	0x51,A
208:              
209:              		if(Ad_Vol_Avg > 66)
  1046    3043    LDIA	0x43
  1047    0251    SUBA	0x51
  1048    1C03    SNZB	0x3,0
  1049    284F    JP	0x4F
210:              		{
211:              			AC_Vol_Rms = 265;	  //上限
  104A    3009    LDIA	0x9
  104B    00E7    LD	0x67,A
  104C    3001    LDIA	0x1
  104D    00E8    LD	0x68,A
212:              		}
  104E    2860    JP	0x60
213:              		else if(Ad_Vol_Avg < 39)
  104F    3027    LDIA	0x27
  1050    0251    SUBA	0x51
  1051    1803    SZB	0x3,0
  1052    2857    JP	0x57
214:              		{
215:              			AC_Vol_Rms = 155;     //下限
  1053    309B    LDIA	0x9B
  1054    00E7    LD	0x67,A
  1055    01E8    CLR	0x68
216:              		}
  1056    2860    JP	0x60
217:              		else
218:              		{
219:              			AC_Vol_Rms = Ad_Vol_Avg*4;   //电压有效值换算关系
  1057    0851    LD	A,0x51
  1058    00E7    LD	0x67,A
  1059    01E8    CLR	0x68
  105A    1003    CLRB	0x3,0
  105B    0DE7    RLCR	0x67
  105C    0DE8    RLCR	0x68
  105D    1003    CLRB	0x3,0
  105E    0DE7    RLCR	0x67
  105F    0DE8    RLCR	0x68
220:              		}
221:              		 
222:              		/*电压有效值分档*/
223:              		if(AC_Vol_Rms <= 190)
  1060    3000    LDIA	0x0
  1061    0268    SUBA	0x68
  1062    30BF    LDIA	0xBF
  1063    1903    SZB	0x3,2
  1064    0267    SUBA	0x67
  1065    1803    SZB	0x3,0
  1066    2869    JP	0x69
224:              		{
225:              			Vrms_Level = VRMS_LEVEL_175;	
  1067    3001    LDIA	0x1
  1068    2883    JP	0x83
226:              		}
227:              		else if(AC_Vol_Rms <= 210)
  1069    3000    LDIA	0x0
  106A    0268    SUBA	0x68
  106B    30D3    LDIA	0xD3
  106C    1903    SZB	0x3,2
  106D    0267    SUBA	0x67
  106E    1803    SZB	0x3,0
  106F    2872    JP	0x72
228:              		{
229:              			Vrms_Level = VRMS_LEVEL_198;
  1070    3002    LDIA	0x2
  1071    2883    JP	0x83
230:              		}
231:              		else if(AC_Vol_Rms <= 235)
  1072    3000    LDIA	0x0
  1073    0268    SUBA	0x68
  1074    30EC    LDIA	0xEC
  1075    1903    SZB	0x3,2
  1076    0267    SUBA	0x67
  1077    1803    SZB	0x3,0
  1078    287B    JP	0x7B
232:              		{
233:              			Vrms_Level = VRMS_LEVEL_220;
  1079    3003    LDIA	0x3
  107A    2883    JP	0x83
234:              		}
235:              		else if(AC_Vol_Rms <= 265)
  107B    3001    LDIA	0x1
  107C    0268    SUBA	0x68
  107D    300A    LDIA	0xA
  107E    1903    SZB	0x3,2
  107F    0267    SUBA	0x67
  1080    1803    SZB	0x3,0
  1081    2884    JP	0x84
236:              		{
237:              			Vrms_Level = VRMS_LEVEL_242;	
  1082    3004    LDIA	0x4
  1083    00E9    LD	0x69,A
238:              		}
239:              				
240:              		s_voltimes = 0;
  1084    01CB    CLR	0x4B
241:              		s_maxvol = 0x00;
  1085    01CC    CLR	0x4C
242:              		s_minvol = 0xFF;
  1086    30FF    LDIA	0xFF
  1087    00EC    LD	0x6C,A
243:              		s_sumvol = 0;  			
  1088    1683    SETB	0x3,5
  1089    01B2    CLR	0x32
  108A    01B3    CLR	0x33
244:              		
245:              	}
246:              	
247:              	b_VolData_OK = 0;     //处理完一次后标志清零			
  108B    1272    CLRB	0x72,4
  108C    0008    RET
248:              
249:              }
250:              
251:              /**********************************************************
252:               @fun:      Get_Zero
253:               @brief:    过零检测  中断250us调用
254:               @param:    None                            
255:               @retval:   None
256:               @history:  V1.0  2019-3-21  初版本
257:                          V1.1  2019.3.27  修改了检测逻辑，第一次AD达到阈值值才开始计时
258:              **********************************************************/
259:              void Get_Zero(void)
260:              {
261:              	static v_uint16 s_zerotimes = 0;    //过零总定时
262:              	static v_uint8  s_zerocnt9ms = 0;   //9ms定时
263:              	static v_uint8  s_highcount = 0;    //AD大于阈值计数
264:              	static v_uint8  s_lowcount = 0;     //AD低于阈值计数
265:              	
266:              		
267:              	//使能过零检测
268:              	if(b_Zero_EN == 1)
  00FD    1DF2    SNZB	0x72,3
  00FE    0008    RET
269:              	{
270:              		s_zerotimes++;               
  00FF    0AB0    INCR	0x30
  0100    1903    SZB	0x3,2
  0101    0AB1    INCR	0x31
271:              		/* 零点检测超时5s */
272:              		if(s_zerotimes >= 20000)
  0102    304E    LDIA	0x4E
  0103    0231    SUBA	0x31
  0104    3020    LDIA	0x20
  0105    1903    SZB	0x3,2
  0106    0230    SUBA	0x30
  0107    1C03    SNZB	0x3,0
  0108    2913    JP	0x113
273:              		{
274:              			s_zerotimes = 0;
  0109    01B0    CLR	0x30
  010A    01B1    CLR	0x31
275:              			b_ZeroTimeout = 1;    //过零超时标志, 继电器强制动作标志
  010B    1572    SETB	0x72,2
276:              			
277:              			/*检测相关变量清零*/
278:              			b_Zero_EN = 0;	
  010C    11F2    CLRB	0x72,3
279:              			b_ZeroWave_OK = 0;
  010D    10F2    CLRB	0x72,1
280:              			s_zerocnt9ms = 0;
  010E    1283    CLRB	0x3,5
  010F    01CA    CLR	0x4A
281:              			s_lowcount = 0;
  0110    01C8    CLR	0x48
282:              			s_highcount = 0;
  0111    01C9    CLR	0x49
  0112    0008    RET
283:              			return;	
284:              		}	
285:              		
286:              		/* 9ms电压AD检测 */
287:              		if(Ad_Pressure_Raw >= 20)         //AD达到阈值
  0113    3014    LDIA	0x14
  0114    1283    CLRB	0x3,5
  0115    0252    SUBA	0x52
  0116    1C03    SNZB	0x3,0
  0117    2924    JP	0x124
288:              		{
289:              			s_zerocnt9ms++;               //9ms定时++						
  0118    0ACA    INCR	0x4A
290:              			if(b_ZeroWave_OK == 0)        //AD高次数未满足要求
  0119    18F2    SZB	0x72,1
  011A    2932    JP	0x132
291:              			{
292:              				s_lowcount = 0;           //低AD计数清零
  011B    01C8    CLR	0x48
293:              				if(++s_highcount >= 34)   //34次满足要求 置标志位     
  011C    3022    LDIA	0x22
  011D    0AC9    INCR	0x49
  011E    0249    SUBA	0x49
  011F    1C03    SNZB	0x3,0
  0120    2932    JP	0x132
294:              				{
295:              					s_highcount = 0;
  0121    01C9    CLR	0x49
296:              					b_ZeroWave_OK = 1;    
  0122    14F2    SETB	0x72,1
  0123    2932    JP	0x132
297:              				}				
298:              			}			
299:              						
300:              		}
301:              		else                                //AD小于阈值
302:              		{
303:              			if(s_zerocnt9ms > 0)            //保证第一个AD必须是>=20才开始计时9ms
  0124    084A    LD	A,0x4A
  0125    1903    SZB	0x3,2
  0126    2932    JP	0x132
304:              			{
305:              				s_zerocnt9ms++;             //9ms定时++
  0127    0ACA    INCR	0x4A
306:              				if(b_ZeroWave_OK == 0)
  0128    18F2    SZB	0x72,1
  0129    2932    JP	0x132
307:              				{
308:              					if(++s_lowcount >= 2)   //连续2次低于20重新检测
  012A    3002    LDIA	0x2
  012B    0AC8    INCR	0x48
  012C    0248    SUBA	0x48
  012D    1C03    SNZB	0x3,0
  012E    2932    JP	0x132
309:              					{
310:              						s_lowcount = 0;     //计数清零
  012F    01C8    CLR	0x48
311:              						s_highcount = 0;
  0130    01C9    CLR	0x49
312:              						s_zerocnt9ms = 0;      
  0131    01CA    CLR	0x4A
313:              					}				
314:              				}				
315:              			}			
316:              		}
317:              		
318:                      /* 9ms检测到后 判断是否零点 */
319:              		if(s_zerocnt9ms >= 36)
  0132    3024    LDIA	0x24
  0133    024A    SUBA	0x4A
  0134    1C03    SNZB	0x3,0
  0135    0008    RET
320:              		{			
321:              			if(b_ZeroWave_OK)
  0136    1CF2    SNZB	0x72,1
  0137    2944    JP	0x144
322:              			{
323:              				b_ZeroWave_OK = 0;
  0138    10F2    CLRB	0x72,1
324:              				s_zerocnt9ms = 0;				
  0139    01CA    CLR	0x4A
325:              				b_Zero = 1;                     //检测到零点 开始延时				
  013A    1472    SETB	0x72,0
326:              				b_Zero_EN = 0;
  013B    11F2    CLRB	0x72,3
327:              				
328:              				//保存下检测时间 用于显示
329:              				ZeroTimesShow = s_zerotimes;       
  013C    1683    SETB	0x3,5
  013D    0831    LD	A,0x31
  013E    00B9    LD	0x39,A
  013F    0830    LD	A,0x30
  0140    00B8    LD	0x38,A
330:              				s_zerotimes = 0;                //检测到零点后 定时清零			
  0141    01B0    CLR	0x30
  0142    01B1    CLR	0x31
331:              			}
  0143    0008    RET
332:              			else
333:              			{
334:              				//重新检测
335:              				s_lowcount = 0;
  0144    01C8    CLR	0x48
336:              				s_highcount = 0;
  0145    01C9    CLR	0x49
337:              				s_zerocnt9ms = 0;
  0146    01CA    CLR	0x4A
  0147    0008    RET
338:              			}
339:              		}		
340:              	}		
341:              }
342:              
343:              
344:              
345:              /*****************************************************************
346:               @fun:      Get_Temp_Data
347:               @brief:    主函数8ms 调用获取NTC AD值
348:              			18次去掉最大最小 取平均
349:              			8*18=144ms
350:               @param:    None                            
351:               @retval:   None
352:              *****************************************************************/
353:              void Get_Temp_Data(void)
354:              {
355:              	static v_uint8  s_admax = 0x00;    //存最大值
356:              	static v_uint8  s_admin = 0xFF;	//存最小值
357:              	static v_uint16 s_adsum = 0;  
358:                  static v_uint8  s_adtimes = 0;       //AD扫描次数
359:              		
360:              	s_adsum += Ad_Bot_Raw;
  054D    1283    CLRB	0x3,5
  054E    0850    LD	A,0x50
  054F    1683    SETB	0x3,5
  0550    07AE    ADDR	0x2E
  0551    1803    SZB	0x3,0
  0552    0AAF    INCR	0x2F
361:              	
362:              	//获取最大最小值
363:              	if(Ad_Bot_Raw > s_admax)
  0553    1283    CLRB	0x3,5
  0554    0850    LD	A,0x50
  0555    0247    SUBA	0x47
  0556    1803    SZB	0x3,0
  0557    2D5A    JP	0x55A
364:              	{
365:              		s_admax = Ad_Bot_Raw;	
  0558    0850    LD	A,0x50
  0559    00C7    LD	0x47,A
366:              	}
367:              	if(Ad_Bot_Raw < s_admin)
  055A    086B    LD	A,0x6B
  055B    0250    SUBA	0x50
  055C    1803    SZB	0x3,0
  055D    2D60    JP	0x560
368:              	{
369:              		s_admin = Ad_Bot_Raw;
  055E    0850    LD	A,0x50
  055F    00EB    LD	0x6B,A
370:              	}
371:              
372:              	//去抖18次
373:              	if(++s_adtimes >= 18)    
  0560    3012    LDIA	0x12
  0561    1683    SETB	0x3,5
  0562    0ACF    INCR	0x4F
  0563    024F    SUBA	0x4F
  0564    1C03    SNZB	0x3,0
  0565    2DA2    JP	0x5A2
374:              	{		
375:              		s_adsum -= s_admax;
  0566    1283    CLRB	0x3,5
  0567    0847    LD	A,0x47
  0568    1683    SETB	0x3,5
  0569    02AE    SUBR	0x2E
  056A    1C03    SNZB	0x3,0
  056B    03AF    DECR	0x2F
376:              		s_adsum -= s_admin;
  056C    1283    CLRB	0x3,5
  056D    086B    LD	A,0x6B
  056E    1683    SETB	0x3,5
  056F    02AE    SUBR	0x2E
  0570    1C03    SNZB	0x3,0
  0571    03AF    DECR	0x2F
377:              		
378:              		Ad_Bot = (v_uint8) (s_adsum>>4);    //取16次平均值
  0572    082F    LD	A,0x2F
  0573    1283    CLRB	0x3,5
  0574    00DB    LD	0x5B,A
  0575    1683    SETB	0x3,5
  0576    082E    LD	A,0x2E
  0577    1283    CLRB	0x3,5
  0578    00DA    LD	0x5A,A
  0579    3004    LDIA	0x4
  057A    1003    CLRB	0x3,0
  057B    0CDB    RRCR	0x5B
  057C    0CDA    RRCR	0x5A
  057D    3EFF    ADDIA	0xFF
  057E    1D03    SNZB	0x3,2
  057F    2D7A    JP	0x57A
  0580    085A    LD	A,0x5A
  0581    00CF    LD	0x4F,A
379:              						
380:              		if(Ad_Bot > 245)
  0582    30F6    LDIA	0xF6
  0583    024F    SUBA	0x4F
  0584    1C03    SNZB	0x3,0
  0585    2D88    JP	0x588
381:              		{
382:              			Bot_Temp = 223;	 //上限
  0586    30DF    LDIA	0xDF
  0587    2D98    JP	0x598
383:              		}
384:              		else if(Ad_Bot < 8)
  0588    3008    LDIA	0x8
  0589    024F    SUBA	0x4F
  058A    1803    SZB	0x3,0
  058B    2D8E    JP	0x58E
385:              		{
386:              			Bot_Temp = 0;     //下限
  058C    01CE    CLR	0x4E
387:              		}
  058D    2D99    JP	0x599
388:              		else
389:              		{
390:              			Bot_Temp = REF_TEMP_TAB[Ad_Bot];	//从表中查得温度值
  058E    084F    LD	A,0x4F
  058F    3E12    ADDIA	0x12
  0590    0084    LD	0x4,A
  0591    3098    LDIA	0x98
  0592    1803    SZB	0x3,0
  0593    3E01    ADDIA	0x1
  0594    00FF    LD	0x7F,A
  0595    160A    SETB	0xA,4
  0596    158A    SETB	0xA,3
  0597    2000    CALL	0x0
  0598    00CE    LD	0x4E,A
391:              		} 
392:              		
393:              		s_adtimes = 0;
  0599    1683    SETB	0x3,5
  059A    01CF    CLR	0x4F
394:              		s_admax = 0x00;
  059B    1283    CLRB	0x3,5
  059C    01C7    CLR	0x47
395:              		s_admin = 0xFF;
  059D    30FF    LDIA	0xFF
  059E    00EB    LD	0x6B,A
396:              		s_adsum = 0;						       		
  059F    1683    SETB	0x3,5
  05A0    01AE    CLR	0x2E
  05A1    01AF    CLR	0x2F
397:              	}	
398:              	
399:              	b_AdBot_OK = 0;		
  05A2    13F1    CLRB	0x71,7
  05A3    0008    RET
400:              
401:              }
402:              
403:              
404:              
405:              
406:              /**********************************************************
407:              ADC转换数据
408:              **********************************************************/
409:              uint8 Get_AD(uint8 ch)
  0078    00F5    LD	0x75,A
410:              {
411:              	v_uint8 i = 0;
  0079    01F6    CLR	0x76
412:              	//v_uint16 advalue;
413:              	uint8 adresult;
414:              	
415:              	ADCON1 = 0x80;	         //右对齐,出10位AD
  007A    3080    LDIA	0x80
  007B    1683    SETB	0x3,5
  007C    009F    LD	0x1F,A
416:              	
417:              	if(ch & 0x10)		 
  007D    1A75    SZB	0x75,4
418:              	{
419:              		ADCON1 |= 0x40;	  //设置CHS4
  007E    171F    SETB	0x1F,6
420:              	}
421:              	
422:              	ch &= 0x0f;       //取通道低四位
  007F    300F    LDIA	0xF
  0080    05F5    ANDR	0x75
423:              	
424:              	ADCON0 = 0x00;	     //16分频0x40  8分频0x00
  0081    1283    CLRB	0x3,5
  0082    019F    CLR	0x1F
425:              	ADCON0 |= (unsigned char)(ch << 2);   //设置通道 
  0083    0875    LD	A,0x75
  0084    00F3    LD	0x73,A
  0085    3001    LDIA	0x1
  0086    1003    CLRB	0x3,0
  0087    0DF3    RLCR	0x73
  0088    3EFF    ADDIA	0xFF
  0089    1003    CLRB	0x3,0
  008A    1D03    SNZB	0x3,2
  008B    2887    JP	0x87
  008C    0D73    RLCA	0x73
  008D    049F    ORR	0x1F
426:              	ADCON0 |= 0x01;						     //使能ADC	
  008E    141F    SETB	0x1F,0
  008F    0000    NOP
  0090    0000    NOP
427:              	
428:              	asm("nop");
429:              	asm("nop");
430:              	
431:              	GODONE = 1;							//开始转换 
  0091    1283    CLRB	0x3,5
  0092    1303    CLRB	0x3,6
  0093    149F    SETB	0x1F,1
432:              	
433:              	while(GODONE)
  0094    1C9F    SNZB	0x1F,1
  0095    2899    JP	0x99
434:              	{
435:              		if(0 == (--i))					//ad等待限时，防止拔插电后出现死循环
  0096    0BF6    SZDECR	0x76
  0097    2894    JP	0x94
436:              			return 0;
  0098    3400    RET	0x0
437:              	}
438:              		
439:              	//advalue = (unsigned int)(ADRESH<<8);
440:              	//advalue |= (unsigned int)ADRESL;	       //读取10位AD
441:              	
442:              	//adresult = (unsigned char) (advalue >> 2);  //取高8位数据
443:              	
444:              	adresult = ADRESH << 6;
  0099    081E    LD	A,0x1E
  009A    00F3    LD	0x73,A
  009B    0CF3    RRCR	0x73
  009C    0CF3    RRCR	0x73
  009D    0C73    RRCA	0x73
  009E    39C0    ANDIA	0xC0
  009F    00F4    LD	0x74,A
445:              	adresult |= (ADRESL>>2);
  00A0    1683    SETB	0x3,5
  00A1    081E    LD	A,0x1E
  00A2    00F3    LD	0x73,A
  00A3    1003    CLRB	0x3,0
  00A4    0CF3    RRCR	0x73
  00A5    1003    CLRB	0x3,0
  00A6    0CF3    RRCR	0x73
  00A7    0873    LD	A,0x73
  00A8    04F4    ORR	0x74
446:              	 
447:              	return adresult;
  00A9    0874    LD	A,0x74
  00AA    0008    RET
448:              			
449:              }
450:              
451:              
452:              
453:              
454:              
455:              
456:              
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  1329    01DE    CLR	0x5E
  132A    01DF    CLR	0x5F
  132B    085A    LD	A,0x5A
  132C    045B    ORA	0x5B
  132D    1903    SZB	0x3,2
  132E    2B4E    JP	0x34E
  132F    01E0    CLR	0x60
  1330    0AE0    INCR	0x60
  1331    1BDB    SZB	0x5B,7
  1332    2B37    JP	0x337
  1333    1003    CLRB	0x3,0
  1334    0DDA    RLCR	0x5A
  1335    0DDB    RLCR	0x5B
  1336    2B30    JP	0x330
  1337    1003    CLRB	0x3,0
  1338    0DDE    RLCR	0x5E
  1339    0DDF    RLCR	0x5F
  133A    085B    LD	A,0x5B
  133B    025D    SUBA	0x5D
  133C    1D03    SNZB	0x3,2
  133D    2B40    JP	0x340
  133E    085A    LD	A,0x5A
  133F    025C    SUBA	0x5C
  1340    1C03    SNZB	0x3,0
  1341    2B4A    JP	0x34A
  1342    085A    LD	A,0x5A
  1343    02DC    SUBR	0x5C
  1344    085B    LD	A,0x5B
  1345    1C03    SNZB	0x3,0
  1346    03DD    DECR	0x5D
  1347    02DD    SUBR	0x5D
  1348    145E    SETB	0x5E,0
  1349    1003    CLRB	0x3,0
  134A    0CDB    RRCR	0x5B
  134B    0CDA    RRCR	0x5A
  134C    0BE0    SZDECR	0x60
  134D    2B37    JP	0x337
  134E    085F    LD	A,0x5F
  134F    00DB    LD	0x5B,A
  1350    085E    LD	A,0x5E
  1351    00DA    LD	0x5A,A
  1352    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  1353    01DF    CLR	0x5F
  1354    1FDB    SNZB	0x5B,7
  1355    2B5D    JP	0x35D
  1356    09DA    COMR	0x5A
  1357    09DB    COMR	0x5B
  1358    0ADA    INCR	0x5A
  1359    1903    SZB	0x3,2
  135A    0ADB    INCR	0x5B
  135B    01DF    CLR	0x5F
  135C    0ADF    INCR	0x5F
  135D    1FDD    SNZB	0x5D,7
  135E    2B66    JP	0x366
  135F    09DC    COMR	0x5C
  1360    09DD    COMR	0x5D
  1361    0ADC    INCR	0x5C
  1362    1903    SZB	0x3,2
  1363    0ADD    INCR	0x5D
  1364    3001    LDIA	0x1
  1365    06DF    XORR	0x5F
  1366    01E0    CLR	0x60
  1367    01E1    CLR	0x61
  1368    085A    LD	A,0x5A
  1369    045B    ORA	0x5B
  136A    1903    SZB	0x3,2
  136B    2B8B    JP	0x38B
  136C    01DE    CLR	0x5E
  136D    0ADE    INCR	0x5E
  136E    1BDB    SZB	0x5B,7
  136F    2B74    JP	0x374
  1370    1003    CLRB	0x3,0
  1371    0DDA    RLCR	0x5A
  1372    0DDB    RLCR	0x5B
  1373    2B6D    JP	0x36D
  1374    1003    CLRB	0x3,0
  1375    0DE0    RLCR	0x60
  1376    0DE1    RLCR	0x61
  1377    085B    LD	A,0x5B
  1378    025D    SUBA	0x5D
  1379    1D03    SNZB	0x3,2
  137A    2B7D    JP	0x37D
  137B    085A    LD	A,0x5A
  137C    025C    SUBA	0x5C
  137D    1C03    SNZB	0x3,0
  137E    2B87    JP	0x387
  137F    085A    LD	A,0x5A
  1380    02DC    SUBR	0x5C
  1381    085B    LD	A,0x5B
  1382    1C03    SNZB	0x3,0
  1383    03DD    DECR	0x5D
  1384    02DD    SUBR	0x5D
  1385    1460    SETB	0x60,0
  1386    1003    CLRB	0x3,0
  1387    0CDB    RRCR	0x5B
  1388    0CDA    RRCR	0x5A
  1389    0BDE    SZDECR	0x5E
  138A    2B74    JP	0x374
  138B    085F    LD	A,0x5F
  138C    1903    SZB	0x3,2
  138D    2B93    JP	0x393
  138E    09E0    COMR	0x60
  138F    09E1    COMR	0x61
  1390    0AE0    INCR	0x60
  1391    1903    SZB	0x3,2
  1392    0AE1    INCR	0x61
  1393    0861    LD	A,0x61
  1394    00DB    LD	0x5B,A
  1395    0860    LD	A,0x60
  1396    00DA    LD	0x5A,A
  1397    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\awmod.c ----------------------------------------------------------------------
1:                // integer signed unsigned modulus
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awmod(signed int divisor, signed int dividend)
  1398    01DF    CLR	0x5F
  1399    1FDD    SNZB	0x5D,7
  139A    2BA2    JP	0x3A2
  139B    09DC    COMR	0x5C
  139C    09DD    COMR	0x5D
  139D    0ADC    INCR	0x5C
  139E    1903    SZB	0x3,2
  139F    0ADD    INCR	0x5D
  13A0    01DF    CLR	0x5F
  13A1    0ADF    INCR	0x5F
  13A2    1FDB    SNZB	0x5B,7
  13A3    2BA9    JP	0x3A9
  13A4    09DA    COMR	0x5A
  13A5    09DB    COMR	0x5B
  13A6    0ADA    INCR	0x5A
  13A7    1903    SZB	0x3,2
  13A8    0ADB    INCR	0x5B
  13A9    085A    LD	A,0x5A
  13AA    045B    ORA	0x5B
  13AB    1903    SZB	0x3,2
  13AC    2BC8    JP	0x3C8
  13AD    01DE    CLR	0x5E
  13AE    0ADE    INCR	0x5E
  13AF    1BDB    SZB	0x5B,7
  13B0    2BB5    JP	0x3B5
  13B1    1003    CLRB	0x3,0
  13B2    0DDA    RLCR	0x5A
  13B3    0DDB    RLCR	0x5B
  13B4    2BAE    JP	0x3AE
  13B5    085B    LD	A,0x5B
  13B6    025D    SUBA	0x5D
  13B7    1D03    SNZB	0x3,2
  13B8    2BBB    JP	0x3BB
  13B9    085A    LD	A,0x5A
  13BA    025C    SUBA	0x5C
  13BB    1C03    SNZB	0x3,0
  13BC    2BC4    JP	0x3C4
  13BD    085A    LD	A,0x5A
  13BE    02DC    SUBR	0x5C
  13BF    085B    LD	A,0x5B
  13C0    1C03    SNZB	0x3,0
  13C1    03DD    DECR	0x5D
  13C2    02DD    SUBR	0x5D
  13C3    1003    CLRB	0x3,0
  13C4    0CDB    RRCR	0x5B
  13C5    0CDA    RRCR	0x5A
  13C6    0BDE    SZDECR	0x5E
  13C7    2BB5    JP	0x3B5
  13C8    085F    LD	A,0x5F
  13C9    1903    SZB	0x3,2
  13CA    2BD0    JP	0x3D0
  13CB    09DC    COMR	0x5C
  13CC    09DD    COMR	0x5D
  13CD    0ADC    INCR	0x5C
  13CE    1903    SZB	0x3,2
  13CF    0ADD    INCR	0x5D
  13D0    085D    LD	A,0x5D
  13D1    00DB    LD	0x5B,A
  13D2    085C    LD	A,0x5C
  13D3    00DA    LD	0x5A,A
  13D4    0008    RET
7:                #else
8:                __awmod(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter, sign;
12:               
13:               	sign = 0;
14:               	if(dividend < 0) {
15:               		dividend = -dividend;
16:               		sign = 1;
17:               	}
18:               	if(divisor < 0)
19:               		divisor = -divisor;
20:               	if(divisor != 0) {
21:               		counter = 1;
22:               		while(((unsigned int)divisor & 0x8000U) == 0) {
23:               			divisor <<= 1;
24:               			counter++;
25:               		}
26:               		do {
27:               			if((unsigned int)divisor <= (unsigned int)dividend)
28:               				dividend -= divisor;
29:               			*(unsigned int *)&divisor >>= 1;
30:               		} while(--counter != 0);
31:               	}
32:               	if(sign)
33:               		dividend = -dividend;
34:               	return dividend;
35:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  13D5    085A    LD	A,0x5A
  13D6    045B    ORA	0x5B
  13D7    1903    SZB	0x3,2
  13D8    2BF4    JP	0x3F4
  13D9    01DE    CLR	0x5E
  13DA    0ADE    INCR	0x5E
  13DB    1BDB    SZB	0x5B,7
  13DC    2BE1    JP	0x3E1
  13DD    1003    CLRB	0x3,0
  13DE    0DDA    RLCR	0x5A
  13DF    0DDB    RLCR	0x5B
  13E0    2BDA    JP	0x3DA
  13E1    085B    LD	A,0x5B
  13E2    025D    SUBA	0x5D
  13E3    1D03    SNZB	0x3,2
  13E4    2BE7    JP	0x3E7
  13E5    085A    LD	A,0x5A
  13E6    025C    SUBA	0x5C
  13E7    1C03    SNZB	0x3,0
  13E8    2BF0    JP	0x3F0
  13E9    085A    LD	A,0x5A
  13EA    02DC    SUBR	0x5C
  13EB    085B    LD	A,0x5B
  13EC    1C03    SNZB	0x3,0
  13ED    03DD    DECR	0x5D
  13EE    02DD    SUBR	0x5D
  13EF    1003    CLRB	0x3,0
  13F0    0CDB    RRCR	0x5B
  13F1    0CDA    RRCR	0x5A
  13F2    0BDE    SZDECR	0x5E
  13F3    2BE1    JP	0x3E1
  13F4    085D    LD	A,0x5D
  13F5    00DB    LD	0x5B,A
  13F6    085C    LD	A,0x5C
  13F7    00DA    LD	0x5A,A
  13F8    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  16FF    00DC    LD	0x5C,A
  1700    3008    LDIA	0x8
  1701    00DD    LD	0x5D,A
  1702    01DE    CLR	0x5E
  1703    085C    LD	A,0x5C
  1704    00DB    LD	0x5B,A
  1705    3007    LDIA	0x7
  1706    1003    CLRB	0x3,0
  1707    0CDB    RRCR	0x5B
  1708    3EFF    ADDIA	0xFF
  1709    1003    CLRB	0x3,0
  170A    1D03    SNZB	0x3,2
  170B    2F07    JP	0x707
  170C    0D5E    RLCA	0x5E
  170D    045B    ORA	0x5B
  170E    00DE    LD	0x5E,A
  170F    1003    CLRB	0x3,0
  1710    0DDC    RLCR	0x5C
  1711    085A    LD	A,0x5A
  1712    025E    SUBA	0x5E
  1713    1C03    SNZB	0x3,0
  1714    2F17    JP	0x717
  1715    085A    LD	A,0x5A
  1716    02DE    SUBR	0x5E
  1717    0BDD    SZDECR	0x5D
  1718    2F03    JP	0x703
  1719    085E    LD	A,0x5E
  171A    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  171B    00DB    LD	0x5B,A
  171C    01DD    CLR	0x5D
  171D    085A    LD	A,0x5A
  171E    1903    SZB	0x3,2
  171F    2F34    JP	0x734
  1720    01DC    CLR	0x5C
  1721    0ADC    INCR	0x5C
  1722    1BDA    SZB	0x5A,7
  1723    2F27    JP	0x727
  1724    1003    CLRB	0x3,0
  1725    0DDA    RLCR	0x5A
  1726    2F21    JP	0x721
  1727    1003    CLRB	0x3,0
  1728    0DDD    RLCR	0x5D
  1729    085A    LD	A,0x5A
  172A    025B    SUBA	0x5B
  172B    1C03    SNZB	0x3,0
  172C    2F31    JP	0x731
  172D    085A    LD	A,0x5A
  172E    02DB    SUBR	0x5B
  172F    145D    SETB	0x5D,0
  1730    1003    CLRB	0x3,0
  1731    0CDA    RRCR	0x5A
  1732    0BDC    SZDECR	0x5C
  1733    2F27    JP	0x727
  1734    085D    LD	A,0x5D
  1735    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- D:\PROGRA~2\CMS_ID~1.12\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  1736    01DE    CLR	0x5E
  1737    01DF    CLR	0x5F
  1738    1C5A    SNZB	0x5A,0
  1739    2F40    JP	0x740
  173A    085C    LD	A,0x5C
  173B    07DE    ADDR	0x5E
  173C    1803    SZB	0x3,0
  173D    0ADF    INCR	0x5F
  173E    085D    LD	A,0x5D
  173F    07DF    ADDR	0x5F
  1740    1003    CLRB	0x3,0
  1741    0DDC    RLCR	0x5C
  1742    0DDD    RLCR	0x5D
  1743    1003    CLRB	0x3,0
  1744    0CDB    RRCR	0x5B
  1745    0CDA    RRCR	0x5A
  1746    085A    LD	A,0x5A
  1747    045B    ORA	0x5B
  1748    1D03    SNZB	0x3,2
  1749    2F38    JP	0x738
  174A    085F    LD	A,0x5F
  174B    00DB    LD	0x5B,A
  174C    085E    LD	A,0x5E
  174D    00DA    LD	0x5A,A
  174E    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\error.c ----------------------------------------------------------------------
1:                #include "error.h"
2:                
3:                /*****************************************************************
4:                 @fun:      Error_Deal
5:                 @brief:    报警错误处理函数,主函数循环调用
6:                 @param:    None                             
7:                 @retval:   None
8:                *****************************************************************/
9:                void Error_Deal(void)
10:               {
11:               	static v_uint16 E3_delaycount = 0;    //压力开关检测延时
12:               	//工作模式或保温模式或工厂模式加热时检测报警
13:               	if(SysStatus == WORK_MODE || SysStatus == KEEP_WARM_MODE || (SysStatus == FACTORY_TEST_MODE && FactoryTestData >= FACTORY_TEST_START))
  03E8    3003    LDIA	0x3
  03E9    066A    XORA	0x6A
  03EA    3004    LDIA	0x4
  03EB    1903    SZB	0x3,2
  03EC    2BF9    JP	0x3F9
  03ED    066A    XORA	0x6A
  03EE    1903    SZB	0x3,2
  03EF    2BF8    JP	0x3F8
  03F0    3005    LDIA	0x5
  03F1    066A    XORA	0x6A
  03F2    1D03    SNZB	0x3,2
  03F3    2C63    JP	0x463
  03F4    3013    LDIA	0x13
  03F5    0241    SUBA	0x41
  03F6    1C03    SNZB	0x3,0
  03F7    2C63    JP	0x463
14:               	{
15:               		//不可恢复E4
16:               		if(ErrorCode == ERROR_E4)	   
  03F8    3004    LDIA	0x4
  03F9    0658    XORA	0x58
  03FA    1903    SZB	0x3,2
  03FB    0008    RET
17:               		{
18:               			return;			
19:               		}
20:               
21:               		//E3压力开关开路
22:               		if(Ad_Bot <= BOT_TEMP_70 && b_PressureOn == TRUE)
  03FC    305F    LDIA	0x5F
  03FD    024F    SUBA	0x4F
  03FE    1C03    SNZB	0x3,0
  03FF    1EF2    SNZB	0x72,5
  0400    2C12    JP	0x412
23:               		{
24:               			if(++E3_delaycount >= 1250)	//延时1S
  0401    1683    SETB	0x3,5
  0402    0AAC    INCR	0x2C
  0403    1903    SZB	0x3,2
  0404    0AAD    INCR	0x2D
  0405    3004    LDIA	0x4
  0406    022D    SUBA	0x2D
  0407    30E2    LDIA	0xE2
  0408    1903    SZB	0x3,2
  0409    022C    SUBA	0x2C
  040A    1C03    SNZB	0x3,0
  040B    0008    RET
25:               			{
26:               				E3_delaycount = 0;
  040C    01AC    CLR	0x2C
  040D    01AD    CLR	0x2D
27:               				ErrorCode = ERROR_E3;				
  040E    3003    LDIA	0x3
  040F    1283    CLRB	0x3,5
  0410    00D8    LD	0x58,A
  0411    0008    RET
28:               			}
29:               			return;			
30:               		}
31:               		E3_delaycount = 0;
  0412    1683    SETB	0x3,5
  0413    01AC    CLR	0x2C
  0414    01AD    CLR	0x2D
32:               
33:               		//开合盖E7
34:               		if((b_LidClosed == FALSE) && ((SysStatus == WORK_MODE) || (SysStatus == FACTORY_TEST_MODE && FactoryTestData >= FACTORY_TEST_START)))	
  0415    1BF2    SZB	0x72,7
  0416    2C2B    JP	0x42B
  0417    3003    LDIA	0x3
  0418    1283    CLRB	0x3,5
  0419    066A    XORA	0x6A
  041A    1903    SZB	0x3,2
  041B    2C24    JP	0x424
  041C    3005    LDIA	0x5
  041D    066A    XORA	0x6A
  041E    1D03    SNZB	0x3,2
  041F    2C2B    JP	0x42B
  0420    3013    LDIA	0x13
  0421    0241    SUBA	0x41
  0422    1C03    SNZB	0x3,0
  0423    2C2B    JP	0x42B
35:               		{
36:               			//除开盖煮外的功能检测开盖需报警
37:               			if(!(ChooseFun == FUN_OPENEHEAT))
  0424    300E    LDIA	0xE
  0425    063C    XORA	0x3C
  0426    1903    SZB	0x3,2
  0427    2C2B    JP	0x42B
38:               			{
39:               				ErrorCode = ERROR_E7;
  0428    3007    LDIA	0x7
  0429    00D8    LD	0x58,A
  042A    0008    RET
40:               				return;					
41:               			}	
42:               		}
43:               		
44:               		//E8电压过高
45:               		if(AC_Vol_Rms >= 265)
  042B    3001    LDIA	0x1
  042C    1283    CLRB	0x3,5
  042D    0268    SUBA	0x68
  042E    3009    LDIA	0x9
  042F    1903    SZB	0x3,2
  0430    0267    SUBA	0x67
  0431    1C03    SNZB	0x3,0
  0432    2C36    JP	0x436
46:               		{
47:               			ErrorCode = ERROR_E8;	
  0433    3008    LDIA	0x8
  0434    00D8    LD	0x58,A
  0435    0008    RET
48:               			return;			
49:               		}
50:               		
51:               		//E9电压过低
52:               		if(AC_Vol_Rms <= 155 && AC_Vol_Rms >= 85)
  0436    3000    LDIA	0x0
  0437    0268    SUBA	0x68
  0438    309C    LDIA	0x9C
  0439    1903    SZB	0x3,2
  043A    0267    SUBA	0x67
  043B    1803    SZB	0x3,0
  043C    2C47    JP	0x447
  043D    3000    LDIA	0x0
  043E    0268    SUBA	0x68
  043F    3055    LDIA	0x55
  0440    1903    SZB	0x3,2
  0441    0267    SUBA	0x67
  0442    1C03    SNZB	0x3,0
  0443    2C47    JP	0x447
53:               		{
54:               			ErrorCode = ERROR_E9;
  0444    3009    LDIA	0x9
  0445    00D8    LD	0x58,A
  0446    0008    RET
55:               			return;	
56:               		}
57:               		
58:                       //底部NTC开路E1
59:               		if(Ad_Bot < 2)		   
  0447    3002    LDIA	0x2
  0448    024F    SUBA	0x4F
  0449    1803    SZB	0x3,0
  044A    2C4E    JP	0x44E
60:               		{
61:               			ErrorCode = ERROR_E1;	
  044B    3001    LDIA	0x1
  044C    00D8    LD	0x58,A
  044D    0008    RET
62:               			return;
63:               		}
64:               		
65:                       //底部NTC短路E2
66:               		if(Ad_Bot >= 252)	  
  044E    30FC    LDIA	0xFC
  044F    024F    SUBA	0x4F
  0450    1C03    SNZB	0x3,0
  0451    2C55    JP	0x455
67:               		{ 
68:               			ErrorCode = ERROR_E2;
  0452    3002    LDIA	0x2
  0453    00D8    LD	0x58,A
  0454    0008    RET
69:               			return;
70:               		}
71:               		
72:               
73:               		
74:               	    //压力开关短路或漏气 E4
75:               		if(SysStatus == WORK_MODE && WorkStage == WORK_HEAT_STAGE && WorkTimeH >= 1)
  0455    3003    LDIA	0x3
  0456    066A    XORA	0x6A
  0457    1D03    SNZB	0x3,2
  0458    2C63    JP	0x463
  0459    3002    LDIA	0x2
  045A    063F    XORA	0x3F
  045B    1D03    SNZB	0x3,2
  045C    2C63    JP	0x463
  045D    082E    LD	A,0x2E
  045E    1903    SZB	0x3,2
  045F    2C63    JP	0x463
76:               		{   
77:               			ErrorCode = ERROR_E4;
  0460    3004    LDIA	0x4
  0461    00D8    LD	0x58,A
  0462    0008    RET
78:               			return;
79:               		}			
80:               	}	
81:               	ErrorCode = NO_ERROR;		//报警清零
  0463    01D8    CLR	0x58
82:               	E3_delaycount = 0;	
  0464    1683    SETB	0x3,5
  0465    01AC    CLR	0x2C
  0466    01AD    CLR	0x2D
  0467    0008    RET
83:               }
---- E:\ProjectFile\2019\1-50C88\Program\Y-50C88-A008\cook.c ----------------------------------------------------------------------
1:                #include "cook.h"
2:                
3:                
4:                /*****************************************************************
5:                 @fun:      BotHeatTime
6:                 @brief:    发热盘间歇加热, 间隙加热前先调用BotHeatOff()
7:                 @param:    uint8 ontm    加热时间 second
8:                            uint8 offtm   停止时间 second                 
9:                 @retval:   None
10:               *****************************************************************/
11:               void Heat_Time_Select(uint8 ontm, uint8 offtm)
  0B4B    00DB    LD	0x5B,A
12:               {
13:               	//限幅	
14:               	if(ontm > 63)
  0B4C    3040    LDIA	0x40
  0B4D    025B    SUBA	0x5B
  0B4E    1C03    SNZB	0x3,0
  0B4F    2B52    JP	0x352
15:               	{
16:               		ontm = 63;		
  0B50    303F    LDIA	0x3F
  0B51    00DB    LD	0x5B,A
17:               	}
18:               	
19:               	if(offtm > 63)
  0B52    3040    LDIA	0x40
  0B53    025A    SUBA	0x5A
  0B54    1C03    SNZB	0x3,0
  0B55    2B59    JP	0x359
20:               	{
21:               		offtm = 63;		
  0B56    303F    LDIA	0x3F
  0B57    00DA    LD	0x5A,A
22:               	}
23:               	
24:               	//转化成0.5s计数	
25:               	RelOnCnt = ontm*2;
  0B58    1003    CLRB	0x3,0
  0B59    0D5B    RLCA	0x5B
  0B5A    1683    SETB	0x3,5
  0B5B    00CE    LD	0x4E,A
26:               	RelOffCnt = offtm*2;
  0B5C    1283    CLRB	0x3,5
  0B5D    1003    CLRB	0x3,0
  0B5E    0D5A    RLCA	0x5A
  0B5F    00C6    LD	0x46,A
27:               	
28:               	b_BotHeatEn = TRUE;	
  0B60    1771    SETB	0x71,6
29:               	b_BotHeatOn = FALSE;						
  0B61    12F1    CLRB	0x71,5
  0B62    0008    RET
30:               }
31:               
32:               /*****************************************************************
33:                @fun:      BotHeatOn
34:                @brief:    发热盘全功率加热
35:                @param:    None                
36:                @retval:   None
37:               *****************************************************************/
38:               void BotHeatOn(void)  
39:               {	
40:               	b_BotHeatEn = FALSE;
  0B6C    1371    CLRB	0x71,6
41:               	b_BotHeatOn = TRUE;
  0B6D    16F1    SETB	0x71,5
42:               	HeatCnt500ms = 0;
  0B6E    01C5    CLR	0x45
  0B6F    0008    RET
43:               }
44:               
45:               /*****************************************************************
46:                @fun:      BotHeatOff
47:                @brief:    发热盘停止加热
48:                @param:    None                
49:                @retval:   None
50:               *****************************************************************/
51:               void BotHeatOff(void)
52:               {	
53:               	b_BotHeatEn = FALSE;
  0B67    1371    CLRB	0x71,6
54:               	b_BotHeatOn = FALSE;
  0B68    12F1    CLRB	0x71,5
55:               	HeatCnt500ms = 0;
  0B69    1283    CLRB	0x3,5
  0B6A    01C5    CLR	0x45
  0B6B    0008    RET
56:               }  
57:               
58:               /*****************************************************************
59:                @fun:      ShortTimeOn
60:                @brief:    开启短计时器1
61:                @param:    None                             
62:                @retval:   None
63:               *****************************************************************/
64:               void ShortTimeOn(void)	
65:               {
66:               	b_ShortOn = 1;
  0B63    1671    SETB	0x71,4
67:               	ShortCntL = 0;
  0B64    01C4    CLR	0x44
68:               	ShortCntM = 0;
  0B65    01C3    CLR	0x43
  0B66    0008    RET
69:               }
70:               
71:               /*****************************************************************
72:                @fun:      FactoryHeat
73:                @brief:    工厂煲水加热
74:                @param:    None                             
75:                @retval:   None
76:               *****************************************************************/
77:               void FactoryTest(void)
78:               {
79:               		//工装检测
80:               	if(b_Auto_test == TRUE)
  0819    1DF1    SNZB	0x71,3
  081A    281C    JP	0x1C
81:               	{
82:               		BotHeatOn();
  081B    2B6C    JP	0x36C
83:               		//工装无法检测零点,采用不过零开启
84:               		return;
85:               	}
86:               	//超温报警不可恢复
87:               	if(b_BotTempOut == TRUE)
  081C    1971    SZB	0x71,2
  081D    2840    JP	0x40
88:               	{
89:               		BotHeatOff();
  0840    2B67    JP	0x367
90:               		return;	
91:               	}	
92:               	//超温135
93:               	if(Ad_Bot >= BOT_TEMP_135)
  081E    30CC    LDIA	0xCC
  081F    024F    SUBA	0x4F
  0820    1803    SZB	0x3,0
  0821    282E    JP	0x2E
  0822    0842    LD	A,0x42
  0823    3A00    XORIA	0x0
  0824    1903    SZB	0x3,2
  0825    2831    JP	0x31
  0826    3A01    XORIA	0x1
  0827    1903    SZB	0x3,2
  0828    2834    JP	0x34
  0829    3A03    XORIA	0x3
  082A    1903    SZB	0x3,2
  082B    283E    JP	0x3E
  082C    2840    JP	0x40
  082D    0008    RET
94:               	{
95:               		BotHeatOff();	
  082E    2367    CALL	0x367
96:               		b_BotTempOut = TRUE;
  082F    1571    SETB	0x71,2
  0830    0008    RET
97:               		return;	
98:               	}
99:               	//工厂煲水流程   
100:              	switch(WorkStep)
101:              	{
102:              		case 0:                                          
103:              			ShortTimeOn(); 
  0831    2363    CALL	0x363
104:              			WorkStep++;
  0832    0AC2    INCR	0x42
105:              			break;
  0833    0008    RET
106:              		case 1:
107:              			if(b_PressureOn)
  0834    1EF2    SNZB	0x72,5
  0835    281B    JP	0x1B
108:              			{
109:              				FactoryTestData = FACTORY_TEST_COUNT;     //上压后进入倒计时
  0836    3014    LDIA	0x14
  0837    00C1    LD	0x41,A
110:              				CountDownTime = 1;                        //倒计时1分钟				
  0838    3001    LDIA	0x1
  0839    00C0    LD	0x40,A
111:              				BotHeatOff();
  083A    2367    CALL	0x367
  083B    120A    CLRB	0xA,4
  083C    158A    SETB	0xA,3
  083D    2831    JP	0x31
112:              				ShortTimeOn();
113:              				WorkStep++;
114:              				break;
115:              			}												
116:              			BotHeatOn();	   //全功率加热		 			
117:              			break;
118:              		case 2:                //倒计时阶段
119:              			if(b_PressureOn)
  083E    1EF2    SNZB	0x72,5
  083F    281B    JP	0x1B
120:              			{
121:              				BotHeatOff();   //到达压力关闭继电器
122:              			}
123:              			else 
124:              			{
125:              				BotHeatOn();
126:              			}				
127:              			break;
128:              			
129:              		default: BotHeatOff(); break;			
130:              	}					
131:              }
132:              
133:              /*****************************************************************
134:               @fun:      RiceHeat
135:               @brief:    米饭加热
136:               @param:    None                             
137:               @retval:   None
138:              *****************************************************************/
139:              void RiceHeat(void)
140:              {
141:              	//压力开关断开或者底部>=145C 进入保压
142:              	if((b_PressureOn == TRUE || Ad_Bot >= BOT_TEMP_145) && WorkStage != WORK_COUNTDOWN_STAGE) 
  0A78    1AF2    SZB	0x72,5
  0A79    2A7E    JP	0x27E
  0A7A    30D5    LDIA	0xD5
  0A7B    024F    SUBA	0x4F
  0A7C    1C03    SNZB	0x3,0
  0A7D    2A8C    JP	0x28C
  0A7E    3003    LDIA	0x3
  0A7F    063F    XORA	0x3F
  0A80    1903    SZB	0x3,2
  0A81    2A8C    JP	0x28C
143:              	{
144:              		WorkStage = WORK_COUNTDOWN_STAGE;		
  0A82    3003    LDIA	0x3
  0A83    00BF    LD	0x3F,A
145:              		WorkStep = 5;
  0A84    3005    LDIA	0x5
  0A85    00C2    LD	0x42,A
146:              		ShortTimeOn();	//重新计时
  0A86    2363    CALL	0x363
  0A87    120A    CLRB	0xA,4
  0A88    158A    SETB	0xA,3
147:              		//计算烹饪总时间
148:              		TotalTimeSave = WorkTimeM + CountDownTime; 
  0A89    0840    LD	A,0x40
  0A8A    073D    ADDA	0x3D
  0A8B    00BE    LD	0x3E,A
  0A8C    0842    LD	A,0x42
  0A8D    3A00    XORIA	0x0
  0A8E    1903    SZB	0x3,2
  0A8F    2AA1    JP	0x2A1
  0A90    3A01    XORIA	0x1
  0A91    1903    SZB	0x3,2
  0A92    2AB6    JP	0x2B6
  0A93    3A03    XORIA	0x3
  0A94    1903    SZB	0x3,2
  0A95    2ABB    JP	0x2BB
  0A96    3A01    XORIA	0x1
  0A97    1903    SZB	0x3,2
  0A98    2AC6    JP	0x2C6
  0A99    3A07    XORIA	0x7
  0A9A    1903    SZB	0x3,2
  0A9B    2AF0    JP	0x2F0
  0A9C    3A01    XORIA	0x1
  0A9D    1903    SZB	0x3,2
  0A9E    2B1B    JP	0x31B
  0A9F    2ABA    JP	0x2BA
  0AA0    0008    RET
149:              	}
150:              	//米饭烹饪流程	
151:              	switch(WorkStep)
152:              	{
153:              		case 0:
154:              		    //全功率加热至95度               
155:              			if(Ad_Bot >= BOT_TEMP_95)
  0AA1    3091    LDIA	0x91
  0AA2    024F    SUBA	0x4F
  0AA3    1C03    SNZB	0x3,0
  0AA4    2AB5    JP	0x2B5
156:              			{ 
157:              				//电压低于205V跳过停功率2分钟 
158:              				if(AC_Vol_Rms >= 205)
  0AA5    3000    LDIA	0x0
  0AA6    0268    SUBA	0x68
  0AA7    30CD    LDIA	0xCD
  0AA8    1903    SZB	0x3,2
  0AA9    0267    SUBA	0x67
  0AAA    1C03    SNZB	0x3,0
  0AAB    2AB2    JP	0x2B2
159:              				{ 
160:              					BotHeatOff();	
  0AAC    2367    CALL	0x367
  0AAD    120A    CLRB	0xA,4
  0AAE    158A    SETB	0xA,3
161:              				  	ShortTimeOn(); 	  //重新计时						
162:              					WorkStep++;
  0AB0    0AC2    INCR	0x42
163:              				}
  0AB1    0008    RET
164:              				else
165:              				{  
166:              					WorkStep = 2;     //直接进入第2步
  0AB2    3002    LDIA	0x2
  0AB3    00C2    LD	0x42,A
  0AB4    0008    RET
167:              				}
168:              				break;
169:              			}
170:              			BotHeatOn();	
  0AB5    2B6C    JP	0x36C
171:              			break;
172:              		case 1 : 
173:              		    //停功率2分钟  
174:              			if(ShortCntM >= 2)
  0AB6    3002    LDIA	0x2
  0AB7    0243    SUBA	0x43
  0AB8    1803    SZB	0x3,0
  0AB9    2AAF    JP	0x2AF
175:              			{
176:              				ShortTimeOn();	
  0AAF    2363    CALL	0x363
177:              				WorkStep++;	
178:              				break;
179:              			}
180:              			BotHeatOff();									
  0ABA    2B67    JP	0x367
181:              			break;
182:              		case 2: 
183:              			if(Ad_Bot >= BOT_TEMP_128)       //第一个间歇温度点128C
  0ABB    30C5    LDIA	0xC5
  0ABC    024F    SUBA	0x4F
  0ABD    1C03    SNZB	0x3,0
  0ABE    2AB5    JP	0x2B5
184:              			{
185:              				ShortTimeOn(); 				
  0ABF    2363    CALL	0x363
  0AC0    120A    CLRB	0xA,4
  0AC1    158A    SETB	0xA,3
186:              				BotHeatOff();
  0AC2    2367    CALL	0x367
  0AC3    120A    CLRB	0xA,4
  0AC4    158A    SETB	0xA,3
  0AC5    2AB0    JP	0x2B0
187:              				WorkStep++;
188:              				break;
189:              			}
190:              			BotHeatOn();       							
191:              			break;
192:              		case 3:	
193:              			if(Ad_Bot <= BOT_TEMP_124)        //恢复全功率
  0AC6    30C1    LDIA	0xC1
  0AC7    024F    SUBA	0x4F
  0AC8    1803    SZB	0x3,0
  0AC9    2ACE    JP	0x2CE
194:              			{
195:              				ShortTimeOn();	
  0ACA    2363    CALL	0x363
  0ACB    120A    CLRB	0xA,4
  0ACC    158A    SETB	0xA,3
  0ACD    2AB2    JP	0x2B2
196:              				WorkStep = 2;
197:              				break;	
198:              			}		
199:              			if(Ad_Bot >= BOT_TEMP_135)       //第二个间歇温度点135C
  0ACE    30CC    LDIA	0xCC
  0ACF    024F    SUBA	0x4F
  0AD0    1803    SZB	0x3,0
  0AD1    2ABF    JP	0x2BF
  0AD2    0869    LD	A,0x69
  0AD3    3A01    XORIA	0x1
  0AD4    1903    SZB	0x3,2
  0AD5    2AB5    JP	0x2B5
  0AD6    3A03    XORIA	0x3
  0AD7    1903    SZB	0x3,2
  0AD8    2AE0    JP	0x2E0
  0AD9    3A01    XORIA	0x1
  0ADA    1903    SZB	0x3,2
  0ADB    2AE4    JP	0x2E4
  0ADC    3A07    XORIA	0x7
  0ADD    1903    SZB	0x3,2
  0ADE    2AE8    JP	0x2E8
  0ADF    2AEC    JP	0x2EC
  0AE0    3003    LDIA	0x3
  0AE1    00DA    LD	0x5A,A
  0AE2    3011    LDIA	0x11
  0AE3    2B4B    JP	0x34B
  0AE4    3006    LDIA	0x6
  0AE5    00DA    LD	0x5A,A
  0AE6    300E    LDIA	0xE
  0AE7    2B4B    JP	0x34B
  0AE8    3008    LDIA	0x8
  0AE9    00DA    LD	0x5A,A
  0AEA    300C    LDIA	0xC
  0AEB    2B4B    JP	0x34B
  0AEC    3006    LDIA	0x6
  0AED    00DA    LD	0x5A,A
  0AEE    300E    LDIA	0xE
  0AEF    2B4B    JP	0x34B
200:              			{
201:              				ShortTimeOn(); 				
202:              				BotHeatOff();
203:              				WorkStep++;
204:              				break;
205:              			}
206:              			/*第一间歇温度点
207:              			根据电压档位选择不同加热比例 等效700W*/
208:              			switch(Vrms_Level)
209:              			{
210:              				case VRMS_LEVEL_175:  BotHeatOn();               break;
211:              				case VRMS_LEVEL_198:  Heat_Time_Select(17, 3);   break;
212:              				case VRMS_LEVEL_220:  Heat_Time_Select(14, 6);   break;
213:              				case VRMS_LEVEL_242:  Heat_Time_Select(12, 8);   break;
214:              				default:              Heat_Time_Select(14, 6);   break;					
215:              			}				   		
216:              			break;
217:              		case 4:
218:              			if(Ad_Bot <= BOT_TEMP_131)       //回到上一步
  0AF0    30C9    LDIA	0xC9
  0AF1    024F    SUBA	0x4F
  0AF2    1803    SZB	0x3,0
  0AF3    2B0D    JP	0x30D
219:              			{
220:              				ShortTimeOn(); 				
  0AF4    2363    CALL	0x363
  0AF5    120A    CLRB	0xA,4
  0AF6    158A    SETB	0xA,3
221:              				BotHeatOff();
  0AF7    2367    CALL	0x367
222:              				WorkStep = 3;
  0AF8    3003    LDIA	0x3
  0AF9    00C2    LD	0x42,A
223:              				break;
  0AFA    0008    RET
  0AFB    3004    LDIA	0x4
  0AFC    00DA    LD	0x5A,A
  0AFD    3010    LDIA	0x10
  0AFE    2B4B    JP	0x34B
  0AFF    3008    LDIA	0x8
  0B00    00DA    LD	0x5A,A
  0B01    300C    LDIA	0xC
  0B02    2B4B    JP	0x34B
  0B03    300A    LDIA	0xA
  0B04    00DA    LD	0x5A,A
  0B05    2B4B    JP	0x34B
  0B06    300C    LDIA	0xC
  0B07    00DA    LD	0x5A,A
  0B08    3008    LDIA	0x8
  0B09    2B4B    JP	0x34B
  0B0A    300A    LDIA	0xA
  0B0B    00DA    LD	0x5A,A
  0B0C    2B4B    JP	0x34B
  0B0D    0869    LD	A,0x69
  0B0E    3A01    XORIA	0x1
  0B0F    1903    SZB	0x3,2
  0B10    2AFB    JP	0x2FB
  0B11    3A03    XORIA	0x3
  0B12    1903    SZB	0x3,2
  0B13    2AFF    JP	0x2FF
  0B14    3A01    XORIA	0x1
  0B15    1903    SZB	0x3,2
  0B16    2B03    JP	0x303
  0B17    3A07    XORIA	0x7
  0B18    1903    SZB	0x3,2
  0B19    2B06    JP	0x306
  0B1A    2B0A    JP	0x30A
224:              			}
225:              			/*第二间歇温度点
226:              			根据电压档位选择不同加热比例 等效500W*/
227:              			switch(Vrms_Level)
228:              			{
229:              				case VRMS_LEVEL_175:  Heat_Time_Select(16, 4);   break;
230:              				case VRMS_LEVEL_198:  Heat_Time_Select(12, 8);   break;
231:              				case VRMS_LEVEL_220:  Heat_Time_Select(10,10);   break;
232:              				case VRMS_LEVEL_242:  Heat_Time_Select(8, 12);   break;
233:              				default:              Heat_Time_Select(10,10);   break;					
234:              			}				
235:              			break;		
236:              		case 5:
237:              			//标准饭最后5分钟不加热 
238:              			if(ChooseFun == FUN_RICE)
  0B1B    0B3C    SZDECA	0x3C
  0B1C    2B21    JP	0x321
239:              			{
240:              				if(CountDownTime <= 5)	
  0B1D    3006    LDIA	0x6
  0B1E    0240    SUBA	0x40
  0B1F    1C03    SNZB	0x3,0
  0B20    2ABA    JP	0x2BA
241:              				{
242:              					BotHeatOff();
243:              					break;		
244:              				}					
245:              			}					
246:              
247:              			//控制底部温度范围115-112			
248:              			if(b_PressureOn == 1 || Ad_Bot >= BOT_TEMP_115)	 
  0B21    1AF2    SZB	0x72,5
  0B22    2ABA    JP	0x2BA
  0B23    30B3    LDIA	0xB3
  0B24    024F    SUBA	0x4F
  0B25    1803    SZB	0x3,0
  0B26    2ABA    JP	0x2BA
249:              			{
250:              				BotHeatOff();	
251:              			}  	
252:              			else if(Ad_Bot <= BOT_TEMP_112)       
  0B27    30AF    LDIA	0xAF
  0B28    024F    SUBA	0x4F
  0B29    1803    SZB	0x3,0
  0B2A    0008    RET
  0B2B    0869    LD	A,0x69
  0B2C    3A01    XORIA	0x1
  0B2D    1903    SZB	0x3,2
  0B2E    2B39    JP	0x339
  0B2F    3A03    XORIA	0x3
  0B30    1903    SZB	0x3,2
  0B31    2B3D    JP	0x33D
  0B32    3A01    XORIA	0x1
  0B33    1903    SZB	0x3,2
  0B34    2B41    JP	0x341
  0B35    3A07    XORIA	0x7
  0B36    1903    SZB	0x3,2
  0B37    2B44    JP	0x344
  0B38    2B48    JP	0x348
  0B39    3004    LDIA	0x4
  0B3A    00DA    LD	0x5A,A
  0B3B    3010    LDIA	0x10
  0B3C    2B4B    JP	0x34B
  0B3D    3008    LDIA	0x8
  0B3E    00DA    LD	0x5A,A
  0B3F    300C    LDIA	0xC
  0B40    2B4B    JP	0x34B
  0B41    300A    LDIA	0xA
  0B42    00DA    LD	0x5A,A
  0B43    2B4B    JP	0x34B
  0B44    300C    LDIA	0xC
  0B45    00DA    LD	0x5A,A
  0B46    3008    LDIA	0x8
  0B47    2B4B    JP	0x34B
  0B48    300A    LDIA	0xA
  0B49    00DA    LD	0x5A,A
  0B4A    2B4B    JP	0x34B
253:              			{
254:              				/*保压阶段根据电压档位选择不同加热比例 等效500W*/
255:              				switch(Vrms_Level)
256:              				{
257:              					case VRMS_LEVEL_175:  Heat_Time_Select(16, 4);   break;
258:              					case VRMS_LEVEL_198:  Heat_Time_Select(12, 8);   break;
259:              					case VRMS_LEVEL_220:  Heat_Time_Select(10,10);   break;
260:              					case VRMS_LEVEL_242:  Heat_Time_Select(8, 12);   break;
261:              					default:              Heat_Time_Select(10,10);   break;					
262:              				}
263:              			}								
264:              			break;
265:              		default: BotHeatOff(); break;	
266:              	}
267:              } 
268:              
269:              /*****************************************************************
270:               @fun:      PressureHeat
271:               @brief:    压力功能
272:               @param:    None                             
273:               @retval:   None
274:              *****************************************************************/
275:              void PressureHeat(void)
276:              {
277:              	//压力开关断开进入保压
278:              	if((b_PressureOn == TRUE) && WorkStage != WORK_COUNTDOWN_STAGE) 
  09B9    1EF2    SNZB	0x72,5
  09BA    29C9    JP	0x1C9
  09BB    3003    LDIA	0x3
  09BC    063F    XORA	0x3F
  09BD    1903    SZB	0x3,2
  09BE    29C9    JP	0x1C9
279:              	{
280:              		WorkStage = WORK_COUNTDOWN_STAGE;
  09BF    3003    LDIA	0x3
  09C0    00BF    LD	0x3F,A
281:              		WorkStep = 5;
  09C1    3005    LDIA	0x5
  09C2    00C2    LD	0x42,A
282:              		ShortTimeOn();	//重新计时
  09C3    2363    CALL	0x363
  09C4    120A    CLRB	0xA,4
  09C5    158A    SETB	0xA,3
283:              		//计算烹饪总时间
284:              		TotalTimeSave = WorkTimeM + CountDownTime;
  09C6    0840    LD	A,0x40
  09C7    073D    ADDA	0x3D
  09C8    00BE    LD	0x3E,A
285:              	}	
286:              	//145C限温后直接进入待机
287:              	if(Ad_Bot >= BOT_TEMP_145)
  09C9    30D5    LDIA	0xD5
  09CA    024F    SUBA	0x4F
  09CB    1C03    SNZB	0x3,0
  09CC    2A63    JP	0x263
288:              	{
289:              		BotHeatOff();
  09CD    2367    CALL	0x367
  09CE    120A    CLRB	0xA,4
  09CF    158A    SETB	0xA,3
290:              		Cancel();
  09D0    2577    CALL	0x577
  09D1    120A    CLRB	0xA,4
  09D2    158A    SETB	0xA,3
291:              		FINISH_SOUND;
  09D3    3005    LDIA	0x5
  09D4    1283    CLRB	0x3,5
  09D5    00D7    LD	0x57,A
  09D6    3019    LDIA	0x19
  09D7    2F88    JP	0x788
292:              		return;	
293:              	}
294:              	//压力功能烹饪流程
295:              	switch(WorkStep)
296:              	{
297:              		case 0:
298:              		    //全功率加热至95度               
299:              			if(Ad_Bot >= BOT_TEMP_95)
  09D8    3091    LDIA	0x91
  09D9    024F    SUBA	0x4F
  09DA    1C03    SNZB	0x3,0
  09DB    29E2    JP	0x1E2
300:              			{
301:              				BotHeatOff();	
  09DC    2367    CALL	0x367
  09DD    120A    CLRB	0xA,4
  09DE    158A    SETB	0xA,3
302:              				ShortTimeOn(); 							
303:              				WorkStep++;
  09E0    0AC2    INCR	0x42
304:              				break;
  09E1    0008    RET
305:              			}
306:              			BotHeatOn();	
  09E2    2B6C    JP	0x36C
307:              			break;
308:              		case 1 : 
309:              		    //停功率2分钟  
310:              			if(ShortCntM >= 2)
  09E3    3002    LDIA	0x2
  09E4    0243    SUBA	0x43
  09E5    1803    SZB	0x3,0
  09E6    29DF    JP	0x1DF
311:              			{
312:              				ShortTimeOn();	
  09DF    2363    CALL	0x363
313:              				WorkStep++;	
314:              				break;
315:              			}
316:              			BotHeatOff();										
  09E7    2B67    JP	0x367
317:              			break;
318:              		case 2: 
319:              			if(Ad_Bot >= BOT_TEMP_120)       //第一个间歇温度点120C
  09E8    30BA    LDIA	0xBA
  09E9    024F    SUBA	0x4F
  09EA    1C03    SNZB	0x3,0
  09EB    29E2    JP	0x1E2
320:              			{
321:              				ShortTimeOn(); 				
  09EC    2363    CALL	0x363
  09ED    120A    CLRB	0xA,4
  09EE    158A    SETB	0xA,3
322:              				BotHeatOff();
  09EF    2367    CALL	0x367
  09F0    120A    CLRB	0xA,4
  09F1    158A    SETB	0xA,3
  09F2    29E0    JP	0x1E0
323:              				WorkStep++;
324:              				break;
325:              			}
326:              			BotHeatOn();       							
327:              			break;
328:              		case 3:	
329:              			if(Ad_Bot <= BOT_TEMP_118)        //恢复全功率
  09F3    30B8    LDIA	0xB8
  09F4    024F    SUBA	0x4F
  09F5    1803    SZB	0x3,0
  09F6    29FB    JP	0x1FB
330:              			{
331:              				ShortTimeOn();	
  09F7    2363    CALL	0x363
332:              				WorkStep = 2;
  09F8    3002    LDIA	0x2
  09F9    00C2    LD	0x42,A
333:              				break;	
  09FA    0008    RET
334:              			}
335:              		
336:              			if(Ad_Bot >= BOT_TEMP_128)       //第二个间歇温度点128C
  09FB    30C5    LDIA	0xC5
  09FC    024F    SUBA	0x4F
  09FD    1803    SZB	0x3,0
  09FE    29EC    JP	0x1EC
  09FF    0869    LD	A,0x69
  0A00    3A01    XORIA	0x1
  0A01    1903    SZB	0x3,2
  0A02    29E2    JP	0x1E2
  0A03    3A03    XORIA	0x3
  0A04    1903    SZB	0x3,2
  0A05    2A0D    JP	0x20D
  0A06    3A01    XORIA	0x1
  0A07    1903    SZB	0x3,2
  0A08    2A11    JP	0x211
  0A09    3A07    XORIA	0x7
  0A0A    1903    SZB	0x3,2
  0A0B    2A15    JP	0x215
  0A0C    2A19    JP	0x219
  0A0D    3003    LDIA	0x3
  0A0E    00DA    LD	0x5A,A
  0A0F    3011    LDIA	0x11
  0A10    2B4B    JP	0x34B
  0A11    3006    LDIA	0x6
  0A12    00DA    LD	0x5A,A
  0A13    300E    LDIA	0xE
  0A14    2B4B    JP	0x34B
  0A15    3008    LDIA	0x8
  0A16    00DA    LD	0x5A,A
  0A17    300C    LDIA	0xC
  0A18    2B4B    JP	0x34B
  0A19    3006    LDIA	0x6
  0A1A    00DA    LD	0x5A,A
  0A1B    300E    LDIA	0xE
  0A1C    2B4B    JP	0x34B
337:              			{
338:              				ShortTimeOn(); 				
339:              				BotHeatOff();
340:              				WorkStep++;
341:              				break;
342:              			}
343:              			/*第一间歇温度点
344:              			根据电压档位选择不同加热比例 等效700W*/
345:              			switch(Vrms_Level)
346:              			{
347:              				case VRMS_LEVEL_175:  BotHeatOn();               break;
348:              				case VRMS_LEVEL_198:  Heat_Time_Select(17, 3);   break;
349:              				case VRMS_LEVEL_220:  Heat_Time_Select(14, 6);   break;
350:              				case VRMS_LEVEL_242:  Heat_Time_Select(12, 8);   break;
351:              				default:              Heat_Time_Select(14, 6);   break;					
352:              			}		
353:              			break;
354:              		case 4:
355:              			if(Ad_Bot <= BOT_TEMP_125)       //回到上一步
  0A1D    30C2    LDIA	0xC2
  0A1E    024F    SUBA	0x4F
  0A1F    1803    SZB	0x3,0
  0A20    2A3A    JP	0x23A
356:              			{
357:              				ShortTimeOn(); 				
  0A21    2363    CALL	0x363
  0A22    120A    CLRB	0xA,4
  0A23    158A    SETB	0xA,3
358:              				BotHeatOff();
  0A24    2367    CALL	0x367
359:              				WorkStep = 3;
  0A25    3003    LDIA	0x3
  0A26    00C2    LD	0x42,A
360:              				break;
  0A27    0008    RET
  0A28    3004    LDIA	0x4
  0A29    00DA    LD	0x5A,A
  0A2A    3010    LDIA	0x10
  0A2B    2B4B    JP	0x34B
  0A2C    3008    LDIA	0x8
  0A2D    00DA    LD	0x5A,A
  0A2E    300C    LDIA	0xC
  0A2F    2B4B    JP	0x34B
  0A30    300A    LDIA	0xA
  0A31    00DA    LD	0x5A,A
  0A32    2B4B    JP	0x34B
  0A33    300C    LDIA	0xC
  0A34    00DA    LD	0x5A,A
  0A35    3008    LDIA	0x8
  0A36    2B4B    JP	0x34B
  0A37    300A    LDIA	0xA
  0A38    00DA    LD	0x5A,A
  0A39    2B4B    JP	0x34B
  0A3A    0869    LD	A,0x69
  0A3B    3A01    XORIA	0x1
  0A3C    1903    SZB	0x3,2
  0A3D    2A28    JP	0x228
  0A3E    3A03    XORIA	0x3
  0A3F    1903    SZB	0x3,2
  0A40    2A2C    JP	0x22C
  0A41    3A01    XORIA	0x1
  0A42    1903    SZB	0x3,2
  0A43    2A30    JP	0x230
  0A44    3A07    XORIA	0x7
  0A45    1903    SZB	0x3,2
  0A46    2A33    JP	0x233
  0A47    2A37    JP	0x237
361:              			}
362:              			/*第二间歇温度点
363:              			根据电压档位选择不同加热比例 等效500W*/
364:              			switch(Vrms_Level)
365:              			{
366:              				case VRMS_LEVEL_175:  Heat_Time_Select(16, 4);   break;
367:              				case VRMS_LEVEL_198:  Heat_Time_Select(12, 8);   break;
368:              				case VRMS_LEVEL_220:  Heat_Time_Select(10,10);   break;
369:              				case VRMS_LEVEL_242:  Heat_Time_Select(8, 12);   break;
370:              				default:              Heat_Time_Select(10,10);   break;					
371:              			}	 				
372:              			break;
373:              		case 5:       //保压阶段		
374:              			/*粥类藏8分钟*/
375:              			if(ChooseFun == FUN_PORRIDGE || ChooseFun == FUN_CONGEE || ChooseFun == FUN_EIGHTCONGEE)
  0A48    3003    LDIA	0x3
  0A49    063C    XORA	0x3C
  0A4A    1903    SZB	0x3,2
  0A4B    2A54    JP	0x254
  0A4C    3004    LDIA	0x4
  0A4D    063C    XORA	0x3C
  0A4E    3009    LDIA	0x9
  0A4F    1903    SZB	0x3,2
  0A50    2A55    JP	0x255
  0A51    063C    XORA	0x3C
  0A52    1D03    SNZB	0x3,2
  0A53    2A58    JP	0x258
376:              			{				
377:              				if(CountDownTime <= 8)	
  0A54    3009    LDIA	0x9
  0A55    0240    SUBA	0x40
  0A56    1C03    SNZB	0x3,0
  0A57    29E7    JP	0x1E7
378:              				{
379:              					BotHeatOff();
380:              					break;		
381:              				}	
382:              			}		          
383:              			//控制底部温度范围118-115    //压力开关断开,关闭继电器			
384:              			if(b_PressureOn == 1 || Ad_Bot >= BOT_TEMP_118)	 
  0A58    1AF2    SZB	0x72,5
  0A59    29E7    JP	0x1E7
  0A5A    30B7    LDIA	0xB7
  0A5B    024F    SUBA	0x4F
  0A5C    1803    SZB	0x3,0
  0A5D    29E7    JP	0x1E7
385:              			{
386:              				BotHeatOff();	
387:              			}  	
388:              			else if(Ad_Bot <= BOT_TEMP_115)       
  0A5E    30B4    LDIA	0xB4
  0A5F    024F    SUBA	0x4F
  0A60    1803    SZB	0x3,0
  0A61    0008    RET
  0A62    29E2    JP	0x1E2
  0A63    0842    LD	A,0x42
  0A64    3A00    XORIA	0x0
  0A65    1903    SZB	0x3,2
  0A66    29D8    JP	0x1D8
  0A67    3A01    XORIA	0x1
  0A68    1903    SZB	0x3,2
  0A69    29E3    JP	0x1E3
  0A6A    3A03    XORIA	0x3
  0A6B    1903    SZB	0x3,2
  0A6C    29E8    JP	0x1E8
  0A6D    3A01    XORIA	0x1
  0A6E    1903    SZB	0x3,2
  0A6F    29F3    JP	0x1F3
  0A70    3A07    XORIA	0x7
  0A71    1903    SZB	0x3,2
  0A72    2A1D    JP	0x21D
  0A73    3A01    XORIA	0x1
  0A74    1903    SZB	0x3,2
  0A75    2A48    JP	0x248
  0A76    29E7    JP	0x1E7
  0A77    0008    RET
389:              			{
390:              				BotHeatOn(); 	
391:              			}				
392:              			break;	
393:              		default: BotHeatOff();	break; 			
394:              	}		
395:              }
396:              
397:              /*****************************************************************
398:               @fun:      OpenCook
399:               @brief:    开盖煮
400:               @param:    None                             
401:               @retval:   None
402:              *****************************************************************/
403:              void OpenCook(void)
404:              {
405:              	if((b_PressureOn || WorkTimeM >= 30) && WorkStage != WORK_COUNTDOWN_STAGE)	
  0952    1AF2    SZB	0x72,5
  0953    2958    JP	0x158
  0954    301E    LDIA	0x1E
  0955    023D    SUBA	0x3D
  0956    1C03    SNZB	0x3,0
  0957    29AD    JP	0x1AD
  0958    3003    LDIA	0x3
  0959    063F    XORA	0x3F
  095A    1903    SZB	0x3,2
  095B    29AD    JP	0x1AD
406:              	{
407:              		WorkStage = WORK_COUNTDOWN_STAGE;		
  095C    3003    LDIA	0x3
  095D    00BF    LD	0x3F,A
408:              		WorkStep = 2;
  095E    3002    LDIA	0x2
  095F    00C2    LD	0x42,A
409:              		ShortTimeOn();	//重新计时
  0960    2363    CALL	0x363
  0961    120A    CLRB	0xA,4
  0962    158A    SETB	0xA,3
  0963    29AD    JP	0x1AD
410:              		//计算烹饪总时间
411:              		//TotalTimeSave = WorkTimeM + CountDownTime;
412:              	}
413:              	switch(WorkStep)
414:              	{
415:              		case 0:  
416:              			if(Ad_Bot >= BOT_TEMP_105)
  0964    30A3    LDIA	0xA3
  0965    024F    SUBA	0x4F
  0966    1C03    SNZB	0x3,0
  0967    296F    JP	0x16F
417:              			{
418:              				BotHeatOff();
  0968    2367    CALL	0x367
  0969    120A    CLRB	0xA,4
  096A    158A    SETB	0xA,3
419:              				ShortTimeOn(); 
  096B    2363    CALL	0x363
420:              				WorkStep++;
  096C    0AC2    INCR	0x42
421:              				b_Opencook_OK = 0;
  096D    10F1    CLRB	0x71,1
422:              				break;
  096E    0008    RET
423:              			}
424:              			BotHeatOn();			
  096F    2B6C    JP	0x36C
425:              			break;
426:              		case 1:			
427:              			if(ShortCntM >= 5 || Ad_Bot >= BOT_TEMP_135)                     
  0970    3005    LDIA	0x5
  0971    0243    SUBA	0x43
  0972    1803    SZB	0x3,0
  0973    2978    JP	0x178
  0974    30CC    LDIA	0xCC
  0975    024F    SUBA	0x4F
  0976    1C03    SNZB	0x3,0
  0977    2983    JP	0x183
428:              			{
429:              				WorkStage = WORK_COUNTDOWN_STAGE;
  0978    3003    LDIA	0x3
  0979    00BF    LD	0x3F,A
430:              				BotHeatOff();
  097A    2367    CALL	0x367
  097B    120A    CLRB	0xA,4
  097C    158A    SETB	0xA,3
431:              				ShortTimeOn();				 
  097D    2363    CALL	0x363
432:              				WorkStep++;
  097E    0AC2    INCR	0x42
433:              				//计算烹饪总时间
434:              		        TotalTimeSave = WorkTimeM + CountDownTime;
  097F    0840    LD	A,0x40
  0980    073D    ADDA	0x3D
  0981    00BE    LD	0x3E,A
435:              				break;				
  0982    0008    RET
436:              			}
437:              			Heat_Time_Select(24, 6);     //800W		
  0983    3006    LDIA	0x6
  0984    00DA    LD	0x5A,A
  0985    3018    LDIA	0x18
  0986    2B4B    JP	0x34B
438:              			break;
439:              		case 2: 
440:              		    //压力到达      
441:              			if(b_PressureOn)
  0987    1EF2    SNZB	0x72,5
  0988    298A    JP	0x18A
442:              			{
443:              				BotHeatOff();
  0989    2B67    JP	0x367
444:              				break;
445:              			}
446:              			//限温标志
447:              			if(b_Opencook_OK == 0 && Ad_Bot >= BOT_TEMP_135)
  098A    18F1    SZB	0x71,1
  098B    2993    JP	0x193
  098C    30CC    LDIA	0xCC
  098D    024F    SUBA	0x4F
  098E    1C03    SNZB	0x3,0
  098F    2993    JP	0x193
448:              			{
449:              				BotHeatOff();
  0990    2367    CALL	0x367
450:              				b_Opencook_OK = 1;             //到达限温标志
  0991    14F1    SETB	0x71,1
451:              				break;
  0992    0008    RET
452:              			}
453:              			//到过限温控制温度110-115
454:              			if(b_Opencook_OK)
  0993    1CF1    SNZB	0x71,1
  0994    29A0    JP	0x1A0
455:              			{
456:              				if(Ad_Bot >= BOT_TEMP_115)
  0995    30B3    LDIA	0xB3
  0996    024F    SUBA	0x4F
  0997    1803    SZB	0x3,0
  0998    2989    JP	0x189
457:              				{
458:              		  			BotHeatOff(); 
459:              				}
460:              				else if(Ad_Bot <= BOT_TEMP_110)
  0999    30AC    LDIA	0xAC
  099A    024F    SUBA	0x4F
  099B    1803    SZB	0x3,0
  099C    0008    RET
461:              				{
462:              					Heat_Time_Select(15, 15);     //500W
  099D    300F    LDIA	0xF
  099E    00DA    LD	0x5A,A
  099F    2B4B    JP	0x34B
463:              				}								
464:              			}
465:              			else
466:              			{
467:              				//没到过限温
468:              				if(Ad_Bot >= BOT_TEMP_115)
  09A0    30B3    LDIA	0xB3
  09A1    024F    SUBA	0x4F
  09A2    1C03    SNZB	0x3,0
  09A3    29A8    JP	0x1A8
469:              				{
470:              					Heat_Time_Select(24, 6);     //800W	    
  09A4    3006    LDIA	0x6
  09A5    00DA    LD	0x5A,A
  09A6    3018    LDIA	0x18
  09A7    2B4B    JP	0x34B
471:              				}
472:              				else if(Ad_Bot <= BOT_TEMP_110)
  09A8    30AC    LDIA	0xAC
  09A9    024F    SUBA	0x4F
  09AA    1803    SZB	0x3,0
  09AB    0008    RET
  09AC    296F    JP	0x16F
473:              				{
474:              					BotHeatOn(); 	
475:              				}				
476:              			}
477:              			break;
  09AD    0842    LD	A,0x42
  09AE    3A00    XORIA	0x0
  09AF    1903    SZB	0x3,2
  09B0    2964    JP	0x164
  09B1    3A01    XORIA	0x1
  09B2    1903    SZB	0x3,2
  09B3    2970    JP	0x170
  09B4    3A03    XORIA	0x3
  09B5    1903    SZB	0x3,2
  09B6    2987    JP	0x187
  09B7    2989    JP	0x189
  09B8    0008    RET
478:              		default: BotHeatOff(); break;
479:              	}	
480:              }
481:              
482:              
483:              
484:              
485:              /*****************************************************************
486:               @fun:      CakeHeat
487:               @brief:    蛋糕
488:               @param:    None                             
489:               @retval:   None
490:              *****************************************************************/
491:              void CakeHeat(void)
492:              {
493:              	if(((WorkTimeM >= 30) || Ad_Bot >= BOT_TEMP_135 || b_PressureOn) && WorkStage != WORK_COUNTDOWN_STAGE)
  08DD    301E    LDIA	0x1E
  08DE    023D    SUBA	0x3D
  08DF    1803    SZB	0x3,0
  08E0    28E7    JP	0xE7
  08E1    30CC    LDIA	0xCC
  08E2    024F    SUBA	0x4F
  08E3    1803    SZB	0x3,0
  08E4    28E7    JP	0xE7
  08E5    1EF2    SNZB	0x72,5
  08E6    28F4    JP	0xF4
  08E7    3003    LDIA	0x3
  08E8    063F    XORA	0x3F
  08E9    1903    SZB	0x3,2
  08EA    28F4    JP	0xF4
494:              	{
495:              		WorkStage = WORK_COUNTDOWN_STAGE;
  08EB    3003    LDIA	0x3
  08EC    00BF    LD	0x3F,A
496:              		WorkStep = 3;	                //进入保压加热方式
  08ED    00C2    LD	0x42,A
497:              		ShortTimeOn();	                //重新计时
  08EE    2363    CALL	0x363
  08EF    120A    CLRB	0xA,4
  08F0    158A    SETB	0xA,3
498:              		//计算烹饪总时间
499:              		TotalTimeSave = WorkTimeM + CountDownTime;
  08F1    0840    LD	A,0x40
  08F2    073D    ADDA	0x3D
  08F3    00BE    LD	0x3E,A
  08F4    0842    LD	A,0x42
  08F5    3A00    XORIA	0x0
  08F6    1903    SZB	0x3,2
  08F7    2903    JP	0x103
  08F8    3A01    XORIA	0x1
  08F9    1903    SZB	0x3,2
  08FA    2906    JP	0x106
  08FB    3A03    XORIA	0x3
  08FC    1903    SZB	0x3,2
  08FD    2913    JP	0x113
  08FE    3A01    XORIA	0x1
  08FF    1903    SZB	0x3,2
  0900    293B    JP	0x13B
  0901    2941    JP	0x141
  0902    0008    RET
500:              	}
501:              	switch(WorkStep)
502:              	{
503:              		case 0:  
504:              			ShortTimeOn(); 
  0903    2363    CALL	0x363
505:              			WorkStep++;							
  0904    0AC2    INCR	0x42
506:              			break;			
  0905    0008    RET
507:              		case 1:  
508:              			if(Ad_Bot >= BOT_TEMP_100 || ShortCntM >= 15)
  0906    309A    LDIA	0x9A
  0907    024F    SUBA	0x4F
  0908    1803    SZB	0x3,0
  0909    290E    JP	0x10E
  090A    300F    LDIA	0xF
  090B    0243    SUBA	0x43
  090C    1C03    SNZB	0x3,0
  090D    2912    JP	0x112
509:              			{
510:              				BotHeatOff();
  090E    2367    CALL	0x367
  090F    120A    CLRB	0xA,4
  0910    158A    SETB	0xA,3
  0911    2903    JP	0x103
511:              				ShortTimeOn(); 
512:              				WorkStep++;	
513:              				break;
514:              			}
515:              			BotHeatOn();			
  0912    2B6C    JP	0x36C
516:              			break;		
517:              		case 2:
518:              			if(Ad_Bot >= BOT_TEMP_135 || ShortCntM >= 15)
  0913    30CC    LDIA	0xCC
  0914    024F    SUBA	0x4F
  0915    1803    SZB	0x3,0
  0916    291B    JP	0x11B
  0917    300F    LDIA	0xF
  0918    0243    SUBA	0x43
  0919    1C03    SNZB	0x3,0
  091A    2923    JP	0x123
519:              			{ 
520:              				WorkStage = WORK_COUNTDOWN_STAGE;
  091B    3003    LDIA	0x3
  091C    00BF    LD	0x3F,A
521:              				WorkStep++;
  091D    0AC2    INCR	0x42
522:              				BotHeatOff();
  091E    2367    CALL	0x367
523:              				//计算烹饪总时间
524:              				TotalTimeSave = WorkTimeM + CountDownTime;
  091F    0840    LD	A,0x40
  0920    073D    ADDA	0x3D
  0921    00BE    LD	0x3E,A
525:              				break;
  0922    0008    RET
526:              			}
527:              			if(Ad_Bot <= BOT_TEMP_120)
  0923    30BB    LDIA	0xBB
  0924    024F    SUBA	0x4F
  0925    1803    SZB	0x3,0
  0926    292B    JP	0x12B
528:              			{
529:              				Heat_Time_Select(12, 8);		//600W 
  0927    3008    LDIA	0x8
  0928    00DA    LD	0x5A,A
  0929    300C    LDIA	0xC
  092A    2B4B    JP	0x34B
530:              			}
531:              			else if(Ad_Bot <= BOT_TEMP_128)
  092B    30C6    LDIA	0xC6
  092C    024F    SUBA	0x4F
  092D    1803    SZB	0x3,0
  092E    2933    JP	0x133
532:              			{
533:              				Heat_Time_Select(7, 13);		//350W
  092F    300D    LDIA	0xD
  0930    00DA    LD	0x5A,A
  0931    3007    LDIA	0x7
  0932    2B4B    JP	0x34B
534:              			}
535:              			else if(Ad_Bot <= BOT_TEMP_135)
  0933    30CD    LDIA	0xCD
  0934    024F    SUBA	0x4F
  0935    1803    SZB	0x3,0
  0936    0008    RET
536:              			{
537:              				Heat_Time_Select(5, 15);		//250W
  0937    300F    LDIA	0xF
  0938    00DA    LD	0x5A,A
  0939    3005    LDIA	0x5
  093A    2B4B    JP	0x34B
538:              			}
539:              			break;			
540:              		case 3:		
541:              			if(b_PressureOn || Ad_Bot >= BOT_TEMP_132)
  093B    1AF2    SZB	0x72,5
  093C    2941    JP	0x141
  093D    30C9    LDIA	0xC9
  093E    024F    SUBA	0x4F
  093F    1C03    SNZB	0x3,0
  0940    2942    JP	0x142
542:              			{
543:              				BotHeatOff();
  0941    2B67    JP	0x367
544:              			}
545:              			else if(Ad_Bot <= BOT_TEMP_120)
  0942    30BB    LDIA	0xBB
  0943    024F    SUBA	0x4F
  0944    1803    SZB	0x3,0
  0945    294A    JP	0x14A
546:              			{
547:              				Heat_Time_Select(7, 13);		//350W
  0946    300D    LDIA	0xD
  0947    00DA    LD	0x5A,A
  0948    3007    LDIA	0x7
  0949    2B4B    JP	0x34B
548:              			}
549:              			else if(Ad_Bot <= BOT_TEMP_128)
  094A    30C6    LDIA	0xC6
  094B    024F    SUBA	0x4F
  094C    1803    SZB	0x3,0
  094D    0008    RET
550:              			{
551:              				Heat_Time_Select(5, 15);		//250W
  094E    300F    LDIA	0xF
  094F    00DA    LD	0x5A,A
  0950    3005    LDIA	0x5
  0951    2B4B    JP	0x34B
552:              			}
553:              			break;			
554:              		default: BotHeatOff(); break;
555:              	}	
556:              }
557:              /*****************************************************************
558:               @fun:      ReheatCook
559:               @brief:    冷食加热
560:               @param:    None                             
561:               @retval:   None
562:              *****************************************************************/
563:              void ReheatCook(void)
564:              {
565:              	if((b_PressureOn || WorkTimeM >= 30) && WorkStage != WORK_COUNTDOWN_STAGE)	
  088C    1AF2    SZB	0x72,5
  088D    2892    JP	0x92
  088E    301E    LDIA	0x1E
  088F    023D    SUBA	0x3D
  0890    1C03    SNZB	0x3,0
  0891    289D    JP	0x9D
  0892    3003    LDIA	0x3
  0893    063F    XORA	0x3F
  0894    1903    SZB	0x3,2
  0895    289D    JP	0x9D
566:              	{
567:              		WorkStage = WORK_COUNTDOWN_STAGE;		
  0896    3003    LDIA	0x3
  0897    00BF    LD	0x3F,A
568:              		WorkStep = 2;
  0898    3002    LDIA	0x2
  0899    00C2    LD	0x42,A
569:              		ShortTimeOn();	//重新计时
  089A    2363    CALL	0x363
  089B    120A    CLRB	0xA,4
  089C    158A    SETB	0xA,3
  089D    0842    LD	A,0x42
  089E    3A00    XORIA	0x0
  089F    1903    SZB	0x3,2
  08A0    28A9    JP	0xA9
  08A1    3A01    XORIA	0x1
  08A2    1903    SZB	0x3,2
  08A3    28B4    JP	0xB4
  08A4    3A03    XORIA	0x3
  08A5    1903    SZB	0x3,2
  08A6    28CF    JP	0xCF
  08A7    28BB    JP	0xBB
  08A8    0008    RET
570:              	}
571:              	
572:              	switch(WorkStep)
573:              	{			
574:              		case 0 :  
575:              			if(Ad_Bot >= BOT_TEMP_105)
  08A9    30A3    LDIA	0xA3
  08AA    024F    SUBA	0x4F
  08AB    1C03    SNZB	0x3,0
  08AC    28B3    JP	0xB3
576:              			{
577:              				BotHeatOff();
  08AD    2367    CALL	0x367
  08AE    120A    CLRB	0xA,4
  08AF    158A    SETB	0xA,3
578:              				ShortTimeOn(); 
  08B0    2363    CALL	0x363
579:              				WorkStep++;	
  08B1    0AC2    INCR	0x42
580:              				break;
  08B2    0008    RET
581:              			}
582:              			BotHeatOn();			
  08B3    2B6C    JP	0x36C
583:              			break;
584:              			
585:              		case 1 :
586:              			if(ShortCntM==0 && ShortCntL< 30)	 //缓冲15S
  08B4    0843    LD	A,0x43
  08B5    1D03    SNZB	0x3,2
  08B6    28BC    JP	0xBC
  08B7    301E    LDIA	0x1E
  08B8    0244    SUBA	0x44
  08B9    1803    SZB	0x3,0
  08BA    28BC    JP	0xBC
587:              			{
588:              				BotHeatOff();
  08BB    2B67    JP	0x367
589:              				break;	
590:              			}
591:              			
592:              			if(ShortCntM >= 5)                     
  08BC    3005    LDIA	0x5
  08BD    0243    SUBA	0x43
  08BE    1C03    SNZB	0x3,0
  08BF    28C3    JP	0xC3
593:              			{
594:              				WorkStage = WORK_COUNTDOWN_STAGE;
  08C0    3003    LDIA	0x3
  08C1    00BF    LD	0x3F,A
  08C2    28AD    JP	0xAD
595:              				BotHeatOff();
596:              				ShortTimeOn();				 
597:              				WorkStep++;
598:              				break;				
599:              			}
600:              			
601:              			if(Ad_Bot>BOT_TEMP_116)
  08C3    30B5    LDIA	0xB5
  08C4    024F    SUBA	0x4F
  08C5    1803    SZB	0x3,0
  08C6    28BB    JP	0xBB
602:              			{
603:              				BotHeatOff();
604:              				break;				
605:              			}
606:              			if(Ad_Bot<=BOT_TEMP_114)
  08C7    30B2    LDIA	0xB2
  08C8    024F    SUBA	0x4F
  08C9    1803    SZB	0x3,0
  08CA    0008    RET
607:              			{
608:              				Heat_Time_Select(24, 6);     //800W			
  08CB    3006    LDIA	0x6
  08CC    00DA    LD	0x5A,A
  08CD    3018    LDIA	0x18
  08CE    2B4B    JP	0x34B
609:              			}					
610:              			break;
611:              			
612:              		case 2 :       
613:              			//控制底部温度范围118-115    //压力开关断开,关闭继电器			
614:              			if(b_PressureOn == 1 || Ad_Bot >= BOT_TEMP_116)	 
  08CF    1AF2    SZB	0x72,5
  08D0    28BB    JP	0xBB
  08D1    30B4    LDIA	0xB4
  08D2    024F    SUBA	0x4F
  08D3    1803    SZB	0x3,0
  08D4    28BB    JP	0xBB
615:              			{
616:              				BotHeatOff();	
617:              			}  	
618:              			else if(Ad_Bot <= BOT_TEMP_114)       
  08D5    30B2    LDIA	0xB2
  08D6    024F    SUBA	0x4F
  08D7    1803    SZB	0x3,0
  08D8    0008    RET
619:              			{
620:              				Heat_Time_Select(8, 10);     //330W	
  08D9    300A    LDIA	0xA
  08DA    00DA    LD	0x5A,A
  08DB    3008    LDIA	0x8
  08DC    2B4B    JP	0x34B
621:              			}
622:              			break;
623:              			
624:              		default: BotHeatOff(); break;
625:              	}	
626:              }
627:              
628:              /*****************************************************************
629:               @fun:      KeepWarmHeat
630:               @brief:    保温加热
631:               @param:    None                             
632:               @retval:   None
633:              *****************************************************************/
634:              void KeepWarmHeat(void)
635:              {
636:              	if(b_PressureOn == 1 || Ad_Bot >= BOT_TEMP_68)
  0800    1AF2    SZB	0x72,5
  0801    2807    JP	0x7
  0802    3059    LDIA	0x59
  0803    1283    CLRB	0x3,5
  0804    024F    SUBA	0x4F
  0805    1C03    SNZB	0x3,0
  0806    2808    JP	0x8
637:              	{
638:              		BotHeatOff();
  0807    2B67    JP	0x367
639:              	}		
640:              	else if(Ad_Bot <= BOT_TEMP_63)
  0808    3051    LDIA	0x51
  0809    024F    SUBA	0x4F
  080A    1803    SZB	0x3,0
  080B    0008    RET
641:              	{
642:              		if(Ad_Bot >= BOT_TEMP_58)	
  080C    3046    LDIA	0x46
  080D    024F    SUBA	0x4F
  080E    1C03    SNZB	0x3,0
  080F    2814    JP	0x14
643:              		{
644:              			Heat_Time_Select(10, 22);       
  0810    3016    LDIA	0x16
  0811    00DA    LD	0x5A,A
  0812    300A    LDIA	0xA
  0813    2B4B    JP	0x34B
645:              		}
646:              		else if(Ad_Bot <= BOT_TEMP_55)	
  0814    3042    LDIA	0x42
  0815    024F    SUBA	0x4F
  0816    1803    SZB	0x3,0
  0817    0008    RET
647:              		{
648:              			BotHeatOn();          
  0818    2B6C    JP	0x36C
649:              		}						
650:              	}	
651:              } 
652:              /*****************************************************************
653:               @fun:      Cook_Task
654:               @brief:    烹饪函数，主函数8ms调用
655:               @param:    None                             
656:               @retval:   None
657:              *****************************************************************/
658:              void Cook_Task(void)
659:              {
660:              	//故障报警暂停不加热
661:              	if(ErrorCode != NO_ERROR)      
  0841    1283    CLRB	0x3,5
  0842    0858    LD	A,0x58
  0843    1903    SZB	0x3,2
  0844    2846    JP	0x46
662:              	{					
663:              		BotHeatOff();
  0845    2B67    JP	0x367
664:              		return;
665:              	}
666:              
667:              	//工作或保温中E3报警条件满足打开继电器  A005
668:              	if((SysStatus == WORK_MODE || SysStatus == KEEP_WARM_MODE) && Ad_Bot <= BOT_TEMP_80 && b_PressureOn == TRUE)
  0846    3003    LDIA	0x3
  0847    066A    XORA	0x6A
  0848    1903    SZB	0x3,2
  0849    284E    JP	0x4E
  084A    3004    LDIA	0x4
  084B    066A    XORA	0x6A
  084C    1D03    SNZB	0x3,2
  084D    2880    JP	0x80
  084E    3073    LDIA	0x73
  084F    024F    SUBA	0x4F
  0850    1C03    SNZB	0x3,0
  0851    1EF2    SNZB	0x72,5
  0852    2880    JP	0x80
669:              	{
670:              		BotHeatOn();
  0853    2B6C    JP	0x36C
671:              		return;	
672:              	}
673:              	
674:              	switch(SysStatus)
675:              	{
676:              		case FACTORY_TEST_MODE:    
677:              			//工厂模式加热			
678:              			if(FactoryTestData == FACTORY_TEST_START || FactoryTestData == FACTORY_TEST_COUNT)
  0854    3013    LDIA	0x13
  0855    0641    XORA	0x41
  0856    1903    SZB	0x3,2
  0857    285C    JP	0x5C
  0858    3014    LDIA	0x14
  0859    0641    XORA	0x41
  085A    1D03    SNZB	0x3,2
  085B    2845    JP	0x45
679:              			{
680:              				FactoryTest(); 		
  085C    2819    JP	0x19
681:              			}
682:              			else
683:              			{
684:              				BotHeatOff();	
685:              			}			
686:              			break;            
687:              		case WORK_MODE:
688:              			//加热、保压、中途加料
689:              			if(WorkStage == WORK_HEAT_STAGE || WorkStage == WORK_COUNTDOWN_STAGE )		
  085D    3002    LDIA	0x2
  085E    063F    XORA	0x3F
  085F    1903    SZB	0x3,2
  0860    2865    JP	0x65
  0861    3003    LDIA	0x3
  0862    063F    XORA	0x3F
  0863    1D03    SNZB	0x3,2
  0864    2845    JP	0x45
690:              			{
691:              				if(ChooseFun == FUN_RICE || ChooseFun == FUN_MIXRICE)
  0865    033C    DECA	0x3C
  0866    1903    SZB	0x3,2
  0867    286C    JP	0x6C
  0868    3002    LDIA	0x2
  0869    063C    XORA	0x3C
  086A    1D03    SNZB	0x3,2
  086B    286D    JP	0x6D
692:              				{
693:              					RiceHeat();	  //米饭类
  086C    2A78    JP	0x278
694:              				}
695:              				else if(ChooseFun == FUN_OPENEHEAT)	
  086D    300E    LDIA	0xE
  086E    063C    XORA	0x3C
  086F    1D03    SNZB	0x3,2
  0870    2874    JP	0x74
696:              				{	
697:              					WorkStep = 2;  //倒计时
  0871    3002    LDIA	0x2
  0872    00C2    LD	0x42,A
698:              					OpenCook();	  //开盖收汁
  0873    2952    JP	0x152
699:              				}
700:              				else if(ChooseFun == FUN_FASTHEAT)	
  0874    300D    LDIA	0xD
  0875    063C    XORA	0x3C
  0876    1D03    SNZB	0x3,2
  0877    2879    JP	0x79
701:              				{
702:              					ReheatCook();	  //蛋糕
  0878    288C    JP	0x8C
703:              				}
704:              				else if(ChooseFun == FUN_CAKE)	
  0879    300C    LDIA	0xC
  087A    063C    XORA	0x3C
  087B    1D03    SNZB	0x3,2
  087C    287E    JP	0x7E
705:              				{
706:              					CakeHeat();	  //蛋糕
  087D    28DD    JP	0xDD
707:              				}
708:              				else
709:              				{
710:              					PressureHeat();	 //压力	
  087E    29B9    JP	0x1B9
711:              				}			
712:              			}
713:              			else
714:              			{
715:              				BotHeatOff();	
716:              			}
717:              			break;
718:              
719:              		case KEEP_WARM_MODE: 
720:              			//保温模式
721:              			KeepWarmHeat(); 
  087F    2800    JP	0x0
722:              			break;	
  0880    086A    LD	A,0x6A
  0881    3A03    XORIA	0x3
  0882    1903    SZB	0x3,2
  0883    285D    JP	0x5D
  0884    3A07    XORIA	0x7
  0885    1903    SZB	0x3,2
  0886    287F    JP	0x7F
  0887    3A01    XORIA	0x1
  0888    1903    SZB	0x3,2
  0889    2854    JP	0x54
  088A    2845    JP	0x45
  088B    0008    RET
723:              				
724:              		default: BotHeatOff(); break;		
725:              	}
726:              }
727:              
728:              /*****************************************************************
729:               @fun:      Relay_Duty_Control
730:               @brief:    继电器动作类型控制函数  主函数500ms调用
731:               @param:    None                             
732:               @retval:   None
733:              *****************************************************************/
734:              void Relay_Duty_Control(void)
735:              {	
736:              	//全功率加热
737:              	if(b_BotHeatOn == TRUE)
  0F02    1EF1    SNZB	0x71,5
  0F03    2F40    JP	0x740
738:              	{
739:              		//端口输出低且过零检测没有完成
740:              		if(REL_PORT == 0 && b_ZeroTimeout == 0 && b_Zero == 0 && RelWaitCnt >= 4000)
  0F04    1283    CLRB	0x3,5
  0F05    2F31    JP	0x731
741:              		{
742:              			b_Zero_EN = 1;      //使能过零检测
  0F3D    15F2    SETB	0x72,3
743:              			b_RelType = 1;      //继电器开标志
  0F3E    1471    SETB	0x71,0
744:              		}	
745:              	}
  0F3F    0008    RET
746:              	else     //间歇或者不加热
747:              	{
748:              		//间歇加热
749:              		if(b_BotHeatEn == TRUE)
  0F40    1B71    SZB	0x71,6
  0F41    2F06    JP	0x706
750:              		{
751:              			HeatCnt500ms++;
  0F06    1283    CLRB	0x3,5
  0F07    0AC5    INCR	0x45
752:              			if(HeatCnt500ms < RelOffCnt)
  0F08    0846    LD	A,0x46
  0F09    0245    SUBA	0x45
  0F0A    1803    SZB	0x3,0
  0F0B    2F1F    JP	0x71F
  0F0C    2F10    JP	0x710
753:              			{
754:              				if(REL_PORT == 1 && b_ZeroTimeout == 0 && b_Zero == 0 && RelWaitCnt >= 4000)
755:              				{
756:              					b_Zero_EN = 1;    //使能过零检测
  0F1C    15F2    SETB	0x72,3
757:              					b_RelType = 0;    //继电器关标志
  0F1D    1071    CLRB	0x71,0
  0F1E    0008    RET
758:              				}		
759:              			}
760:              			else
761:              			{			
762:              				if(HeatCnt500ms >= (RelOffCnt + RelOnCnt))
  0F1F    0846    LD	A,0x46
  0F20    1683    SETB	0x3,5
  0F21    074E    ADDA	0x4E
  0F22    1283    CLRB	0x3,5
  0F23    00DA    LD	0x5A,A
  0F24    01DB    CLR	0x5B
  0F25    0DDB    RLCR	0x5B
  0F26    085B    LD	A,0x5B
  0F27    3A80    XORIA	0x80
  0F28    3C80    SUBIA	0x80
  0F29    1D03    SNZB	0x3,2
  0F2A    2F2D    JP	0x72D
  0F2B    085A    LD	A,0x5A
  0F2C    0245    SUBA	0x45
  0F2D    1803    SZB	0x3,0
  0F2E    2F0D    JP	0x70D
763:              				{
764:              					HeatCnt500ms = 0;	
  0F0D    1283    CLRB	0x3,5
  0F0E    1303    CLRB	0x3,6
  0F0F    01C5    CLR	0x45
765:              					if(REL_PORT == 1 && b_ZeroTimeout == 0 && b_Zero == 0 && RelWaitCnt >= 4000)
  0F10    1887    SZB	0x7,1
  0F11    1972    SZB	0x72,2
  0F12    0008    RET
  0F13    1872    SZB	0x72,0
  0F14    0008    RET
  0F15    300F    LDIA	0xF
  0F16    027A    SUBA	0x7A
  0F17    30A0    LDIA	0xA0
  0F18    1903    SZB	0x3,2
  0F19    0279    SUBA	0x79
  0F1A    1C03    SNZB	0x3,0
  0F1B    0008    RET
766:              					{
767:              						b_Zero_EN = 1;    //使能过零检测
768:              						b_RelType = 0;    //继电器关标志
769:              					}
770:              					
771:              				}
772:              				else
773:              				{	
774:              					if(REL_PORT == 0 && b_ZeroTimeout == 0 && b_Zero == 0 && RelWaitCnt >= 4000)
  0F2F    1283    CLRB	0x3,5
  0F30    1303    CLRB	0x3,6
  0F31    1C87    SNZB	0x7,1
  0F32    1972    SZB	0x72,2
  0F33    0008    RET
  0F34    1872    SZB	0x72,0
  0F35    0008    RET
  0F36    300F    LDIA	0xF
  0F37    027A    SUBA	0x7A
  0F38    30A0    LDIA	0xA0
  0F39    1903    SZB	0x3,2
  0F3A    0279    SUBA	0x79
  0F3B    1C03    SNZB	0x3,0
  0F3C    0008    RET
775:              					{
776:              						b_Zero_EN = 1;    //使能过零检测
777:              						b_RelType = 1;    //继电器开标志
778:              					}
779:              				}				
780:              			}		
781:              		}
782:              		else    //不加热
783:              		{
784:              			HeatCnt500ms = 0;
  0F42    1283    CLRB	0x3,5
  0F43    01C5    CLR	0x45
785:              			//压力开关断开情况下 不检测过零直接动作
786:              			if(REL_PORT == 1 && b_PressureOn == 1 && RelWaitCnt >= 4000)
  0F44    1887    SZB	0x7,1
  0F45    1EF2    SNZB	0x72,5
  0F46    2F10    JP	0x710
  0F47    300F    LDIA	0xF
  0F48    027A    SUBA	0x7A
  0F49    30A0    LDIA	0xA0
  0F4A    1903    SZB	0x3,2
  0F4B    0279    SUBA	0x79
  0F4C    1C03    SNZB	0x3,0
  0F4D    2F10    JP	0x710
787:              			{
788:              				b_Rel_NoZero = 1;   //不检测过零直接动作标志位
  0F4E    17F0    SETB	0x70,7
789:              			}				
  0F4F    0008    RET
790:              			else if(REL_PORT == 1 && b_ZeroTimeout == 0 && b_Zero == 0 && RelWaitCnt >= 4000)
791:              			{
792:              				b_Zero_EN = 1;       //使能过零检测
793:              				b_RelType = 0;       //继电器关标志
794:              			}				
795:              		}		
796:              	}		
797:              }
798:              
799:              /*****************************************************************
800:               @fun:      Operate_Relay_IO
801:               @brief:    继电器IO输出操作函数  中断250us调用
802:               @param:    None                             
803:               @retval:   None
804:              *****************************************************************/
805:              void Operate_Relay_IO(void)
806:              {
807:              	//继电器相邻动作定时
808:              	if(++RelWaitCnt >= 4000)
  0148    0AF9    INCR	0x79
  0149    1903    SZB	0x3,2
  014A    0AFA    INCR	0x7A
  014B    300F    LDIA	0xF
  014C    027A    SUBA	0x7A
  014D    30A0    LDIA	0xA0
  014E    1903    SZB	0x3,2
  014F    0279    SUBA	0x79
  0150    1C03    SNZB	0x3,0
  0151    2956    JP	0x156
809:              	{
810:              		RelWaitCnt = 4000;     //限制上限	
  0152    30A0    LDIA	0xA0
  0153    00F9    LD	0x79,A
  0154    300F    LDIA	0xF
  0155    00FA    LD	0x7A,A
811:              	}		
812:              	//压力开关断开时继电器关闭	
813:              	if(b_Rel_NoZero)
  0156    1FF0    SNZB	0x70,7
  0157    295A    JP	0x15A
814:              	{
815:              		b_Rel_NoZero = 0;
  0158    13F0    CLRB	0x70,7
  0159    2975    JP	0x175
816:              		REL_OFF;          //关闭继电器
817:              		RelWaitCnt = 0;   //继电器间隔动作时间清零			
  0176    01F9    CLR	0x79
  0177    01FA    CLR	0x7A
818:              	}
819:              	else if(b_Zero)       //获取零点后延时
  015A    1C72    SNZB	0x72,0
  015B    2967    JP	0x167
820:              	{
821:              		//开启延时5.25ms	
822:              		if(b_RelType)	
  015C    1C71    SNZB	0x71,0
  015D    295E    JP	0x15E
823:              		{
824:              			if(++ZeroDeley >= 21)     //21*250us=5.25ms  
  015E    3015    LDIA	0x15
  015F    0ABB    INCR	0x3B
  0160    023B    SUBA	0x3B
  0161    1C03    SNZB	0x3,0
  0162    2978    JP	0x178
825:              			{
826:              				ZeroDeley = 0;
  0163    01BB    CLR	0x3B
827:              				b_ZeroDeley_OK = 1;
  0164    1770    SETB	0x70,6
828:              				b_Zero = 0;	
  0165    1072    CLRB	0x72,0
  0166    2978    JP	0x178
829:              			}				
830:              		}
831:              		else                          //关闭延时5.25ms
832:              		{
833:              			if(++ZeroDeley >= 21)     
834:              			{
835:              				ZeroDeley = 0;
836:              				b_ZeroDeley_OK = 1;
837:              				b_Zero = 0;	
838:              			}				
839:              		}
840:              	}
841:              	else if(b_ZeroTimeout == 1)     //过零检测超时,继电器强制动作
  0167    1D72    SNZB	0x72,2
  0168    2978    JP	0x178
842:              	{
843:              		b_ZeroTimeout = 0;
  0169    1172    CLRB	0x72,2
844:              		ZeroTimeoutCnt++;         //记录强制动作次数
  016A    0ABA    INCR	0x3A
845:              		if(ZeroTimeoutCnt >= 254)
  016B    30FE    LDIA	0xFE
  016C    023A    SUBA	0x3A
  016D    1C03    SNZB	0x3,0
  016E    2971    JP	0x171
846:              		{
847:              			ZeroTimeoutCnt = 254;
  016F    30FE    LDIA	0xFE
  0170    00BA    LD	0x3A,A
848:              		}
849:              		
850:              		if(b_RelType)
  0171    1C71    SNZB	0x71,0
  0172    2975    JP	0x175
851:              		{
852:              			REL_ON;           //开启继电器
  0173    1487    SETB	0x7,1
  0174    2976    JP	0x176
853:              			RelWaitCnt = 0;   //继电器间隔动作时间清零  
854:              		}
855:              		else
856:              		{
857:              			REL_OFF;   //关闭继电器
  0175    1087    CLRB	0x7,1
858:              			RelWaitCnt = 0;   //继电器间隔动作时间清零 
859:              		}						
860:              	}
861:              		
862:              	//延时完成
863:              	if(b_ZeroDeley_OK)
  0178    1F70    SNZB	0x70,6
  0179    0008    RET
864:              	{
865:              		b_ZeroDeley_OK = 0;
  017A    1370    CLRB	0x70,6
866:              		
867:              		if(b_RelType)
  017B    1C71    SNZB	0x71,0
  017C    2981    JP	0x181
868:              		{
869:              			REL_ON;           //开启继电器
  017D    1487    SETB	0x7,1
870:              			RelWaitCnt = 0;   //继电器间隔动作时间清零 
  017E    01F9    CLR	0x79
  017F    01FA    CLR	0x7A
871:              		}
  0180    0008    RET
872:              		else
873:              		{
874:              			REL_OFF;          //关闭继电器
  0181    1087    CLRB	0x7,1
  0182    297E    JP	0x17E
875:              			RelWaitCnt = 0;   //继电器间隔动作时间清零 
876:              		}
877:              	}	
878:              }
879:              
880:              
881:              
882:              
883:              
884:              
885:                
886:                
887:                
888:                
---- stringtab ------------------------------------------------------------------
  1800    1BFF    SZB	0x7F,7
  1801    280A    JP	0xA
  1802    1383    CLRB	0x3,7
  1803    187F    SZB	0x7F,0
  1804    1783    SETB	0x3,7
  1805    0800    LD	A,0x0
  1806    0A84    INCR	0x4
  1807    1903    SZB	0x3,2
  1808    0AFF    INCR	0x7F
  1809    0008    RET
  180A    087F    LD	A,0x7F
  180B    397F    ANDIA	0x7F
  180C    008A    LD	0xA,A
  180D    0804    LD	A,0x4
  180E    0A84    INCR	0x4
  180F    1903    SZB	0x3,2
  1810    0AFF    INCR	0x7F
  1811    0082    LD	0x2,A
---- reset_enter ------------------------------------------------------------------
  0000    120A    CLRB	0xA,4
  0001    118A    CLRB	0xA,3
  0002    280C    JP	0xC
  000C    120A    CLRB	0xA,4
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    30FF    LDIA	0xFF
  0010    00EB    LD	0x6B,A
  0011    00EC    LD	0x6C,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30D0    LDIA	0xD0
  0016    120A    CLRB	0xA,4
  0017    118A    CLRB	0xA,3
  0018    25FF    CALL	0x5FF
  001B    3020    LDIA	0x20
  001C    0084    LD	0x4,A
  001D    305A    LDIA	0x5A
  001E    120A    CLRB	0xA,4
  001F    118A    CLRB	0xA,3
  0020    25FF    CALL	0x5FF
  0021    01F9    CLR	0x79
  0022    01FA    CLR	0x7A
  0023    01FB    CLR	0x7B
  0024    01FC    CLR	0x7C
  0025    01F0    CLR	0x70
  0026    01F1    CLR	0x71
  0027    01F2    CLR	0x72
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F7    LD	0x77,A
  0007    080A    LD	A,0xA
  0008    00F8    LD	0x78,A
  0009    120A    CLRB	0xA,4
  000A    118A    CLRB	0xA,3
  000B    282C    JP	0x2C
---- common_function ------------------------------------------------------------------
  0028    0183    CLR	0x3
  0029    120A    CLRB	0xA,4
  002A    118A    CLRB	0xA,3
  002B    2C68    JP	0x468
  027A    1720    SETB	0x20,6
  027B    1721    SETB	0x21,6
  027C    1722    SETB	0x22,6
  027D    1723    SETB	0x23,6
  027E    17A2    SETB	0x22,7
  027F    17A1    SETB	0x21,7
  0280    0008    RET
  0352    00DB    LD	0x5B,A
  0353    3001    LDIA	0x1
  0354    0ADB    INCR	0x5B
  0355    00DC    LD	0x5C,A
  0356    3000    LDIA	0x0
  0357    00DD    LD	0x5D,A
  0358    2B5C    JP	0x35C
  0359    1003    CLRB	0x3,0
  035A    0DDC    RLCR	0x5C
  035B    0DDD    RLCR	0x5D
  035C    0BDB    SZDECR	0x5B
  035D    2B59    JP	0x359
  035E    085C    LD	A,0x5C
  035F    04A7    ORR	0x27
  0360    085D    LD	A,0x5D
  0361    04A8    ORR	0x28
  0362    0008    RET
  05FF    0064    CLRWDT
  0600    0180    CLR	0x0
  0601    0A84    INCR	0x4
  0602    0604    XORA	0x4
  0603    1903    SZB	0x3,2
  0604    3400    RET	0x0
  0605    0604    XORA	0x4
  0606    2E00    JP	0x600
  0F88    00D6    LD	0x56,A
  0F89    307D    LDIA	0x7D
  0F8A    00D5    LD	0x55,A
  0F8B    0856    LD	A,0x56
  0F8C    00D4    LD	0x54,A
  0F8D    0855    LD	A,0x55
  0F8E    00D3    LD	0x53,A
  0F8F    0008    RET
  0F90    00D7    LD	0x57,A
  0F91    300C    LDIA	0xC
  0F92    00D6    LD	0x56,A
  0F93    307D    LDIA	0x7D
  0F94    00D5    LD	0x55,A
  0F95    0856    LD	A,0x56
  0F96    00D4    LD	0x54,A
  0F97    0855    LD	A,0x55
  0F98    00D3    LD	0x53,A
  0F99    0008    RET
  0F9A    307D    LDIA	0x7D
  0F9B    00D5    LD	0x55,A
  0F9C    0856    LD	A,0x56
  0F9D    00D4    LD	0x54,A
  0F9E    0855    LD	A,0x55
  0F9F    00D3    LD	0x53,A
  0FA0    0008    RET
  0FD5    00D5    LD	0x55,A
  0FD6    0856    LD	A,0x56
  0FD7    00D4    LD	0x54,A
  0FD8    0855    LD	A,0x55
  0FD9    00D3    LD	0x53,A
  0FDA    0008    RET
  1792    3E78    ADDIA	0x78
  1793    0084    LD	0x4,A
  1794    3099    LDIA	0x99
  1795    1803    SZB	0x3,0
  1796    3E01    ADDIA	0x1
  1797    00FF    LD	0x7F,A
  1798    0008    RET
  1799    01E3    CLR	0x63
  179A    1003    CLRB	0x3,0
  179B    0DE2    RLCR	0x62
  179C    0DE3    RLCR	0x63
  179D    083D    LD	A,0x3D
  179E    00E4    LD	0x64,A
  179F    01E5    CLR	0x65
  17A0    1003    CLRB	0x3,0
  17A1    0DE4    RLCR	0x64
  17A2    0DE5    RLCR	0x65
  17A3    1003    CLRB	0x3,0
  17A4    0DE4    RLCR	0x64
  17A5    0DE5    RLCR	0x65
  17A6    0865    LD	A,0x65
  17A7    3A80    XORIA	0x80
  17A8    00E6    LD	0x66,A
  17A9    0863    LD	A,0x63
  17AA    3A80    XORIA	0x80
  17AB    0266    SUBA	0x66
  17AC    1D03    SNZB	0x3,2
  17AD    2FB0    JP	0x7B0
  17AE    0862    LD	A,0x62
  17AF    0264    SUBA	0x64
  17B0    1C03    SNZB	0x3,0
  17B1    2FB5    JP	0x7B5
  17B2    1283    CLRB	0x3,5
  17B3    1303    CLRB	0x3,6
  17B4    1626    SETB	0x26,4
  17B5    1283    CLRB	0x3,5
  17B6    1303    CLRB	0x3,6
  17B7    0008    RET
  17B8    3E44    ADDIA	0x44
  17B9    0084    LD	0x4,A
  17BA    3099    LDIA	0x99
  17BB    1803    SZB	0x3,0
  17BC    3E01    ADDIA	0x1
  17BD    00FF    LD	0x7F,A
  17BE    0008    RET
  17BF    3EA0    ADDIA	0xA0
  17C0    0084    LD	0x4,A
  17C1    1383    CLRB	0x3,7
  17C2    0800    LD	A,0x0
  17C3    390F    ANDIA	0xF
  17C4    0008    RET
  17C5    00E2    LD	0x62,A
  17C6    01E3    CLR	0x63
  17C7    1003    CLRB	0x3,0
  17C8    0DE2    RLCR	0x62
  17C9    0DE3    RLCR	0x63
  17CA    1003    CLRB	0x3,0
  17CB    0DE2    RLCR	0x62
  17CC    0DE3    RLCR	0x63
  17CD    0863    LD	A,0x63
  17CE    3A80    XORIA	0x80
  17CF    00E4    LD	0x64,A
  17D0    0008    RET
  17D1    3EA0    ADDIA	0xA0
  17D2    0084    LD	0x4,A
  17D3    1383    CLRB	0x3,7
  17D4    0E00    SWAPA	0x0
  17D5    390F    ANDIA	0xF
  17D6    0008    RET
  17D7    01DD    CLR	0x5D
  17D8    07DC    ADDR	0x5C
  17D9    1803    SZB	0x3,0
  17DA    0ADD    INCR	0x5D
  17DB    303C    LDIA	0x3C
  17DC    00DA    LD	0x5A,A
  17DD    01DB    CLR	0x5B
  17DE    0008    RET
  17DF    01DD    CLR	0x5D
  17E0    07DC    ADDR	0x5C
  17E1    1803    SZB	0x3,0
  17E2    0ADD    INCR	0x5D
  17E3    303C    LDIA	0x3C
  17E4    00DA    LD	0x5A,A
  17E5    01DB    CLR	0x5B
  17E6    0008    RET
  17E7    085A    LD	A,0x5A
  17E8    00B8    LD	0x38,A
  17E9    3064    LDIA	0x64
  17EA    00DA    LD	0x5A,A
  17EB    01DB    CLR	0x5B
  17EC    1003    CLRB	0x3,0
  17ED    0008    RET
  17EE    3000    LDIA	0x0
  17EF    1803    SZB	0x3,0
  17F0    3001    LDIA	0x1
  17F1    00DC    LD	0x5C,A
  17F2    01DD    CLR	0x5D
  17F3    0008    RET
  17F4    04A2    ORR	0x22
  17F5    0832    LD	A,0x32
  17F6    00DF    LD	0x5F,A
  17F7    3001    LDIA	0x1
  17F8    1003    CLRB	0x3,0
  17F9    0008    RET
  17FA    3000    LDIA	0x0
  17FB    1803    SZB	0x3,0
  17FC    3001    LDIA	0x1
  17FD    00DC    LD	0x5C,A
  17FE    01DD    CLR	0x5D
  17FF    0008    RET
  1812    3400    RET	0x0
  1813    3400    RET	0x0
  1814    3400    RET	0x0
  1815    3400    RET	0x0
  1816    3400    RET	0x0
  1817    3400    RET	0x0
  1818    3400    RET	0x0
  1819    3400    RET	0x0
  181A    3401    RET	0x1
  181B    3403    RET	0x3
  181C    3405    RET	0x5
  181D    3407    RET	0x7
  181E    3409    RET	0x9
  181F    340B    RET	0xB
  1820    340D    RET	0xD
  1821    340E    RET	0xE
  1822    3410    RET	0x10
  1823    3411    RET	0x11
  1824    3413    RET	0x13
  1825    3414    RET	0x14
  1826    3415    RET	0x15
  1827    3416    RET	0x16
  1828    3418    RET	0x18
  1829    3419    RET	0x19
  182A    341A    RET	0x1A
  182B    341B    RET	0x1B
  182C    341C    RET	0x1C
  182D    341D    RET	0x1D
  182E    341E    RET	0x1E
  182F    341F    RET	0x1F
  1830    3420    RET	0x20
  1831    3420    RET	0x20
  1832    3421    RET	0x21
  1833    3422    RET	0x22
  1834    3423    RET	0x23
  1835    3424    RET	0x24
  1836    3425    RET	0x25
  1837    3425    RET	0x25
  1838    3426    RET	0x26
  1839    3427    RET	0x27
  183A    3428    RET	0x28
  183B    3428    RET	0x28
  183C    3429    RET	0x29
  183D    342A    RET	0x2A
  183E    342A    RET	0x2A
  183F    342B    RET	0x2B
  1840    342C    RET	0x2C
  1841    342C    RET	0x2C
  1842    342D    RET	0x2D
  1843    342E    RET	0x2E
  1844    342E    RET	0x2E
  1845    342F    RET	0x2F
  1846    3430    RET	0x30
  1847    3430    RET	0x30
  1848    3431    RET	0x31
  1849    3431    RET	0x31
  184A    3432    RET	0x32
  184B    3433    RET	0x33
  184C    3433    RET	0x33
  184D    3434    RET	0x34
  184E    3434    RET	0x34
  184F    3435    RET	0x35
  1850    3435    RET	0x35
  1851    3436    RET	0x36
  1852    3436    RET	0x36
  1853    3437    RET	0x37
  1854    3438    RET	0x38
  1855    3438    RET	0x38
  1856    3439    RET	0x39
  1857    3439    RET	0x39
  1858    343A    RET	0x3A
  1859    343A    RET	0x3A
  185A    343B    RET	0x3B
  185B    343B    RET	0x3B
  185C    343C    RET	0x3C
  185D    343C    RET	0x3C
  185E    343D    RET	0x3D
  185F    343D    RET	0x3D
  1860    343E    RET	0x3E
  1861    343E    RET	0x3E
  1862    343F    RET	0x3F
  1863    343F    RET	0x3F
  1864    3440    RET	0x40
  1865    3441    RET	0x41
  1866    3441    RET	0x41
  1867    3442    RET	0x42
  1868    3442    RET	0x42
  1869    3443    RET	0x43
  186A    3443    RET	0x43
  186B    3444    RET	0x44
  186C    3444    RET	0x44
  186D    3444    RET	0x44
  186E    3445    RET	0x45
  186F    3445    RET	0x45
  1870    3446    RET	0x46
  1871    3446    RET	0x46
  1872    3447    RET	0x47
  1873    3447    RET	0x47
  1874    3448    RET	0x48
  1875    3448    RET	0x48
  1876    3449    RET	0x49
  1877    3449    RET	0x49
  1878    344A    RET	0x4A
  1879    344A    RET	0x4A
  187A    344B    RET	0x4B
  187B    344B    RET	0x4B
  187C    344C    RET	0x4C
  187D    344C    RET	0x4C
  187E    344D    RET	0x4D
  187F    344D    RET	0x4D
  1880    344E    RET	0x4E
  1881    344E    RET	0x4E
  1882    344F    RET	0x4F
  1883    344F    RET	0x4F
  1884    3450    RET	0x50
  1885    3450    RET	0x50
  1886    3451    RET	0x51
  1887    3451    RET	0x51
  1888    3452    RET	0x52
  1889    3452    RET	0x52
  188A    3453    RET	0x53
  188B    3453    RET	0x53
  188C    3453    RET	0x53
  188D    3454    RET	0x54
  188E    3454    RET	0x54
  188F    3455    RET	0x55
  1890    3455    RET	0x55
  1891    3456    RET	0x56
  1892    3456    RET	0x56
  1893    3457    RET	0x57
  1894    3457    RET	0x57
  1895    3458    RET	0x58
  1896    3458    RET	0x58
  1897    3459    RET	0x59
  1898    3459    RET	0x59
  1899    345A    RET	0x5A
  189A    345A    RET	0x5A
  189B    345B    RET	0x5B
  189C    345B    RET	0x5B
  189D    345C    RET	0x5C
  189E    345C    RET	0x5C
  189F    345D    RET	0x5D
  18A0    345D    RET	0x5D
  18A1    345E    RET	0x5E
  18A2    345E    RET	0x5E
  18A3    345F    RET	0x5F
  18A4    345F    RET	0x5F
  18A5    3460    RET	0x60
  18A6    3461    RET	0x61
  18A7    3461    RET	0x61
  18A8    3462    RET	0x62
  18A9    3462    RET	0x62
  18AA    3463    RET	0x63
  18AB    3463    RET	0x63
  18AC    3464    RET	0x64
  18AD    3464    RET	0x64
  18AE    3465    RET	0x65
  18AF    3466    RET	0x66
  18B0    3466    RET	0x66
  18B1    3467    RET	0x67
  18B2    3467    RET	0x67
  18B3    3468    RET	0x68
  18B4    3468    RET	0x68
  18B5    3469    RET	0x69
  18B6    3469    RET	0x69
  18B7    346A    RET	0x6A
  18B8    346B    RET	0x6B
  18B9    346B    RET	0x6B
  18BA    346C    RET	0x6C
  18BB    346C    RET	0x6C
  18BC    346D    RET	0x6D
  18BD    346E    RET	0x6E
  18BE    346E    RET	0x6E
  18BF    346F    RET	0x6F
  18C0    3470    RET	0x70
  18C1    3470    RET	0x70
  18C2    3471    RET	0x71
  18C3    3472    RET	0x72
  18C4    3472    RET	0x72
  18C5    3473    RET	0x73
  18C6    3474    RET	0x74
  18C7    3474    RET	0x74
  18C8    3475    RET	0x75
  18C9    3476    RET	0x76
  18CA    3476    RET	0x76
  18CB    3477    RET	0x77
  18CC    3478    RET	0x78
  18CD    3478    RET	0x78
  18CE    3479    RET	0x79
  18CF    347A    RET	0x7A
  18D0    347B    RET	0x7B
  18D1    347B    RET	0x7B
  18D2    347C    RET	0x7C
  18D3    347D    RET	0x7D
  18D4    347E    RET	0x7E
  18D5    347F    RET	0x7F
  18D6    347F    RET	0x7F
  18D7    3480    RET	0x80
  18D8    3481    RET	0x81
  18D9    3482    RET	0x82
  18DA    3483    RET	0x83
  18DB    3484    RET	0x84
  18DC    3485    RET	0x85
  18DD    3486    RET	0x86
  18DE    3487    RET	0x87
  18DF    3488    RET	0x88
  18E0    3489    RET	0x89
  18E1    348A    RET	0x8A
  18E2    348B    RET	0x8B
  18E3    348C    RET	0x8C
  18E4    348D    RET	0x8D
  18E5    348E    RET	0x8E
  18E6    348F    RET	0x8F
  18E7    3490    RET	0x90
  18E8    3492    RET	0x92
  18E9    3493    RET	0x93
  18EA    3494    RET	0x94
  18EB    3495    RET	0x95
  18EC    3496    RET	0x96
  18ED    3498    RET	0x98
  18EE    3499    RET	0x99
  18EF    349A    RET	0x9A
  18F0    349C    RET	0x9C
  18F1    349D    RET	0x9D
  18F2    349F    RET	0x9F
  18F3    34A0    RET	0xA0
  18F4    34A2    RET	0xA2
  18F5    34A4    RET	0xA4
  18F6    34A6    RET	0xA6
  18F7    34A7    RET	0xA7
  18F8    34A9    RET	0xA9
  18F9    34AB    RET	0xAB
  18FA    34AD    RET	0xAD
  18FB    34B0    RET	0xB0
  18FC    34B2    RET	0xB2
  18FD    34B4    RET	0xB4
  18FE    34B7    RET	0xB7
  18FF    34BA    RET	0xBA
  1900    34BD    RET	0xBD
  1901    34C0    RET	0xC0
  1902    34C3    RET	0xC3
  1903    34C6    RET	0xC6
  1904    34CA    RET	0xCA
  1905    34CE    RET	0xCE
  1906    34D3    RET	0xD3
  1907    34D8    RET	0xD8
  1908    3400    RET	0x0
  1909    3400    RET	0x0
  190A    3400    RET	0x0
  190B    3400    RET	0x0
  190C    3410    RET	0x10
  190D    3412    RET	0x12
  190E    3414    RET	0x14
  190F    3400    RET	0x0
  1910    340F    RET	0xF
  1911    3411    RET	0x11
  1912    3415    RET	0x15
  1913    3400    RET	0x0
  1914    3405    RET	0x5
  1915    340A    RET	0xA
  1916    340F    RET	0xF
  1917    3400    RET	0x0
  1918    340A    RET	0xA
  1919    340F    RET	0xF
  191A    3414    RET	0x14
  191B    3400    RET	0x0
  191C    3414    RET	0x14
  191D    341C    RET	0x1C
  191E    3423    RET	0x23
  191F    3400    RET	0x0
  1920    340F    RET	0xF
  1921    3414    RET	0x14
  1922    3419    RET	0x19
  1923    3400    RET	0x0
  1924    340C    RET	0xC
  1925    340F    RET	0xF
  1926    3414    RET	0x14
  1927    3400    RET	0x0
  1928    340F    RET	0xF
  1929    3414    RET	0x14
  192A    341E    RET	0x1E
  192B    3400    RET	0x0
  192C    3412    RET	0x12
  192D    3419    RET	0x19
  192E    341E    RET	0x1E
  192F    3400    RET	0x0
  1930    3414    RET	0x14
  1931    3419    RET	0x19
  1932    3423    RET	0x23
  1933    3400    RET	0x0
  1934    341E    RET	0x1E
  1935    3423    RET	0x23
  1936    342D    RET	0x2D
  1937    3400    RET	0x0
  1938    3428    RET	0x28
  1939    3428    RET	0x28
  193A    3428    RET	0x28
  193B    3400    RET	0x0
  193C    3408    RET	0x8
  193D    3408    RET	0x8
  193E    3408    RET	0x8
  193F    3400    RET	0x0
  1940    3408    RET	0x8
  1941    3408    RET	0x8
  1942    3408    RET	0x8
  1943    3400    RET	0x0
  1944    3401    RET	0x1
  1945    3401    RET	0x1
  1946    3401    RET	0x1
  1947    3400    RET	0x0
  1948    3401    RET	0x1
  1949    3401    RET	0x1
  194A    3401    RET	0x1
  194B    3400    RET	0x0
  194C    3400    RET	0x0
  194D    3401    RET	0x1
  194E    3401    RET	0x1
  194F    3401    RET	0x1
  1950    3400    RET	0x0
  1951    3400    RET	0x0
  1952    3401    RET	0x1
  1953    3403    RET	0x3
  1954    3400    RET	0x0
  1955    3400    RET	0x0
  1956    3400    RET	0x0
  1957    3407    RET	0x7
  1958    3400    RET	0x0
  1959    3400    RET	0x0
  195A    3400    RET	0x0
  195B    340E    RET	0xE
  195C    3400    RET	0x0
  195D    3400    RET	0x0
  195E    3408    RET	0x8
  195F    340C    RET	0xC
  1960    3400    RET	0x0
  1961    3408    RET	0x8
  1962    3408    RET	0x8
  1963    3408    RET	0x8
  1964    3408    RET	0x8
  1965    3408    RET	0x8
  1966    3408    RET	0x8
  1967    3400    RET	0x0
  1968    3418    RET	0x18
  1969    3408    RET	0x8
  196A    3400    RET	0x0
  196B    3400    RET	0x0
  196C    3438    RET	0x38
  196D    3400    RET	0x0
  196E    3400    RET	0x0
  196F    3400    RET	0x0
  1970    3431    RET	0x31
  1971    3400    RET	0x0
  1972    3400    RET	0x0
  1973    3400    RET	0x0
  1974    3421    RET	0x21
  1975    3401    RET	0x1
  1976    3400    RET	0x0
  1977    3400    RET	0x0
  1978    343F    RET	0x3F
  1979    3406    RET	0x6
  197A    345B    RET	0x5B
  197B    344F    RET	0x4F
  197C    3466    RET	0x66
  197D    346D    RET	0x6D
  197E    347D    RET	0x7D
  197F    3407    RET	0x7
  1980    347F    RET	0x7F
  1981    346F    RET	0x6F
  1982    3477    RET	0x77
  1983    347C    RET	0x7C
  1984    3439    RET	0x39
  1985    345E    RET	0x5E
  1986    3479    RET	0x79
  1987    3471    RET	0x71
  1FF8    3400    RET	0x0
  1FF9    3400    RET	0x0
  1FFA    3400    RET	0x0
  1FFB    3400    RET	0x0
  1FFC    3400    RET	0x0
  1FFD    3400    RET	0x0
  1FFE    3400    RET	0x0
